<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[陈浩的技术博客]]></title>
  <link href="http://hawk0620.github.io/atom.xml" rel="self"/>
  <link href="http://hawk0620.github.io/"/>
  <updated>2018-03-23T00:32:56+08:00</updated>
  <id>http://hawk0620.github.io/</id>
  <author>
    <name><![CDATA[Hawk0620]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[探秘 Mach-O 文件]]></title>
    <link href="http://hawk0620.github.io/blog/2018/03/22/study-mach-o-file/"/>
    <updated>2018-03-22T23:06:52+08:00</updated>
    <id>http://hawk0620.github.io/blog/2018/03/22/study-mach-o-file</id>
    <content type="html"><![CDATA[<p>之前负责项目的包体积优化学习了 Mach-O 文件的格式，那么 Mach-O 究竟是怎么样的文件，知道它的组成之后我们又能做点什么？本文会从 Mach-O 文件的介绍讲起，再看看认识它后的一些实际应用。</p>

<!--more-->


<p>由于本文篇幅有点长，这里添加了文章导航方便阅读</p>

<ul>
<li><a href="#Mach-O%20%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F">Mach-O 文件格式</a></li>
<li><a href="#%E5%87%8F%E5%B0%91%E5%8C%85%E5%A4%A7%E5%B0%8F">减少包大小</a></li>
<li><a href="#%E8%8E%B7%E5%8F%96%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88">获取调用堆栈</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E7%94%A8%20MachO%20%E6%96%87%E4%BB%B6%E5%85%B3%E8%81%94%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%E5%90%8D">如何用 MachO 文件关联类的方法名</a></li>
</ul>


<h3 id="Mach-O 文件格式">Mach-O 文件格式</h3>


<p>先让我们看看 Mach-O 的大致构成</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37776837-23a2b58c-2e21-11e8-8b97-f968d484319e.png" alt="" /></p>

<p>再使用 MachOView 一窥究竟</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37776371-15ac9b10-2e20-11e8-9dfe-850250c2a8bc.png" alt="" /></p>

<p>结合可知 Mach-O 文件包含了三部分内容：</p>

<ul>
<li>Header（头部），指明了 cpu 架构、大小端序、文件类型、Load Commands 个数等一些基本信息</li>
<li>Load Commands（加载命令)，正如官方的图所示，描述了怎样加载每个 Segment 的信息。在 Mach-O 文件中可以有多个 Segment，每个 Segment 可能包含一个或多个 Section。</li>
<li>Data（数据区），Segment 的具体数据，包含了代码和数据等。</li>
</ul>


<h4>Headers</h4>

<p>Mach-O 文件的头部定义如下：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37776955-6ac166f2-2e21-11e8-9408-e7a3836eff72.png" alt="" /></p>

<ul>
<li>magic 标志符 0xfeedface 是 32 位， 0xfeedfacf 是 64 位。</li>
<li>cputype 和 cpusubtype 确定 cpu 类型、平台</li>
<li>filetype 文件类型，可执行文件、符号文件（DSYM）、内核扩展等</li>
<li>ncmds 加载 Load Commands 的数量</li>
<li>flags dyld 加载的标志

<ul>
<li><code>MH_NOUNDEFS</code> 目标文件没有未定义的符号，</li>
<li><code>MH_DYLDLINK</code> 目标文件是动态链接输入文件，不能被再次静态链接,</li>
<li><code>MH_SPLIT_SEGS</code> 只读 segments 和 可读写 segments 分离，</li>
<li><code>MH_NO_HEAP_EXECUTION</code> 堆内存不可执行…</li>
</ul>
</li>
</ul>


<p>filetype 的定义有：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37776995-7e897378-2e21-11e8-9c86-913ba5277b39.png" alt="" /></p>

<p>flags 的定义有：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37777034-98bdef9e-2e21-11e8-900a-34108ae119fa.png" alt="" /></p>

<p>简单总结一下就是 Headers 能帮助校验 Mach-O 合法性和定位文件的运行环境。</p>

<h4>Load Commands</h4>

<p>Headers 之后就是 Load Commands，其占用的内存和加载命令的总数在 Headers 中已经指出。</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37777147-d5f832e8-2e21-11e8-8c69-8dba2d32a631.png" alt="" /></p>

<p>Load Commands 的定义比较简单：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37777211-f9635d98-2e21-11e8-9c0e-66560b6b3197.png" alt="" /></p>

<ul>
<li>cmd 字段，如上图它指出了 command 类型

<ul>
<li><code>LC_SEGMENT、LC_SEGMENT_64 </code> 将 segment 映射到进程的内存空间，</li>
<li><code>LC_UUID </code> 二进制文件 id，与符号表 uuid 对应，可用作符号表匹配，</li>
<li><code>LC_LOAD_DYLINKER</code> 启动动态加载器，</li>
<li><code>LC_SYMTAB </code> 描述在 <code>__LINKEDIT </code> 段的哪找字符串表、符号表，</li>
<li><code>LC_CODE_SIGNATURE</code> 代码签名等</li>
</ul>
</li>
<li>cmdsize 字段，主要用以计算出到下一个 command 的偏移量。</li>
</ul>


<h4>Segment &amp; Section</h4>

<p>这里先来看看 segment 的定义：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37777286-1b07ebf8-2e22-11e8-8587-4b4897f9dbc7.png" alt="" /></p>

<ul>
<li>cmd 就是上面分析的 command 类型</li>
<li>segname 在源码中定义的宏

<ul>
<li><code>#define  SEG_PAGEZERO    "__PAGEZERO" // 可执行文件捕获空指针的段 </code></li>
<li><code>#define  SEG_TEXT    "__TEXT" // 代码段，只读数据段 </code></li>
<li><code>#define  SEG_DATA    "__DATA"    // 数据段 </code></li>
<li><code>#define  SEG_LINKEDIT    "__LINKEDIT" // 包含动态链接器所需的符号、字符串表等数据 </code></li>
</ul>
</li>
<li>vmaddr 段的虚存地址（未偏移），由于 ALSR，程序会在进程加上一段偏移量（slide），真实的地址 = vm address + slide</li>
<li>vmsize 段的虚存大小</li>
<li>fileoff 段在文件的偏移</li>
<li>filesize 段在文件的大小</li>
<li>nsects 段中有多少个 section</li>
</ul>


<p>接着看看 section 的定义：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37777312-2f77f7f4-2e22-11e8-8736-12ab00714504.png" alt="" /></p>

<p><code>__Text</code> 和 <code>__Data</code> 都有自己的 section</p>

<ul>
<li>segname 就是所在段的名称</li>
<li>sectname section名称，部分列举：

<ul>
<li><code>Text.__text</code> 主程序代码</li>
<li><code>Text.__cstring</code> c 字符串</li>
<li><code>Text.__stubs</code> 桩代码</li>
<li><code>Text.__stub_helper</code></li>
<li><code>Data.__data</code> 初始化可变的数据</li>
<li><code>Data.__objc_imageinfo</code> 镜像信息 ，在运行时初始化时 <code>objc_init</code>，调用 <code>load_images</code> 加载新的镜像到 infolist 中<img src="https://user-images.githubusercontent.com/5633917/37777338-4106908e-2e22-11e8-94df-3328b570226f.png" alt="" /></li>
<li><code>Data.__la_symbol_ptr</code></li>
<li><code>Data.__nl_symbol_ptr</code></li>
<li><code>Data.__objc_classlist</code> 类列表</li>
<li><code>Data.__objc_classrefs</code> 引用的类</li>
</ul>
</li>
</ul>


<p>这节最后探究下 stubs，在 Xcode 中新建 C 项目，代码如下：</p>

<pre><code>#include &lt;stdio.h&gt;
int main(int argc, const char * argv[]) {
    printf("Hello, coder\n");
    return 0;
}
</code></pre>

<p>使用 <code>gcc -c main.c</code> 将其编译成 a.out 文件，调用 nm 命令查看 .o 文件的符号</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37777400-68692d3a-2e22-11e8-8d20-b42a4d88b86c.png" alt="" /></p>

<p>看到 <code>_printf </code> 是未定义的，也就是说并没有该函数的内存地址。nm 打印出的信息表明<code>dyld_stub_binder </code> 也是未定义的。
打开 Hopper 查看 .o 文件</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37777431-81613ff8-2e22-11e8-8ab5-ff4bbf8bffb0.png" alt="" /></p>

<p>可以看出 printf 会跳入 <code>__stubs</code> 中，地址也与 MachOView 看到的相对应</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37777470-96d8cd9c-2e22-11e8-8cea-cf107dbb7858.png" alt="" /></p>

<p>双击刚才  <code>__stubs</code>  中的地址，会跳转到 <code>__la_symbol_ptr</code></p>

<p><img src="https://user-images.githubusercontent.com/5633917/37777493-a96c4948-2e22-11e8-80f6-20bb35175ea5.png" alt="" /></p>

<p>在 MachOView 中查看 0x100001010 对应的数据为 0x10000f9c</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37777894-940abbe2-2e23-11e8-9000-2d1800633d4b.png" alt="" /></p>

<p>用 Hopper 搜索 0x10000f9c，跳转到 <code>stub_helper</code>，可知 <code>__la_symbol_ptr</code> 里的数据被 bind 成了  <code>stub_helper</code></p>

<p><img src="https://user-images.githubusercontent.com/5633917/37777951-b34195a8-2e23-11e8-93df-b659b770ba0f.png" alt="" /></p>

<p>由此可知，<code>__la_symbol_ptr</code> 中的数据被第一次调用时会通过 <code>dyld_stub_binder</code> 进行相关绑定，而 <code>__nl_symbol_ptr</code> 中的数据就是在动态库绑定时进行加载。</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37777997-d2a381fe-2e23-11e8-9ec0-3c6ab5e20447.png" alt="" /></p>

<p>所以 <code>__la_symbol_ptr</code> 中的数据在初始状态都被 bind 成  <code>stub_helper</code>，接着 <code>dyld_stub_binder </code> 会加载相应的动态链接库，执行具体的函数实现，此时 <code>__la_symbol_ptr</code> 也获取到了函数的真实地址，完成了一次近似懒加载的过程。</p>

<p>写到这里，算是快速过了一遍 Mach-O 文件的基本概念，接着聊聊可以怎样减少项目的体积。</p>

<h3 id="减少包大小">减少包大小</h3>


<p>iOS 的包主要由可执行文件、资源文件（图片）等文件组成，所以可以从这两大头文件入手优化。</p>

<h4>可执行文件瘦身</h4>

<p>我们的项目中难免会存在一些没使用的类或方法，由于 OC 的动态特性，编译器会对所有的源文件进行编译，找出并删除没用到的类或方法可以减少可执行文件大小。
上文中提到了 <code>__objc_classlist</code> 和 <code>__objc_classrefs </code>，它们分别表示项目中全部类列表和项目中被引用的类列表，那么取两者之差，就能删除一些项目中没使用的类文件。但是在删除过程中记住要在项目中全局搜索确认下，看看有没有通过字符串调用无引用的类的方法，原因还是 OC 是动态语言。
在看具体做法之前，顺带提一下我公司的项目组成。我们维护着俩客户端，共用着一个基础库（lib 库），可能有时由于产品的需求变更或者为了产品功能的预留导致 lib 库中只有着某个端使用的代码，我在上述的做法中对脚本做了稍微改进，以防删除了 lib 库的代码，导致另一个端跑不起来，下面介绍通用的做法：</p>

<ul>
<li>在控制台输入 <code>otool -v -s __objc_classlist </code> 和 <code>otool -v -s __objc_classrefs </code> 命令，逆向 <code>__DATA. __objc_classlist</code> 段和 <code>__DATA. __objc_classrefs </code> 段获取当前所有oc类和被引用的oc类。</li>
<li>取两者差集，得到没被引用的类的段地址</li>
<li>otool -o 二进制文件，获取段信息</li>
<li>通过脚本使用没被引用的类的段地址去段信息中匹配出具体类名</li>
</ul>


<h4>压缩图片资源</h4>

<p>这点就跟本文的主题没什么关系，不感兴趣可以略过。
压缩 app 中的图片是我做的另一个努力，虽然 Xcode 会压一遍，但是经我压缩后打包发现包还是会少个将近 1m，这里用到的工具是 ImageOptim，贴出我的三脚猫 python：</p>

<pre><code>all_file_size = 0
all_file_count = 0

def fileDriector(filePath):
    global all_file_size, all_file_count

    for file in os.listdir(filePath):
        if os.path.isdir(filePath + '/' + file):
            if file != 'Pods' and not file.startswith('.') and not file.endswith('.framework') \
                    and not file.endswith('.bundle') and not file.endswith('.a') and file != 'libs' \
                    or file.endswith('.xcassets') or file.endswith('.imageset'):
                the_path = filePath + '/' + file
                fileDriector(the_path)
        elif file.endswith('.png') or file.endswith('.jpg'):
            fileName = filePath + '/' + file

            comand_line = "echo %s | imageoptim" % fileName
            test = subprocess.Popen(comand_line, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            output = test.communicate()[0]

            numberList = re.findall('\.?\d+\.?\d*kb', output)
            lastSize = numberList[-1]

            lastSizeList = re.findall('\.?\d+\.?\d*', lastSize)
            saveSize = lastSizeList[0]
            if saveSize.startswith('.'):
                saveSize = '0' + saveSize

            finalSize = float(saveSize)
            all_file_size += finalSize
            all_file_count += 1
            print output
</code></pre>

<p>其他的一些减包方案就不展开了，接下来我试着分析一下 bestswifter 大神的 <code>BSBacktraceLogger </code></p>

<h3 id="获取调用堆栈">获取调用堆栈</h3>


<p>说到调用堆栈，我们很容易联想到 DSYM 文件，我们知道 Xcode build setting 有个 DEBUG INFOMATION FORMAT 的选项</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37778243-6492e91a-2e24-11e8-8fde-1ec051ffae0e.png" alt="" /></p>

<p>可以看到 Debug 模式下，符号表文件会存入可执行文件中，而 Release 模式则会生成出 DSYM 文件，我们平常使用 Bugly 等工具上传的就是这份 DSYM 文件，DSYM 也是种 Mach-O 文件。在 Debug 模式，由于符号表在内存中，这为我们符号化堆栈提供了可能性。</p>

<pre><code>bool bs_fillThreadStateIntoMachineContext(thread_t thread, _STRUCT_MCONTEXT *machineContext) {
    mach_msg_type_number_t state_count = BS_THREAD_STATE_COUNT;
    kern_return_t kr = thread_get_state(thread, BS_THREAD_STATE, (thread_state_t)&amp;machineContext-&gt;__ss, &amp;state_count);
    return (kr == KERN_SUCCESS);
}
</code></pre>

<p><code>thread_get_state </code> 函数获取线程执行状态（例如寄存器），传入 <code>_STRUCT_MCONTEXT </code> 结构体，<code>_STRUCT_MCONTEXT </code> 在不同的 cpu 架构会有所不同。</p>

<pre><code>uintptr_t bs_mach_instructionAddress(mcontext_t const machineContext){
    return machineContext-&gt;__ss.BS_INSTRUCTION_ADDRESS;
}

const uintptr_t instructionAddress = bs_mach_instructionAddress(&amp;machineContext);
</code></pre>

<p>获取当前指令的地址，也就是当前的栈帧，即当前被调用的函数。下面先讲下关于栈帧的概念。</p>

<h4>栈帧是什么</h4>

<p><img src="https://user-images.githubusercontent.com/5633917/37778363-bd21bbf6-2e24-11e8-8545-4acaf084d954.png" alt="" /></p>

<p>如上图，一个函数调用栈是由若干个栈帧组成，每个栈帧通过 FP 和 SP 划分界线，fun1 函数 SP 和 FP 的指向就是 main 函数的栈帧。所以说只要知道当前函数的栈帧就能获取上一个函数的栈帧，从而回溯出函数调用栈。</p>

<p>程序计数器（PC）作用是给出将要执行的下一条指令在内存中的地址，上面代码的 <code>BS_INSTRUCTION_ADDRESS</code>。其中 16 位为 %ip，32 位为 %eip，64 位为 %rip，arm 是 pc。</p>

<p>SP 是栈指针寄存器，指向栈顶。</p>

<p>FP 是栈基址寄存器，指向栈起始位置。</p>

<p>LR 寄存器在子程序调用时会存储 PC 的值，即返回值。</p>

<p>为了方便获取栈帧，干脆构造一个栈帧的结构体，以下代码来自 KSCrash，它的注释已经很好的讲明了结构体的原由，BSBacktraceLogger 与之类似。</p>

<pre><code>/** Represents an entry in a frame list.
 * This is modeled after the various i386/x64 frame walkers in the xnu source,
 * and seems to work fine in ARM as well. I haven't included the args pointer
 * since it's not needed in this context.
 */
typedef struct FrameEntry
{
    /** The previous frame in the list. */
    struct FrameEntry* previous;

    /** The instruction address. */
    uintptr_t return_address;
} FrameEntry;
</code></pre>

<p>之后，递归获取函数栈帧</p>

<pre><code>for(; i &lt; 50; i++) {
        backtraceBuffer[i] = frame.return_address;
        if(backtraceBuffer[i] == 0 ||
           frame.previous == 0 ||
           bs_mach_copyMem(frame.previous, &amp;frame, sizeof(frame)) != KERN_SUCCESS) {
            break;
        }
    }
</code></pre>

<h4>符号化</h4>

<p>符号化地址的大致思路分三步：1. 获取地址所在的内存镜像；2. 定位到内存镜像的符号表；3. 再从符号表中找到目标地址的符号。</p>

<h5>找到地址所在的内存镜像</h5>

<pre><code>uint32_t bs_imageIndexContainingAddress(const uintptr_t address) {
    const uint32_t imageCount = _dyld_image_count();
    const struct mach_header* header = 0;

    for(uint32_t iImg = 0; iImg &lt; imageCount; iImg++) {
        header = _dyld_get_image_header(iImg);
</code></pre>

<p> 遍历 image，得到指向 image header 的指针</p>

<pre><code>uintptr_t addressWSlide = address - (uintptr_t)_dyld_get_image_vmaddr_slide(iImg);
uintptr_t cmdPtr = bs_firstCmdAfterHeader(header);
</code></pre>

<p>对指针 +1 操作，返回指向 load command 的指针</p>

<pre><code>for(uint32_t iCmd = 0; iCmd &lt; header-&gt;ncmds; iCmd++) {
                const struct load_command* loadCmd = (struct load_command*)cmdPtr;
                if(loadCmd-&gt;cmd == LC_SEGMENT) {
                    const struct segment_command* segCmd = (struct segment_command*)cmdPtr;
                    if(addressWSlide &gt;= segCmd-&gt;vmaddr &amp;&amp;
                       addressWSlide &lt; segCmd-&gt;vmaddr + segCmd-&gt;vmsize) {
                        return iImg;
                    }
                }
</code></pre>

<p>如果某个 segment 包含这个地址，那么该地址应大于 segment 的起始地址，小于 segment 的起始地址 + segment 的大小。</p>

<h5>定位镜像的符号表</h5>

<p><code>__LINKEDIT</code> 段包含了符号表（symbol），字符串表（string），重定位表（relocation）。<code>LC_SYMTAB</code> 指明了 <code>__LINKEDIT</code> 段查找字符串和符号表的位置。我们可以结合 <code>SEG_LINKEDIT</code> 和 <code>LC_SYMTAB</code> 来找到 image 的符号表。
接下来看看段基址的获取：
虚拟地址偏移量 = 虚拟地址（vmaddr） &ndash; 文件偏移量（fileoff）
段基址 = 虚拟地址偏移量 +  ASLR的偏移量</p>

<pre><code>const uintptr_t imageVMAddrSlide = (uintptr_t)_dyld_get_image_vmaddr_slide(idx);
// ALSR
const uintptr_t addressWithSlide = address - imageVMAddrSlide;
const uintptr_t segmentBase = bs_segmentBaseOfImageIndex(idx) + imageVMAddrSlide;
</code></pre>

<p>有了段基址，获取符号表和字符串表就只是计算下 symoff 和 stroff 偏移量了：</p>

<pre><code>const BS_NLIST* symbolTable = (BS_NLIST*)(segmentBase + symtabCmd-&gt;symoff);
const uintptr_t stringTable = segmentBase + symtabCmd-&gt;stroff;
</code></pre>

<h5>找到最匹配的符号</h5>

<p>递归查找离 addressWithSlide 更近的函数入口地址，因为 addressWithSlide 肯定大于某个函数的入口。</p>

<pre><code>for(uint32_t iSym = 0; iSym &lt; symtabCmd-&gt;nsyms; iSym++) {
                // If n_value is 0, the symbol refers to an external object.
    if(symbolTable[iSym].n_value != 0) {
            uintptr_t symbolBase = symbolTable[iSym].n_value;
                 uintptr_t currentDistance = addressWithSlide - symbolBase;
                  if((addressWithSlide &gt;= symbolBase) &amp;&amp;
                       (currentDistance &lt;= bestDistance)) {
                        bestMatch = symbolTable + iSym;
                        bestDistance = currentDistance;
                    }
        }
}
</code></pre>

<h3 id="如何用 MachO 文件关联类的方法名">如何用 MachO 文件关联类的方法名</h3>


<p>MachO 文件的 <code>__Text</code> 段有 <code>__objc_classname</code> 和 <code>__objc_methname</code> 来表示类名和方法名，但是这两者之间是如何做到关联的呢？下面我以系统的计算器做例子，试着进一步研究下 MachO 文件。
使用 MachOView 打开系统计算机，先来看看 <code>__objc_classname</code> 和 <code>__objc_methname</code> 在 load commands 里的定义：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37772635-327d2624-2e16-11e8-98fb-b5cea70f5154.png" alt="" /></p>

<p><img src="https://user-images.githubusercontent.com/5633917/37772656-4669a46e-2e16-11e8-832f-6351a28979e0.png" alt="" /></p>

<p>我们顺着 <code>__objc_classname</code> 的偏移offset 109518 即 0x1ABCE 来到：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37772457-a6329546-2e15-11e8-807e-cbef3da6cbee.png" alt="" /></p>

<p>同理 <code>__objc_methname</code> 的偏移为 0x165E8：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37772866-f014900a-2e16-11e8-8ee2-04793df6d995.png" alt="" /></p>

<p>那么，怎样像 class-dump 那样将类和自个的方法名对应起来呢？
由于每个类的虚拟地址都在Data 段 <code>__objc_classlist</code> 中：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37773001-5c068688-2e17-11e8-8ca6-defa18ac7428.png" alt="" /></p>

<p>我们看到起始地址对应的是 0x1000298A8 这个地址，为了得到实际的地址需要用虚拟地址 &ndash; 段起始地址 + 文件偏移，经过一番计算，结果是0x298A8，来到文件偏移处，已经在DATA 段的 <code>__objc_data</code></p>

<p><img src="https://user-images.githubusercontent.com/5633917/37773272-210903b6-2e18-11e8-8d75-5612f5c24dbf.png" alt="" /></p>

<p>在这里会对应着类的结构体，代码拷自 class-dump</p>

<pre><code>struct cd_objc2_class {
    uint64_t isa;
    uint64_t superclass;
    uint64_t cache;
    uint64_t vtable;
    uint64_t data; // points to class_ro_t
    uint64_t reserved1;
    uint64_t reserved2;
    uint64_t reserved3;
};
</code></pre>

<p>data 是我们感兴趣的，它指向 <code>class_ro_t </code>，熟悉 runtime 的话应该知道 <code>class_ro_t </code> 存储了类在编译器就确定的属性、方法、协议等。
所以上图顺着找下去 0x100020A68 就是data 的内存地址，再用上面的公式计算得到 0x20A68，我们在 <code>__objc_const</code>找到那里：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37773857-aca7264a-2e19-11e8-848f-e40a00038f7f.png" alt="" /></p>

<p>这里就是对应着 <code>class_ro_t </code>，来看看它在 class-dump 里的定义：</p>

<pre><code>struct cd_objc2_class_ro_t {
    uint32_t flags;
    uint32_t instanceStart;
    uint32_t instanceSize;
    uint32_t reserved; // *** this field does not exist in the 32-bit version ***
    uint64_t ivarLayout;
    uint64_t name;
    uint64_t baseMethods;
    uint64_t baseProtocols;
    uint64_t ivars;
    uint64_t weakIvarLayout;
    uint64_t baseProperties;
};
</code></pre>

<p>最终 0x20A80 就是name，0x20A88 就是 baseMethods。name 对应的正好是 0x1ABCE，类名是 BitFieldBox。baseMethods 指向内存 0x100020A00，该地址对应的数据是 18 00 00 00 04 00 00 00 表示 entsize 和 count 方法数，在这8个字节之后就是 name 方法名，types 方法类型， imp 函数指针了，所以方法名处的数据为 0x1000165e8 刚好对应 initWithFrame:
将结论用 class-dump 验证可得 BitFieldBox 的第一个方法是 initWithFrame</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37774620-b04a4212-2e1b-11e8-9e45-22098920b939.png" alt="" /></p>

<h3>总结</h3>

<p>最初学习 MachO 文件格式觉得挺抽象的，后来经过各种源码的阅读和融合，终于在一次次地探索中比较直观地认识了 MachO 文件，特别是在 MachO 文件关联类的方法名时对类在内存中的布局有了更进一步的认识。虽然我们平常开发基本不和 MachO 文件打交道，但是对它有个基本概念，无论是做崩溃分析、逆向等都是有帮助的。</p>

<h4>参考链接</h4>

<p><a href="http://satanwoo.github.io/2017/06/13/Macho-1/">深入剖析Macho (1)</a></p>

<p><a href="https://blog.csdn.net/jasonblog/article/details/49909163">iOS中线程Call Stack的捕获和解析（一）</a></p>

<p><a href="https://blog.csdn.net/jasonblog/article/details/49909209">iOS中线程Call Stack的捕获和解析（二）</a></p>

<p><a href="https://bestswifter.com/callstack/">获取任意线程调用栈的那些事</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 11 怎样为导航条上的 UIBarButtonItem 设置间距]]></title>
    <link href="http://hawk0620.github.io/blog/2018/01/06/ios11-barbuttonitem/"/>
    <updated>2018-01-06T14:28:20+08:00</updated>
    <id>http://hawk0620.github.io/blog/2018/01/06/ios11-barbuttonitem</id>
    <content type="html"><![CDATA[<p>以前我们常用 <code>fixedSpace</code> 的方式为 UINavigationBar 上的 UIBarButtonItem 设置间距：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">UIBarButtonItem</span> <span class="o">*</span><span class="n">negativeSpacer</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIBarButtonItem</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithBarButtonSystemItem</span><span class="o">:</span><span class="n">UIBarButtonSystemItemFixedSpace</span>
</span><span class='line'>                                                                                <span class="n">target</span><span class="o">:</span><span class="nb">nil</span>
</span><span class='line'>                                                                                <span class="n">action</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="n">negativeSpacer</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="o">-</span><span class="mi">8</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">navigationItem</span> <span class="n">setLeftBarButtonItems</span><span class="o">:</span><span class="p">@[</span><span class="n">negativeSpacer</span><span class="p">,</span> <span class="n">button</span><span class="p">]</span> <span class="n">animated</span><span class="o">:</span><span class="nb">NO</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>




<!--more-->


<p>然而在 iOS 11 下 <code>UIBarButtonItem</code> width 属性不但失效了，<code>UIBarButtonItem</code> 也开始使用 auto layout 布局，对此我们需要设置 <code>UIBarButtonItem</code> 子 view 的约束。除此之外，苹果还修改了 <code>UINavigationBar</code> 的实现。直到 iOS 10 <code>UINavigationBar</code> 都是采用手动布局，所有的子 view 都是直接加在 <code>UINavigationBar</code> 上。但是，从 iOS 11 开始， <code>UINavigationBar</code> 使用了 auto layout 来布局它的内容子 view，并且子 view 加在了 <code>_UINavigationBarContentView</code> 上。</p>

<p>先来看看 iOS 11 下 <code>UINavigationBar</code> 的视图层级：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">UINavigationBar</span>
</span><span class='line'>      <span class="o">|</span> <span class="n">_UIBarBackground</span>
</span><span class='line'>      <span class="o">|</span>    <span class="o">|</span> <span class="n">UIImageView</span>
</span><span class='line'>      <span class="o">|</span>    <span class="o">|</span> <span class="n">UIImageView</span>
</span><span class='line'>      <span class="o">|</span> <span class="n">_UINavigationBarLargeTitleView</span>
</span><span class='line'>      <span class="o">|</span>    <span class="o">|</span> <span class="n">UILabel</span>
</span><span class='line'>      <span class="o">|</span> <span class="n">_UINavigationBarContentView</span>
</span><span class='line'>      <span class="o">|</span>    <span class="o">|</span> <span class="n">_UIButtonBarStackView</span>
</span><span class='line'>      <span class="o">|</span>    <span class="o">|</span>    <span class="o">|</span> <span class="n">_UIButtonBarButton</span>
</span><span class='line'>      <span class="o">|</span>    <span class="o">|</span>    <span class="o">|</span>    <span class="o">|</span> <span class="n">_UIModernBarButton</span>
</span><span class='line'>      <span class="o">|</span>    <span class="o">|</span>    <span class="o">|</span>    <span class="o">|</span>    <span class="o">|</span> <span class="n">UIButtonLabel</span>
</span><span class='line'>      <span class="o">|</span> <span class="n">_UINavigationBarContentView</span>
</span><span class='line'>      <span class="o">|</span>    <span class="o">|</span> <span class="n">_UIButtonBarStackView</span>
</span><span class='line'>      <span class="o">|</span>    <span class="o">|</span>    <span class="o">|</span> <span class="n">_UITAMICAdaptorView</span> <span class="c1">// customView</span>
</span><span class='line'>      <span class="o">|</span>    <span class="o">|</span>    <span class="o">|</span>    <span class="o">|</span> <span class="n">UIBarButtonItem</span>
</span><span class='line'>      <span class="o">|</span>    <span class="o">|</span>    <span class="o">|</span>    <span class="o">|</span>    <span class="o">|</span> <span class="n">UIImageView</span>
</span><span class='line'>      <span class="o">|</span>    <span class="o">|</span>    <span class="o">|</span>    <span class="o">|</span>    <span class="o">|</span> <span class="n">UIButtonLabel</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过 View Debug 工具可知，原来是 stackView 限制了 customView 的宽度以及引起了偏移：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">contentView</span> <span class="o">|&lt;-</span><span class="n">fullWidth</span><span class="o">-----------&gt;|</span>
</span><span class='line'><span class="n">stackView</span>     <span class="o">|&lt;-</span><span class="n">stackViewWidth</span><span class="o">-&gt;|</span>
</span><span class='line'><span class="n">customView</span>    <span class="o">|&lt;-</span><span class="n">reducedWidth</span><span class="o">---&gt;|</span>
</span></code></pre></td></tr></table></div></figure>


<p>在此次深挖之前，贝聊客户端的开发小哥们由于项目工期紧以及适配 iOS 11 工作量大，暂时是通过设置 <code>UIButton</code> 的 <code>setContentEdgeInsets:</code> 来实现的，这在当时看来是以最小的改动完成了适配，直到 iOS 11.2 这个版本的推出，我们发现当侧滑返回时，导航条的返回按钮会被切掉一点角。（这个方法还有个小缺点是点击区域太小了）</p>

<p><img src="https://user-images.githubusercontent.com/5633917/34596594-044690be-f21c-11e7-8000-e045dd1f0822.png" alt="img1" /></p>

<p>碰巧的是，我的 leader 恰好发现了钉钉也有类似的问题。</p>

<p><img src="https://user-images.githubusercontent.com/5633917/34637834-7982edb8-f2f9-11e7-84f5-9fef5306e910.JPG" alt="" /></p>

<p>iOS 11 虽然已经推出好几个月了，这个问题可能还在困扰着部分同行，接下来就讲讲贝聊是如何解决这个问题的。</p>

<p>由于大家知道 fixed space 失效是系统换成了 auto layout 来实现，所以网上的大部分文章也都是修改 constraint。遗憾的是，我谷歌到挺多使用这种方式去修改要获取到 <code>UINavigationBar</code> 的私有子 view，譬如 <code>contentView</code> 或 <code>barStackView</code>，再为私有子 view 添加 leading 和 trailing 的约束等。</p>

<p>我并没有尝试这种方法的可行性，因为始终觉得获取私有子 view 的做法比较脆弱，苹果一旦更换实现，程序的健壮性不好保障。但可以确定的是，解决这个问题的思路大致是修改约束，设法摆脱 stackView 的限制。</p>

<p>在 auto layout 中，约束是使用 alignment rectangle 来确定视图的大小和位置。先看看 alignment rectangle 的作用是怎样，下图摘自《iOS Auto Layout Demystified》：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/34598265-97cfd8e0-f226-11e7-886f-3d0d2f0d79ce.jpeg" alt="img2" /></p>

<p><img src="https://user-images.githubusercontent.com/5633917/34598273-b0486090-f226-11e7-998a-9d695a1f4bbc.jpeg" alt="img3" /></p>

<p>书中对此的说明是，假如设计师给了你张带角标的气泡图片，程序只期望对气泡进行居中，而图片的 frame 却包含了角标部分，这时可以 override <code>alignmentRectForFrame:</code>、<code>frameForAlignmentRect</code>。<code>UIView</code> 也给出了相对简便的属性 <code>alignmentRectInsets</code>，需要注意的是，一旦设置了 <code>alignmentRectInsets</code>，view 的 frame 就会根据 alignment rectangle 和 <code>alignmentRectInsets</code> 计算出来。</p>

<p>有了以上的概念后，贝聊的修复方法是子类化一个 UIBarButtonItem 的 customView：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">BLNavigationItemCustomView</span>: <span class="nc">UIView</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">)</span> <span class="n">UIEdgeInsets</span> <span class="n">alignmentRectInsetsOverride</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">BLNavigationItemCustomView</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">UIEdgeInsets</span><span class="p">)</span><span class="nf">alignmentRectInsets</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">UIEdgeInsetsEqualToEdgeInsets</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">alignmentRectInsetsOverride</span><span class="p">,</span> <span class="n">UIEdgeInsetsZero</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">super</span><span class="p">.</span><span class="n">alignmentRectInsets</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">alignmentRectInsetsOverride</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>再就是创建 customView 时针对 iOS 11 做特殊处理，以返回按钮为例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="p">(@</span><span class="n">available</span><span class="p">(</span><span class="n">iOS</span> <span class="mf">11.0</span><span class="p">,</span> <span class="o">*</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">button</span><span class="p">.</span><span class="n">alignmentRectInsetsOverride</span> <span class="o">=</span> <span class="n">UIEdgeInsetsMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">offset</span><span class="p">));</span>
</span><span class='line'>    <span class="n">button</span><span class="p">.</span><span class="n">translatesAutoresizingMaskIntoConstraints</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">button</span><span class="p">.</span><span class="n">widthAnchor</span> <span class="n">constraintEqualToConstant</span><span class="o">:</span><span class="n">buttonWidth</span><span class="p">].</span><span class="n">active</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">button</span><span class="p">.</span><span class="n">heightAnchor</span> <span class="n">constraintEqualToConstant</span><span class="o">:</span><span class="mi">44</span><span class="p">].</span><span class="n">active</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>之所以设置 widthAnchor、heightAnchor 是前文提到的需要对 <code>UIBarButtonItem</code> 子 view 设置约束，我在实现时就遇到了怎么修改 frame 都无法撑大 customView 的情况，后来发现是没设置 widthAnchor。我们接着用 View Debug 来看看实现的效果：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/34602108-8b91454c-f239-11e7-9677-9c8434ec0d8a.jpeg" alt="img4" /></p>

<p>这儿有个问题就是 customView 有小部分超出了 stackView 的 bounds，导致了超出部分无法接收点击。有趣的是，使用 iOS 11 之前 fixed space 添加间距的做法可以减少 stackView 的 margin。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">UIBarButtonItem</span> <span class="o">*</span><span class="n">spacer</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIBarButtonItem</span> <span class="n">bl_barButtonItemSpacerWithWidth</span><span class="o">:-</span><span class="p">(</span><span class="n">offset</span><span class="p">)];</span>
</span><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">navigationItem</span><span class="p">.</span><span class="n">leftBarButtonItems</span> <span class="o">=</span> <span class="p">@[</span><span class="n">spacer</span><span class="p">,</span> <span class="n">barButtonItem</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>结合上 fixed space 和 alignmentRectInsets，customView 将不再超出它的父视图：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/34602516-04f734b8-f23b-11e7-809a-5574dc5f6b3e.jpeg" alt="img5" /></p>

<p>总之，我们需继承复写 <code> alignmentRectInsets</code> 的 <code>BLNavigationItemCustomView </code>，然后继续保持之前版本 fixed space 的处理，只针对 iOS 11 为 customView 新增约束，就可使间距问题在新旧系统得以解决。</p>

<h3>总结</h3>

<p>不客气的说，iOS 11 真的是一个挺难适配的版本，期间我都差点放弃对导航条间隔的适配了，好在最后还是顺利解决了。如果你有更好的方式解决，欢迎赐教。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何实现一个 AttributedLabel]]></title>
    <link href="http://hawk0620.github.io/blog/2017/11/27/attributed-label/"/>
    <updated>2017-11-27T23:46:34+08:00</updated>
    <id>http://hawk0620.github.io/blog/2017/11/27/attributed-label</id>
    <content type="html"><![CDATA[<p>Core Text 是苹果提供的富文本排版技术，可以定制开发图文混排功能，DTCoreText、Nimbus、YYLabel 等优秀的开源库底层都是基于 Core Text 的封装和扩展。本文将介绍 Core Text 的基本用法，逐步讲解我是如何封装一个 <a href="https://github.com/hawk0620/PYQFeedDemo">AttributedLabel</a> 的。</p>

<!--more-->


<h3>文本排版简述</h3>

<p>文本排版是根据给定的文本（text）、字体（font）、绘制区域（shape）、行高（line height）等相关属性，生成出字形（glyphs）布局在屏幕绘制区的适当位置。排版的核心就是将字符（characters）转换成字形，将字形排列成行（lines），再将行排成段落（paragraphs）。用代码表达就是下边寥寥几行。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CTFramesetterRef</span> <span class="n">framesetter</span> <span class="o">=</span> <span class="n">CTFramesetterCreateWithAttributedString</span><span class="p">((</span><span class="n">CFAttributedStringRef</span><span class="p">)</span><span class="n">attributedString</span><span class="p">);</span>
</span><span class='line'><span class="n">CTFrameRef</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">CTFramesetterCreateFrame</span><span class="p">(</span><span class="n">framesetter</span><span class="p">,</span> <span class="n">CFRangeMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="n">attributedString</span> <span class="n">length</span><span class="p">]),</span> <span class="n">path</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'><span class="n">CTFrameDraw</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的主要步骤有：</p>

<ol>
<li>创建 Attributed String；</li>
<li>创建 CTFramesetter，这是 Core Text 排版的核心类，它会贯穿整个排版过程；</li>
<li>创建 CGPath，即绘制的区域；</li>
<li>通过 CTFramesetter 和 CGPath 创建 CTFrame，然后可将其绘制在当前的 context 上；</li>
<li>别忘了调用 CFRelease 释放对象。</li>
</ol>


<p>在继续深入代码之前，先了解以下几个小概念：</p>

<h4>字形与字体</h4>

<p>简单说字体就是映射到字符的字形集合，以下就是字符 a （ascii 码为 97）的不同字形：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/33275706-6f4178aa-d3ce-11e7-921c-4afd1bb6b76a.png" alt="" /></p>

<p>而同一字体下字形也可能会有所不同，在英文中比较常见的如连字，典型的就是fi中 i 的点常与 f 的钩合并：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/33275829-b2a349ac-d3ce-11e7-931a-41dcd8c2f3ec.png" alt="" /></p>

<p>接下来说说字体，在开发中我们常说同一字体不同字号，比如  <code>[UIFont systemFontOfSize: 16]</code> 和 <code>[UIFont systemFontOfSize: 18]</code>，或者同一字体但是加粗显示，又如  <code>[UIFont systemFontOfSize: 16]</code> 和 <code>[UIFont boldSystemFontOfSize: 16]</code>，又或者斜体，然而这对于系统而言是完全不同的字体。这儿想说明的是：不同字号是不同的字体，粗体相对普通也是不同的字体，而给文本添加下划线却是个例外（下划线是系统额外画的一条装饰线）。</p>

<p>有时我们在开发中也会接触到字体的 Ascent 和 Descent，其实就是在于字形度量（Glyph metrics）打交道：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/33275873-d1a33c5e-d3ce-11e7-985d-5b8e7bc8b9e1.png" alt="" /></p>

<p>由上图可知，一个字符最高点到基线的偏移叫做 Ascent，最低点到基线的偏移叫做 Descent，单行的行高 Line Height 由 Ascent、Descent 与 Line Gap 相加得出。</p>

<h4>文本的绘制</h4>

<p><img src="https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/core_text_arch_2x.png" alt="" /></p>

<p>Core Text 需要使用 CTFramesetter 对文本进行布局，位于上图中最顶端的 CTFramesetter，它要求以 Attributed String 和绘制区域的形状（CGPath）作为入参，来创建 CTFrame（可以不止一个 CTFrame） ，顾名思义，这就是文本布局所在的 frame，确定好绘制区域后，framesetter 就能将段落样式（NSParagraphStyle）的 lineBreakMode、lineSpacing 等属性应用于此。
这里有必要提一下 CTRun，从 CTRun 我们可以获取许多重要的属性，这在开发排版功能的时候非常有用，下面这张图有助于我们了解什么是 CTRun：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/33275976-20fb6826-d3cf-11e7-9add-089329fb271d.png" alt="" /></p>

<p>这一行文本可以认为是一个 CTLine 对象，由从左往右的顺序依次包含了默认字体样式、加粗字体样式、默认字体样式、小字号蓝色样式、正常字号蓝色样式和默认字体样式共 6 种 Attributed。每一种样式的字符则表示一个 CTRun 对象。</p>

<p>了解了这些概念之后，就可以实现排版功能了。</p>

<h3>实现一个简单的 AttributedLabel</h3>

<p>进入正题之前，再储备些基础知识。</p>

<h5>Core Foundation 内存管理规则</h5>

<p>Core Text 使用了 Core Foundation 基于 C 语言的 API，所以需要遵循 Core Foundation 的内存管理规则。</p>

<ul>
<li>创建方法名中含有 “Create” 或 “Copy”，需要调用 CFRelease 释放内存</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CTFramesetterRef</span> <span class="n">CTFramesetterCreateWithAttributedString</span><span class="p">(</span>
</span><span class='line'><span class="n">CFAttributedStringRef</span> <span class="n">string</span> <span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>返回 CF 对象方法名中不含 “Create” 和 “Copy”，无需手动释放内存</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CFStringRef</span> <span class="n">CFAttributedStringGetString</span><span class="p">(</span><span class="n">CFAttributedStringRef</span> <span class="n">aStr</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>明白了这点，就对项目中什么时候该调用 CFRelease，什么时候不该调用做到心中有数了。</p>

<p>关于 <code>__bridge</code> 关键字</p>

<ul>
<li><code>__bridge</code> 只是声明类型转变，但不做内存管理规则的转变。</li>
<li><code>__bridge_retained</code> 表示指针类型转变的同时，将内存管理由原来的 Objective-C 交给 Core Foundation 处理，即 ARC to MRC。</li>
<li><code>__bridge_transfer</code> 表示内存管理由 Core Foundation 交给 Objective-C，即 MRC to ARC。</li>
</ul>


<h5>关于坐标系</h5>

<p>另外，Core Text 最初是设计给 mac 的，它的坐标系是 mac 坐标系（原点在左下角），所以通常需要对坐标进行翻转，这也是下文提及为什么需要翻转的缘由。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CGContextSetTextMatrix</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">CGAffineTransformIdentity</span><span class="p">);</span>
</span><span class='line'><span class="n">CGContextTranslateCTM</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>
</span><span class='line'><span class="n">CGContextScaleCTM</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h5>借助下面这张类关系图让我们直奔主题。</h5>

<p><img src="https://user-images.githubusercontent.com/5633917/33276265-09758578-d3d0-11e7-9690-db644433aeec.png" alt="" /></p>

<h4>1.堪当重任的 CALayer</h4>

<p>相对于 UIView，CALayer 通常是比较“轻”的，我们在日常开发中接触 layer 比较多的还是设置 cornerRadius、contents、mask 或者做个动画等，而在这个项目中，依靠 layer 的 <code>- (void)display</code> 方法，让其充当了一个 “桥梁” 的作用。</p>

<p>先来了解下 <code>- (void)display</code> 方法，如文档里所说，layer 会在适当的时候调用该方法来更新 layer 的 contents，但是并不建议直接调用该方法，子类化可以重写该方法，并能直接设置 layer 的 contents。文档的最后一句话大大盘活了自定义的 AttributedLabel，当 AttributedLabel 需要改变 text、frame、font、attributedString…时，AttributedLabel 不用关心具体的绘制，只需告知下 layer 需要 display 即可。由于将 AttributedLabel 的 <code>+ (Class)layerClass</code> 返回了子类化的 layer。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">+</span> <span class="p">(</span><span class="kt">Class</span><span class="p">)</span><span class="nf">layerClass</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">ZPLabelLayer</span> <span class="n">class</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>layer 的 delegate 对象就是 AttributedLabel，所以 layer 就能通过它的 delegate 属性获取到 AttributedLabel 的上述属性，进一步调用 Core Text 绘制出新的 contents 进行设置。这是做这个项目时最干净利落的一个地方。</p>

<h4>2.文本高亮交互的处理</h4>

<p>如果无需处理高亮交互等定制（截断、附件）效果，我们在拿到 NSAttributedString 和 CGPath 即可将文本绘制到 context 上。对于链接而言，虽然我们能通过 NSDataDetector 标记出文本中哪些地方需要高亮显示，但是需求往往要能对链接进行点击跳转，在使用 CTFrameDraw 方法绘制文本时，既不知道高亮过的文本位置，更无法谈及对高亮文本的交互响应了。</p>

<p>幸运的是，Core Text 另外还有个稍微复杂点的绘制方法 CTLineDraw，从名字可以得知它是用来绘制 line 的，感观上要比 CTFrameDraw 的确要精细许多。我们先看看添加高亮功能的实现思路。</p>

<ul>
<li>能响应点击的回调 block</li>
<li>接受高亮颜色、range、backgroundColor 等</li>
</ul>


<p>假设上述高亮相关属性都由 AttributedLabel 处理，使用者每次添加高亮不仅要让 AttributedLabel 改变内部文本的 Attributed 属性，考虑到一段文本可能有多处高亮，其本身也还需要维护一个处理高亮的数组。然而对设置高亮来说，这本就是 NSAttributedString 能做到的事，若让 UI 层来处理这些逻辑并不是很好。再者，对于调用者来说，虽然可以将上述属性封装成 model 方便 AttributedLabel 使用，但如果想复用 NSAttributedString 就变得不可能了。看来交由 NSAttributedString 来处理高亮相关属性是最合适不过的了，这里通过创建 NSAttributedString 的 category 和  AssociatedObject 满足了需求。</p>

<p>最终从 NSAttributedString 中获取到高亮的 ranges，再配合 CTLineDraw 绘制行的时候获取到 run （文章前面介绍）的 range，先来看看代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">ranges</span> <span class="o">=</span> <span class="n">attributedStr</span><span class="p">.</span><span class="n">highlightRangeArray</span><span class="p">;</span>  <span class="c1">// 获取 ranges</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="c1">// 遍历行</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">CFIndex</span> <span class="n">lineIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">lineIndex</span> <span class="o">&lt;</span> <span class="n">numberOfLines</span><span class="p">;</span> <span class="n">lineIndex</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">CTLineRef</span> <span class="n">line</span> <span class="o">=</span> <span class="n">CFArrayGetValueAtIndex</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">lineIndex</span><span class="p">);</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>    <span class="n">CFArrayRef</span> <span class="n">runs</span> <span class="o">=</span> <span class="n">CTLineGetGlyphRuns</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
</span><span class='line'>    <span class="c1">// 遍历行的每一个 run</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">CFArrayGetCount</span><span class="p">(</span><span class="n">runs</span><span class="p">);</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">...</span>
</span><span class='line'>        <span class="n">CFRange</span> <span class="n">range</span> <span class="o">=</span> <span class="n">CTRunGetStringRange</span><span class="p">(</span><span class="n">run</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>             <span class="k">for</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">rangeString</span> <span class="k">in</span> <span class="n">self</span><span class="p">.</span><span class="n">ranges</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">NSRange</span> <span class="n">hightlightRange</span> <span class="o">=</span> <span class="n">NSRangeFromString</span><span class="p">(</span><span class="n">rangeString</span><span class="p">);</span>
</span><span class='line'>                    <span class="n">NSRange</span> <span class="n">lineRange</span> <span class="o">=</span> <span class="n">NSMakeRange</span><span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">location</span><span class="p">,</span> <span class="n">range</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
</span><span class='line'>            <span class="c1">// 得到属于高亮的 range</span>
</span><span class='line'>                    <span class="k">if</span> <span class="p">(</span><span class="n">NSIntersectionRange</span><span class="p">(</span><span class="n">hightlightRange</span><span class="p">,</span> <span class="n">lineRange</span><span class="p">).</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></code></pre></td></tr></table></div></figure>


<p>接下来获取具体的 CGRect，注意在获取 CGRect 时还需将坐标翻转：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CGAffineTransform</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">CGAffineTransformMakeTranslation</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">contentHeight</span><span class="p">);</span>
</span><span class='line'><span class="n">transform</span> <span class="o">=</span> <span class="n">CGAffineTransformScale</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="mf">1.f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.f</span><span class="p">);</span>
</span><span class='line'><span class="n">CGRect</span> <span class="n">flipRect</span> <span class="o">=</span> <span class="n">CGRectApplyAffineTransform</span><span class="p">(</span><span class="n">runRect</span><span class="p">,</span> <span class="n">transform</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 保存链接的CGRect</span>
</span><span class='line'><span class="n">NSRange</span> <span class="n">nRange</span> <span class="o">=</span> <span class="n">NSMakeRange</span><span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">location</span><span class="p">,</span> <span class="n">range</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
</span><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">framesDict</span><span class="p">[</span><span class="n">NSStringFromRange</span><span class="p">(</span><span class="n">nRange</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSValue</span> <span class="n">valueWithCGRect</span><span class="o">:</span><span class="n">flipRect</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>到这已经基本获取到高亮文本的位置，为什么说是基本呢？因为漏了个链接换行的问题，当链接换行显示时，就会产生多个 CTRun 对象，这些 CTRun 对应的 CGRect 都会存在 framesDict 中，当用户点击换行的链接某部分（range）时，它只能响应到 framesDict 中的一个 CGRect，而正确的做法是应该响应某个链接在 framesDict 中的所有 CGRect，只有这样才能完整的高亮出一条链接的所有部分，本质就是要将来自同一条链接的若干 CGRect 关联起来。</p>

<p>说了这么多，实现起来却不困难，这里采用了链接的 range 做为 key，CGRect 的数组做为 value，然后判断用户的 range 在不在链接的 range 中，若属于某条链接的 range，通过链接的 range 取出 CGRect 的数组渲染即可。</p>

<h4>3.字符串截断的处理</h4>

<p>当 UILabel 显示不全字符串的时候，系统会在文本的最后添加“…”。同样，AttributedLabel 也提供了添加“…”的默认处理，并在此基础上提供了让用户自定义截断内容的功能。这里的实现并不难，直接截取最后一行的文本，再不断倒序删除最后一行的字符直到最后一行能容纳得下 TruncationText 为止。</p>

<p>首先我们还是要调用 CoreText 的 API 获取到最后一行的 range：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CTFrameRef</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">CTFramesetterCreateFrame</span><span class="p">(</span><span class="n">framesetter</span><span class="p">,</span> <span class="n">CFRangeMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="n">self</span> <span class="n">length</span><span class="p">]),</span> <span class="n">path</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">CFArrayRef</span> <span class="n">lines</span> <span class="o">=</span> <span class="n">CTFrameGetLines</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>
</span><span class='line'><span class="n">NSInteger</span> <span class="n">numberOfLines</span> <span class="o">=</span> <span class="n">CFArrayGetCount</span><span class="p">(</span><span class="n">lines</span><span class="p">);</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="n">NSInteger</span> <span class="n">lastLineIndex</span> <span class="o">=</span> <span class="n">numberOfLines</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">numberOfLines</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="n">CTLineRef</span> <span class="n">line</span> <span class="o">=</span> <span class="n">CFArrayGetValueAtIndex</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">lastLineIndex</span><span class="p">);</span>
</span><span class='line'><span class="n">CFRange</span> <span class="n">lastLineRange</span> <span class="o">=</span> <span class="n">CTLineGetStringRange</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>接着使用最后一行的 range 从 AttributedString 中获取到子文本：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//截到最后一行</span>
</span><span class='line'><span class="n">NSUInteger</span> <span class="n">truncationAttributePosition</span> <span class="o">=</span> <span class="n">lastLineRange</span><span class="p">.</span><span class="n">location</span> <span class="o">+</span> <span class="n">lastLineRange</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
</span><span class='line'><span class="n">NSMutableAttributedString</span> <span class="o">*</span><span class="n">cutAttributedString</span> <span class="o">=</span> <span class="p">[[</span><span class="n">self</span> <span class="n">attributedSubstringFromRange</span><span class="o">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">truncationAttributePosition</span><span class="p">)]</span> <span class="n">mutableCopy</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="n">NSMutableAttributedString</span> <span class="o">*</span><span class="n">lastLineAttributeString</span> <span class="o">=</span> <span class="p">[[</span><span class="n">cutAttributedString</span> <span class="n">attributedSubstringFromRange</span><span class="o">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="n">lastLineRange</span><span class="p">.</span><span class="n">location</span><span class="p">,</span> <span class="n">lastLineRange</span><span class="p">.</span><span class="n">length</span><span class="p">)]</span> <span class="n">mutableCopy</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>递归调用每次删除子文本最后一个字符的方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSMutableAttributedString</span> <span class="o">*</span><span class="p">)</span><span class="nf">handleLastLineAttributeString:</span><span class="p">(</span><span class="n">NSMutableAttributedString</span> <span class="o">*</span><span class="p">)</span><span class="nv">attributeString</span> <span class="nf">withTruncationText:</span><span class="p">(</span><span class="n">NSMutableAttributedString</span> <span class="o">*</span><span class="p">)</span><span class="nv">truncationText</span> <span class="nf">width:</span><span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nv">width</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CTLineRef</span> <span class="n">truncationToken</span> <span class="o">=</span> <span class="n">CTLineCreateWithAttributedString</span><span class="p">((</span><span class="n">CFAttributedStringRef</span><span class="p">)</span><span class="n">attributeString</span><span class="p">);</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">lastLineWidth</span> <span class="o">=</span> <span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span><span class="n">CTLineGetTypographicBounds</span><span class="p">(</span><span class="n">truncationToken</span><span class="p">,</span> <span class="nb">nil</span><span class="p">,</span> <span class="nb">nil</span><span class="p">,</span><span class="nb">nil</span><span class="p">);</span>
</span><span class='line'>    <span class="n">CFRelease</span><span class="p">(</span><span class="n">truncationToken</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">lastLineWidth</span> <span class="o">&gt;</span> <span class="n">width</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSString</span> <span class="o">*</span><span class="n">lastLineString</span> <span class="o">=</span> <span class="n">attributeString</span><span class="p">.</span><span class="n">string</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">NSRange</span> <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="n">lastLineString</span> <span class="n">rangeOfComposedCharacterSequencesForRange</span><span class="o">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="n">lastLineString</span><span class="p">.</span><span class="n">length</span> <span class="o">-</span> <span class="n">truncationText</span><span class="p">.</span><span class="n">string</span><span class="p">.</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)];</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">[</span><span class="n">attributeString</span> <span class="n">deleteCharactersInRange</span><span class="o">:</span><span class="n">r</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>       <span class="k">return</span> <span class="p">[</span><span class="n">self</span> <span class="n">handleLastLineAttributeString</span><span class="o">:</span><span class="n">attributeString</span> <span class="n">withTruncationText</span><span class="o">:</span><span class="n">truncationText</span> <span class="n">width</span><span class="o">:</span><span class="n">width</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">attributeString</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>之所以递归删除是因为试过一下子截取 truncationText 的长度时会有用 <code>CTLineGetTypographicBounds</code> 计算宽度不准确的问题，不清楚这是否与不同字符的高矮胖瘦有关，如果你有更好的方法，欢迎 pr !!!</p>

<h4>4.为字符串添加附件</h4>

<p>我最初是想用“…查看更多”截断文本，再剔除“…”后，仅把“查看更多”当作可支持高亮点击的文本，然而在实现过程中大大破坏了下边两个方法的通用性，甚至实现的效果还差强人意。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">zp_highlightColor:</span><span class="p">(</span><span class="n">UIColor</span> <span class="o">*</span><span class="p">)</span><span class="nv">highlightColor</span> <span class="nf">backgroundColor:</span><span class="p">(</span><span class="n">UIColor</span> <span class="o">*</span><span class="p">)</span><span class="nv">backgroundColor</span> <span class="nf">highlightRange:</span><span class="p">(</span><span class="n">NSRange</span><span class="p">)</span><span class="nv">highlightRange</span> <span class="nf">tapAction:</span><span class="p">(</span><span class="n">ZPTapHightlightBlock</span><span class="p">)</span><span class="nv">tapAction</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSMutableAttributedString</span> <span class="o">*</span><span class="p">)</span><span class="nf">zp_joinWithTruncationText:</span><span class="p">(</span><span class="n">NSMutableAttributedString</span> <span class="o">*</span><span class="p">)</span><span class="nv">truncationText</span> <span class="nf">textRect:</span><span class="p">(</span><span class="n">CGRect</span><span class="p">)</span><span class="nv">textRect</span> <span class="nf">maximumNumberOfRows:</span><span class="p">(</span><span class="n">NSInteger</span><span class="p">)</span><span class="nv">maximumNumberOfRows</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>通常实现某个功能感到别扭时，往往都是方法没用对。最终通过查询文档及资料发现 Core Text 竟还有个 CTRunDelegate 的对象，CTRunDelegate 是 CTRun 的 delegate，它可被用来修改布局时的字形信息（glyph metrics）， 比如控制字符的 ascent、descent、width 等。换句话说，我们可以“撑开”一个字符到我们想要的高宽，在这个占位字符之上就可以添加自定义的视图（比如 UIButton）。unicode 中恰好有空白字符 <code>\uFFFC</code> 的表示，我们在字符串适当的位置插入空白字符来占位，再获取到空白字符的 CGRect 信息，就可以添加子视图在这之上了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">zp_deallocCallback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ref</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">ZPTextRunDelegate</span> <span class="o">*</span><span class="n">delegate</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge_transfer</span> <span class="n">ZPTextRunDelegate</span> <span class="o">*</span><span class="p">)(</span><span class="n">ref</span><span class="p">);</span>
</span><span class='line'>    <span class="n">delegate</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="n">CGFloat</span> <span class="nf">zp_ascentCallback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ref</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">ZPTextRunDelegate</span> <span class="o">*</span><span class="n">delegate</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge</span> <span class="n">ZPTextRunDelegate</span> <span class="o">*</span><span class="p">)(</span><span class="n">ref</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">delegate</span><span class="p">.</span><span class="n">ascent</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="n">CGFloat</span> <span class="nf">zp_descentCallback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ref</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">ZPTextRunDelegate</span> <span class="o">*</span><span class="n">delegate</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge</span> <span class="n">ZPTextRunDelegate</span> <span class="o">*</span><span class="p">)(</span><span class="n">ref</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">delegate</span><span class="p">.</span><span class="n">descent</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="n">CGFloat</span> <span class="nf">zp_widthCallback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ref</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">ZPTextRunDelegate</span> <span class="o">*</span><span class="n">delegate</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge</span> <span class="n">ZPTextRunDelegate</span> <span class="o">*</span><span class="p">)(</span><span class="n">ref</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">delegate</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="n">CTRunDelegateCallbacks</span> <span class="n">callbacks</span><span class="p">;</span>
</span><span class='line'><span class="n">callbacks</span><span class="p">.</span><span class="n">version</span> <span class="o">=</span> <span class="n">kCTRunDelegateCurrentVersion</span><span class="p">;</span>
</span><span class='line'><span class="n">callbacks</span><span class="p">.</span><span class="n">dealloc</span> <span class="o">=</span> <span class="n">zp_deallocCallback</span><span class="p">;</span>
</span><span class='line'><span class="n">callbacks</span><span class="p">.</span><span class="n">getAscent</span> <span class="o">=</span> <span class="n">zp_ascentCallback</span><span class="p">;</span>
</span><span class='line'><span class="n">callbacks</span><span class="p">.</span><span class="n">getDescent</span> <span class="o">=</span> <span class="n">zp_descentCallback</span><span class="p">;</span>
</span><span class='line'><span class="n">callbacks</span><span class="p">.</span><span class="n">getWidth</span> <span class="o">=</span> <span class="n">zp_widthCallback</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后要注意的是 CTRunDelegate 需要实现代理的委托，在委托方法中，对象并不遵循 ARC 内存管理，这里封装了 ZPTextRunDelegate 来管理属性，使用 <code> __bridge_transfer</code>  进行内存的转换，避免了内存泄露和过早释放的 bug。获取附件的位置和高亮那块的处理类似，就不再赘述。</p>

<h3>总结</h3>

<p>本文记录了如何造一个 AttributedLabel 的轮子，相信读者结合代码一起看会发现实现简单的 Core Text 排版功能并不难，而笔者在剥离业务代码、实现通用性、封装工具类上还是遇到不少技术挑战。建议大家在平常开发中能多造点轮子锻炼锻炼技术，也能提高 iOS 技术社区的活力。同时希望大家在用惯了业界标准的 YYText 时，顺带了解下 Core Text 的使用流程。</p>

<p>Github 地址：<a href="https://github.com/hawk0620/PYQFeedDemo">https://github.com/hawk0620/PYQFeedDemo</a></p>
]]></content>
  </entry>
  
</feed>
