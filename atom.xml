<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[陈浩的技术博客]]></title>
  <link href="http://hawk0620.github.io/atom.xml" rel="self"/>
  <link href="http://hawk0620.github.io/"/>
  <updated>2017-02-17T22:35:25+08:00</updated>
  <id>http://hawk0620.github.io/</id>
  <author>
    <name><![CDATA[Hawk0620]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[开源一个上架 App Store 的相机 App]]></title>
    <link href="http://hawk0620.github.io/blog/2017/02/17/zpcamera-opensource-share/"/>
    <updated>2017-02-17T22:25:00+08:00</updated>
    <id>http://hawk0620.github.io/blog/2017/02/17/zpcamera-opensource-share</id>
    <content type="html"><![CDATA[<p>Osho 相机是我独立开发上架的一个相机 App，它支持1:1，4:3，16:9多种分辨率拍摄，滤镜可在取景框的实时预览，拍摄过程可与滤镜实时合成，支持分段拍摄，支持回删等特性。下面先分享分享开发这个 App 的一些心得体会，文末会给出项目的下载地址，阅读本文可能需要一点点 AVFoundation 开发的基础。</p>

<p><img src="https://cloud.githubusercontent.com/assets/5633917/23069130/3921d0ea-f561-11e6-92c2-ffc308d26460.jpeg" alt="" /></p>

<h2>1、GLKView和GPUImageVideoCamera</h2>

<p>一开始取景框的预览我是基于 GLKView 做的，GLKView 是苹果对 <code>OpenGL</code> 的封装，我们可以使用它的回调函数 <code>-glkView:drawInRect:</code> 进行对处理后的 <code>samplebuffer</code> 渲染的工作（<code>samplebuffer</code> 是在相机回调 <code>didOutputSampleBuffer</code> 产生的），附上当初简版代码：</p>

<pre><code>- (CIImage *)renderImageInRect:(CGRect)rect {
    CMSampleBufferRef sampleBuffer = _sampleBufferHolder.sampleBuffer;

    if (sampleBuffer != nil) {
        UIImage *originImage = [self imageFromSamplePlanerPixelBuffer:sampleBuffer];
        if (originImage) {
           if (self.filterName &amp;&amp; self.filterName.length &gt; 0) {

               GPUImageOutput&lt;GPUImageInput&gt; *filter;
                if ([self.filterType isEqual: @"1"]) {
                    Class class = NSClassFromString(self.filterName);
                    filter = [[class alloc] init];
                } else {
                    NSBundle *bundle = [NSBundle bundleForClass:self.class];
                    NSURL *filterAmaro = [NSURL fileURLWithPath:[bundle pathForResource:self.filterName ofType:@"acv"]];
                    filter = [[GPUImageToneCurveFilter alloc] initWithACVURL:filterAmaro];
                }
                [filter forceProcessingAtSize:originImage.size];
                GPUImagePicture *pic = [[GPUImagePicture alloc] initWithImage:originImage];
                [pic addTarget:filter];
                [filter useNextFrameForImageCapture];
                [filter addTarget:self.gpuImageView];
                [pic processImage];              
                UIImage *filterImage = [filter imageFromCurrentFramebuffer];
                //UIImage *filterImage = [filter imageByFilteringImage:originImage];

                _CIImage = [[CIImage alloc] initWithCGImage:filterImage.CGImage options:nil];
            } else {
            _CIImage = [CIImage imageWithCVPixelBuffer:CMSampleBufferGetImageBuffer(sampleBuffer)];
        }
    }  
    CIImage *image = _CIImage;

    if (image != nil) {
        image = [image imageByApplyingTransform:self.preferredCIImageTransform];

        if (self.scaleAndResizeCIImageAutomatically) {
           image = [self scaleAndResizeCIImage:image forRect:rect];
        }
    }

    return image;
}

- (void)glkView:(GLKView *)view drawInRect:(CGRect)rect {
    @autoreleasepool {
        rect = CGRectMultiply(rect, self.contentScaleFactor);
        glClearColor(0, 0, 0, 0);
        glClear(GL_COLOR_BUFFER_BIT);

        CIImage *image = [self renderImageInRect:rect];

        if (image != nil) {
            [_context.CIContext drawImage:image inRect:rect fromRect:image.extent];
        }
    }
}
</code></pre>

<p>这样的实现在低端机器上取景框会有明显的卡顿，而且 ViewController 上的列表几乎无法滑动，虽然手势倒是还可以支持。
因为要实现分段拍摄与回删等功能，采用这种方式的初衷是期望更高度的自定义，而不去使用 <code>GPUImageVideoCamera</code>， 毕竟我得在 <code>AVCaptureVideoDataOutputSampleBufferDelegate</code>， <code>AVCaptureAudioDataOutputSampleBufferDelegate</code> 这两个回调做文章，为了满足需求，所以得在不侵入 <code>GPUImage</code> 源代码的前提下点功夫。</p>

<p>怎么样才能在不破坏 <code>GPUImageVideoCamera</code> 的代码呢？我想到两个方法，第一个是创建一个类，然后把 <code>GPUImageVideoCamera</code> 里的代码拷贝过来，这么做简单粗暴，缺点是若以后 <code>GPUImage</code> 升级了，代码维护起来是个小灾难；再来说说第二个方法——继承，继承是个挺优雅的行为，可它的麻烦在于获取不到私有变量，好在有强大的 runtime，解决了这个棘手的问题。下面是用 runtime 获取私有变量：</p>

<pre><code>- (AVCaptureAudioDataOutput *)gpuAudioOutput {
    Ivar var = class_getInstanceVariable([super class], "audioOutput");
    id nameVar = object_getIvar(self, var);
    return nameVar;
}
</code></pre>

<p>至此取景框实现了滤镜的渲染并保证了列表的滑动帧率。</p>

<h2>2、实时合成以及 GPUImage 的 outputImageOrientation</h2>

<p>顾名思义，<code>outputImageOrientation</code> 属性和图像方向有关的。<code>GPUImage</code> 的这个属性是对不同设备的在取景框的图像方向做过优化的，但这个优化会与 videoOrientation 产生冲突，它会导致切换摄像头导致图像方向不对，也会造成拍摄完之后的视频方向不对。
最后的解决办法是确保摄像头输出的图像方向正确，所以将其设置为 <code>UIInterfaceOrientationPortrait</code>，而不对 <code>videoOrientation</code> 进行设置，剩下的问题就是怎样处理拍摄完成之后视频的方向。</p>

<p>先来看看视频的实时合成，因为这里包含了对用户合成的 <code>CVPixelBufferRef</code> 资源处理。还是使用继承的方式继承 <code>GPUImageView</code>，其中使用了 runtime 调用私有方法：</p>

<pre><code>SEL s = NSSelectorFromString(@"textureCoordinatesForRotation:");
IMP imp = [[GPUImageView class] methodForSelector:s];
GLfloat *(*func)(id, SEL, GPUImageRotationMode) = (void *)imp;
GLfloat *result = [GPUImageView class] ? func([GPUImageView class], s, inputRotation) : nil;

......

glVertexAttribPointer(self.gpuDisplayTextureCoordinateAttribute, 2, GL_FLOAT, 0, 0, result);
</code></pre>

<p>直奔重点——<code>CVPixelBufferRef</code> 的处理，将 renderTarget 转换为 CGImageRef 对象，再使用 UIGraphics 获得经 <code>CGAffineTransform</code> 处理过方向的 UIImage，此时 UIImage 的方向并不是正常的方向，而是旋转过90度的图片，这么做的目的是为 videoInput 的 transform 属性埋下伏笔。下面是 CVPixelBufferRef 的处理代码：</p>

<pre><code>int width = self.gpuInputFramebufferForDisplay.size.width;
int height = self.gpuInputFramebufferForDisplay.size.height;

renderTarget = self.gpuInputFramebufferForDisplay.gpuBufferRef;

NSUInteger paddedWidthOfImage = CVPixelBufferGetBytesPerRow(renderTarget) / 4.0;
NSUInteger paddedBytesForImage = paddedWidthOfImage * (int)height * 4;

glFinish();
CVPixelBufferLockBaseAddress(renderTarget, 0);
GLubyte *data = (GLubyte *)CVPixelBufferGetBaseAddress(renderTarget);
CGDataProviderRef ref = CGDataProviderCreateWithData(NULL, data, paddedBytesForImage, NULL);
CGColorSpaceRef colorspace = CGColorSpaceCreateDeviceRGB();
CGImageRef iref = CGImageCreate((int)width, (int)height, 8, 32, CVPixelBufferGetBytesPerRow(renderTarget), colorspace, kCGBitmapByteOrder32Little | kCGImageAlphaPremultipliedFirst, ref, NULL, NO, kCGRenderingIntentDefault);

UIGraphicsBeginImageContext(CGSizeMake(height, width));
CGContextRef cgcontext = UIGraphicsGetCurrentContext();
CGAffineTransform transform = CGAffineTransformIdentity;
transform = CGAffineTransformMakeTranslation(height / 2.0, width / 2.0);
transform = CGAffineTransformRotate(transform, M_PI_2);
transform = CGAffineTransformScale(transform, 1.0, -1.0);
CGContextConcatCTM(cgcontext, transform);

CGContextSetBlendMode(cgcontext, kCGBlendModeCopy);
CGContextDrawImage(cgcontext, CGRectMake(0.0, 0.0, width, height), iref);
UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();
self.img = image;

CFRelease(ref);
CFRelease(colorspace);
CGImageRelease(iref);
CVPixelBufferUnlockBaseAddress(renderTarget, 0);
</code></pre>

<p>而 videoInput 的 transform 属性设置如下：</p>

<pre><code>_videoInput.transform = CGAffineTransformRotate(_videoConfiguration.affineTransform, -M_PI_2);
</code></pre>

<p>经过这两次方向的处理，合成的小视频终于方向正常了。此处为简版的合成视频代码：</p>

<pre><code>CIImage *image = [[CIImage alloc] initWithCGImage:img.CGImage options:nil];
CVPixelBufferLockBaseAddress(pixelBuffer, 0);
[self.context.CIContext render:image toCVPixelBuffer:pixelBuffer];
...
[_videoPixelBufferAdaptor appendPixelBuffer:pixelBuffer withPresentationTime:bufferTimestamp]
</code></pre>

<p>可以看到关键点还是在于上面继承自 <code>GPUImageView</code> 这个类获取到的 renderTarget 属性，它应该即是取景框实时预览的结果，我在最初的合成中是使用 sampleBuffer 转 UIImage，再通过 GPUImage 添加滤镜，最后将 UIImage 再转 CIImage，这么做导致拍摄时会卡。当时我几乎想放弃了，甚至想采用拍好后再加滤镜的方式绕过去，最后这些不纯粹的方法都被我 ban 掉了。</p>

<p>既然滤镜可以在取景框实时渲染，我想到了 <code>GPUImageView</code> 可能有料。在阅读过 GPUImage 的诸多源码后，终于在 <code>GPUImageFramebuffer.m</code> 找到了一个叫 renderTarget 的属性。至此，合成的功能也告一段落。</p>

<h2>3、关于滤镜</h2>

<p>这里主要分享个有意思的过程。App 里有三种类型的滤镜。基于 glsl 的、直接使用 acv 的以及直接使用 lookuptable 的。lookuptable 其实也是 photoshop 可导出的一种图片，但一般的软件都会对其加密，下面简单提下我是如何反编译“借用”某软件的部分滤镜吧。使用 Hopper Disassembler 软件进行反编译，然后通过某些关键字的搜索，幸运地找到了下图的一个方法名。</p>

<p><img src="https://cloud.githubusercontent.com/assets/5633917/23052077/714be454-f509-11e6-9679-24e37fbe0aaa.jpeg" alt="" /></p>

<p>reverse 只能说这么多了&hellip;.在开源代码里我已将这一类敏感的滤镜剔除了。</p>

<h2>小结</h2>

<p>开发相机 App 是个挺有意思的过程，在其中邂逅不少优秀开源代码，向开源代码学习，才能避免自己总是写出一成不变的代码。最后附上项目的开源地址 <a href="https://github.com/hawk0620/ZPCamera">https://github.com/hawk0620/ZPCamera</a>，希望能够帮到有需要的朋友，也欢迎 star 和 pull request。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[EasyDataKit 简单易用的 SQLite 轮子]]></title>
    <link href="http://hawk0620.github.io/blog/2016/11/10/easydatakit-introduction/"/>
    <updated>2016-11-10T22:30:38+08:00</updated>
    <id>http://hawk0620.github.io/blog/2016/11/10/easydatakit-introduction</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/hawk0620/EasyDataKit">EasyDataKit</a> 是一个基于 FMDB 封装的库，它可以免去开发者编写复杂 SQL 的困扰，更加专注业务上的事情，从而提高开发效率。</p>

<h2>特征</h2>

<ul>
<li><p>类 ORM 接口</p></li>
<li><p>自动创建库和表，支持表新增字段的修改</p></li>
<li><p>支持 where 查询语句</p></li>
<li><p>自动事务提升插入效率</p></li>
</ul>


<!--more-->


<h2>使用</h2>

<p>EasyDataKit 适用于将网络请求的数据持久化到数据库中，特别是处理网络请求数据时不习惯把数据转换成 model。笔者的浅见是：转换对性能是有消耗的，获得的可读性好处也可以通过字符串常量解决。（<a href="http://casatwy.com/OOP_nomodel.html">这儿有篇探讨</a>）</p>

<p>假设你通过网络请求获取到了数据：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>    "data": {
</span><span class='line'>        "id": "56d177a27cb3331100465f72",
</span><span class='line'>        "messagePrefix": "饭否每日精选",
</span><span class='line'>        "content": "饭否每日精选",
</span><span class='line'>        "topicId": 1345,
</span><span class='line'>        "briefIntro": "饭否是国内著名的小众轻博客社区，氛围独特，清新自由。关注饭否每日精选，看看尘嚣之外，大家谈论什么。",
</span><span class='line'>        "keywords": "饭否 精选 短博客 社区",
</span><span class='line'>        "timeForRank": "2016-02-27T11:06:30.731Z",
</span><span class='line'>        "lastMessagePostTime": "2016-11-06T02:42:52.111Z",
</span><span class='line'>        "topicPublishDate": "2016-02-26T16:00:00.000Z",
</span><span class='line'>        "createdAt": "2016-02-27T10:17:06.295Z",
</span><span class='line'>        "updatedAt": "2016-11-01T04:30:08.973Z",
</span><span class='line'>        "subscribersCount": 1207100,
</span><span class='line'>        "subscribedStatusRawValue": 1,
</span><span class='line'>        "subscribedAt": "2016-10-18T09:57:24.424Z",
</span><span class='line'>        "rectanglePicture": {
</span><span class='line'>            "thumbnailUrl": "https://cdn.ruguoapp.com/o_1ach3c6o011j91ljjtmdhlhnffo.jpg?imageView2/1/w/120/h/180",
</span><span class='line'>            "middlePicUrl": "https://cdn.ruguoapp.com/o_1ach3c6o011j91ljjtmdhlhnffo.jpg?imageView2/1/w/200/h/300",
</span><span class='line'>            "picUrl": "https://cdn.ruguoapp.com/o_1ach3c6o011j91ljjtmdhlhnffo.jpg?imageView2/0/h/1000",
</span><span class='line'>            "format": "png"
</span><span class='line'>        },
</span><span class='line'>        "squarePicture": {
</span><span class='line'>            "thumbnailUrl": "https://cdn.ruguoapp.com/o_1ach6nm599m94re1gvj14r71jaso.jpg?imageView2/0/w/120/h/120",
</span><span class='line'>            "middlePicUrl": "https://cdn.ruguoapp.com/o_1ach6nm599m94re1gvj14r71jaso.jpg?imageView2/0/w/300/h/300",
</span><span class='line'>            "picUrl": "https://cdn.ruguoapp.com/o_1ach6nm599m94re1gvj14r71jaso.jpg?imageView2/0/h/1000",
</span><span class='line'>            "format": "png"
</span><span class='line'>        },
</span><span class='line'>        "pictureUrl": "https://cdn.ruguoapp.com/o_1ach3c6o011j91ljjtmdhlhnffo.jpg?imageView2/1/w/200/h/300",
</span><span class='line'>        "thumbnailUrl": "https://cdn.ruguoapp.com/o_1ach6nm599m94re1gvj14r71jaso.jpg?imageView2/0/w/300/h/300"
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>你可将这段 JSON String 转换成 Dictionary 或 Array:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSDictionary</span> <span class="o">*</span><span class="n">dictionary</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSJSONSerialization</span> <span class="n">JSONObjectWithData</span><span class="o">:</span><span class="n">data</span> <span class="n">options</span><span class="o">:</span><span class="n">NSJSONReadingAllowFragments</span> <span class="n">error</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'><span class="n">NSDictionary</span> <span class="o">*</span><span class="n">subscribe</span> <span class="o">=</span> <span class="n">dictionary</span><span class="p">[</span><span class="s">@&quot;data&quot;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>接着便可使用 EasyDataKit 的 API 进行存储：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">EDKEntity</span> <span class="o">*</span><span class="n">subscribeEntity</span> <span class="o">=</span> <span class="p">[[</span><span class="n">EDKEntity</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithTableName</span><span class="o">:</span><span class="s">@&quot;subcribes&quot;</span> <span class="n">dbName</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">subscribeEntity</span> <span class="n">saveData</span><span class="o">:</span><span class="n">subscribe</span> <span class="n">primaryColumn</span><span class="o">:</span><span class="s">@&quot;id&quot;</span> <span class="n">relationShip</span><span class="o">:</span><span class="nb">nil</span> <span class="n">indexes</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以手动为数据添加列，实现满足业务的需求：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSMutableDictionary</span> <span class="o">*</span><span class="n">subcribeInfo</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSMutableDictionary</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithDictionary</span><span class="o">:</span><span class="n">subscribe</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">subcribeInfo</span> <span class="n">setObject</span><span class="o">:</span><span class="mi">@1</span> <span class="n">forKey</span><span class="o">:</span><span class="s">@&quot;isSubcribed&quot;</span><span class="p">];</span>
</span><span class='line'><span class="n">EDKEntity</span> <span class="o">*</span><span class="n">subscribeEntity</span> <span class="o">=</span> <span class="p">[[</span><span class="n">EDKEntity</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithTableName</span><span class="o">:</span><span class="s">@&quot;subcribes&quot;</span> <span class="n">dbName</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">subscribeEntity</span> <span class="n">saveData</span><span class="o">:</span><span class="n">subcribeInfo</span> <span class="n">primaryColumn</span><span class="o">:</span><span class="s">@&quot;id&quot;</span> <span class="n">relationShip</span><span class="o">:</span><span class="nb">nil</span> <span class="n">indexes</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果你想让某纪录关联其它对象，可以将对象存储后返回的 id 作为 value，key 是该纪录原本对应该对象的字段，这相当于用 id 这个值去替换原本字段对应的对象，从而达到拆分的目的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">id</span> <span class="n">rowId</span> <span class="o">=</span> <span class="p">[</span><span class="n">rectanglePictureEntity</span> <span class="n">saveData</span><span class="o">:</span><span class="n">subscribe</span><span class="p">[</span><span class="s">@&quot;rectanglePicture&quot;</span><span class="p">]</span> <span class="n">primaryColumn</span><span class="o">:</span><span class="nb">nil</span> <span class="n">relationShip</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="n">EDKEntity</span> <span class="o">*</span><span class="n">subscribeEntity</span> <span class="o">=</span> <span class="p">[[</span><span class="n">EDKEntity</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithTableName</span><span class="o">:</span><span class="s">@&quot;subcribes&quot;</span> <span class="n">dbName</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">subscribeEntity</span> <span class="n">saveData</span><span class="o">:</span><span class="n">subscribe</span> <span class="n">primaryColumn</span><span class="o">:</span><span class="s">@&quot;id&quot;</span> <span class="n">relationShip</span><span class="o">:</span><span class="p">@{</span><span class="s">@&quot;rectanglePicture&quot;</span><span class="o">:</span> <span class="n">rowId</span><span class="p">}</span> <span class="n">indexes</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>存储索引：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSDictionary</span> <span class="o">*</span><span class="n">subcribeInfo</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSDictionary</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithDictionary</span><span class="o">:</span><span class="n">subscribe</span><span class="p">];</span>
</span><span class='line'><span class="n">EDKEntity</span> <span class="o">*</span><span class="n">subscribeEntity</span> <span class="o">=</span> <span class="p">[[</span><span class="n">EDKEntity</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithTableName</span><span class="o">:</span><span class="s">@&quot;subcribes&quot;</span> <span class="n">dbName</span><span class="o">:</span><span class="s">@&quot;TestIndex&quot;</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">subscribeEntity</span> <span class="n">saveData</span><span class="o">:</span><span class="n">subcribeInfo</span> <span class="n">primaryColumn</span><span class="o">:</span><span class="nb">nil</span> <span class="n">relationShip</span><span class="o">:</span><span class="nb">nil</span> <span class="n">indexes</span><span class="o">:</span><span class="p">@[@[</span><span class="s">@&quot;topicId&quot;</span><span class="p">],</span> <span class="p">@[</span><span class="s">@&quot;content&quot;</span><span class="p">,</span> <span class="s">@&quot;messagePrefix&quot;</span><span class="p">]]];</span>
</span></code></pre></td></tr></table></div></figure>


<p>对存储来说，EasyDataKit 还提供了自动 ALTER TABLE 添加列的功能，方便开发者应对升级，原理是当检测到待存储的字典 keys 数组元素个数比之前已经在表中的列多时，则会自动为表添加新的列，即并不支持修改列和删除列的操作，而 EasyDataKit 对创建的索引是支持修改删除的。</p>

<p>查询：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// select by id</span>
</span><span class='line'><span class="n">EDKEntity</span> <span class="o">*</span><span class="n">entity</span> <span class="o">=</span> <span class="p">[[</span><span class="n">EDKEntity</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithTableName</span><span class="o">:</span><span class="s">@&quot;messages&quot;</span> <span class="n">dbName</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'><span class="kt">id</span> <span class="n">object</span> <span class="o">=</span> <span class="p">[</span><span class="n">entity</span> <span class="n">queryByPrimaryKey</span><span class="o">:</span><span class="s">@&quot;581d2fdb36a4471100e311d6&quot;</span> <span class="n">withColumns</span><span class="o">:</span><span class="p">@[</span><span class="s">@&quot;topicId&quot;</span><span class="p">,</span> <span class="s">@&quot;commentCount&quot;</span><span class="p">,</span> <span class="s">@&quot;topic&quot;</span><span class="p">]];</span>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="n">object</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">objects</span> <span class="o">=</span> <span class="p">[</span><span class="n">entity</span> <span class="n">queryWithColumns</span><span class="o">:</span><span class="nb">nil</span> <span class="n">where</span><span class="o">:</span><span class="s">@&quot;WHERE commentCount &lt; ? and read = ?&quot;</span> <span class="n">arguments</span><span class="o">:</span><span class="p">@[</span><span class="mi">@20</span><span class="p">,</span> <span class="mi">@1</span><span class="p">]];</span>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="n">objects</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>查询嵌套对象并将其转换为 Dictionary 或 Array：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">EDKEntity</span> <span class="o">*</span><span class="n">subcribeEntity</span> <span class="o">=</span> <span class="p">[[</span><span class="n">EDKEntity</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithTableName</span><span class="o">:</span><span class="s">@&quot;subcribes&quot;</span> <span class="n">dbName</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'><span class="c1">// select by id</span>
</span><span class='line'><span class="kt">id</span> <span class="n">subcribe</span> <span class="o">=</span> <span class="p">[</span><span class="n">subcribeEntity</span> <span class="n">queryByPrimaryKey</span><span class="o">:</span><span class="s">@&quot;56d177a27cb3331100465f72&quot;</span> <span class="n">withColumns</span><span class="o">:</span><span class="p">@[</span><span class="s">@&quot;squarePicture&quot;</span><span class="p">]];</span>
</span><span class='line'><span class="c1">// subcribe is a json string</span>
</span><span class='line'><span class="n">NSData</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">subcribe</span><span class="p">[</span><span class="s">@&quot;squarePicture&quot;</span><span class="p">]</span> <span class="n">dataUsingEncoding</span><span class="o">:</span><span class="n">NSUTF8StringEncoding</span><span class="p">];</span>
</span><span class='line'><span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">;</span>
</span><span class='line'><span class="n">NSDictionary</span> <span class="o">*</span><span class="n">jsonDict</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSJSONSerialization</span> <span class="n">JSONObjectWithData</span><span class="o">:</span><span class="n">data</span> <span class="n">options</span><span class="o">:</span><span class="mi">0</span> <span class="n">error</span><span class="o">:&amp;</span><span class="n">error</span><span class="p">];</span>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;JSONDict: %@&quot;</span><span class="p">,</span> <span class="n">jsonDict</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>更新：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">EDKEntity</span> <span class="o">*</span><span class="n">entity</span> <span class="o">=</span> <span class="p">[[</span><span class="n">EDKEntity</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithTableName</span><span class="o">:</span><span class="s">@&quot;messages&quot;</span> <span class="n">dbName</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">entity</span> <span class="n">updateByPrimaryKey</span><span class="o">:</span><span class="s">@&quot;5805905a319a9c1200833660&quot;</span> <span class="n">set</span><span class="o">:</span><span class="p">@{</span><span class="s">@&quot;read&quot;</span><span class="o">:</span> <span class="s">@&quot;0&quot;</span><span class="p">,</span> <span class="s">@&quot;commentCount&quot;</span><span class="o">:</span> <span class="mi">@99</span><span class="p">}];</span>
</span><span class='line'><span class="p">[</span><span class="n">entity</span> <span class="n">updateWithSet</span><span class="o">:</span><span class="p">@{</span><span class="s">@&quot;messageId&quot;</span><span class="o">:</span> <span class="s">@&quot;2333333&quot;</span><span class="p">}</span> <span class="n">where</span><span class="o">:</span><span class="s">@&quot;WHERE commentCount &gt; ?&quot;</span> <span class="n">arguments</span><span class="o">:</span><span class="p">@[</span><span class="mi">@50</span><span class="p">]];</span>
</span></code></pre></td></tr></table></div></figure>


<p>删除：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">EDKEntity</span> <span class="o">*</span><span class="n">entity</span> <span class="o">=</span> <span class="p">[[</span><span class="n">EDKEntity</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithTableName</span><span class="o">:</span><span class="s">@&quot;messages&quot;</span> <span class="n">dbName</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'><span class="c1">// delete by id</span>
</span><span class='line'><span class="p">[</span><span class="n">entity</span> <span class="n">deleteByPrimaryKey</span><span class="o">:</span><span class="s">@&quot;5805905a319a9c1200833660&quot;</span><span class="p">];</span>
</span><span class='line'><span class="c1">// delete by where</span>
</span><span class='line'><span class="p">[</span><span class="n">entity</span> <span class="n">deleteWithWhere</span><span class="o">:</span><span class="s">@&quot;WHERE popularity = ?&quot;</span> <span class="n">arguments</span><span class="o">:</span><span class="p">@[</span><span class="s">@&quot;93&quot;</span><span class="p">]];</span>
</span><span class='line'><span class="c1">// delete all</span>
</span><span class='line'><span class="p">[</span><span class="n">entity</span> <span class="n">deleteAll</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>由上面可以看出，只要创建出 EDKEntity 对象，就可以轻松加愉快地进行存储，查找，修改，删除操作。开发者无需创建数据库、表，EasyDataKit 也支持 db 的划分，但不提供内存缓存，原因是笔者认为没有热块的数据库缓存意义不是太大。当有写操作发生的时候，EasyDataKit 会通过轮询的事务机制打包写操作，从而提高频繁写操作的效率。</p>

<h2>源码简析</h2>

<p>EasyDataKit 有个 swizzle 了 NSMutableDictionary 的 setObject:forKey: 和 NSMutableArray 的 addObject:，使得应对空值不会 crash。</p>

<p>EasyDataKit 还有个递归方法：dealWithObject:，主要有两个用途：一是用来检测除了 NSDictionary、NSArray、NSString、NSNumber、NSNull 这些类型以外的合法性，譬如 UIView 类型直接调用 description 转换成字符串；二是为了能让嵌套的 Dictionary 或 Array 以 JSON String 的形式存入数据库，在取出后仍可以将其转换回 Dictionary 或 Array。</p>

<p>DISPATCH_SOURCE_TYPE_TIMER 创建的定时器。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FFmpeg iOS音频开发的小总结]]></title>
    <link href="http://hawk0620.github.io/blog/2016/10/06/ffmpeg-summary/"/>
    <updated>2016-10-06T21:52:17+08:00</updated>
    <id>http://hawk0620.github.io/blog/2016/10/06/ffmpeg-summary</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;iOS 音频开发一般是 AudioFileStream 配合 Audio Queue 或者 Audio Unit实现的，而 FFmpeg 是与原生截然不同的软解码实现，比起原生更支持了诸如 flac、ape、acc、m4a、mp3、wav等格式（原生可通过第三方支持 flac 等格式）。因为工作项目的音乐播放器是原生那套实现的，所以就想换个思路，看看用 FFmpeg 开发音频是怎样的体验。</p>

<!--more-->


<p>&emsp;&emsp;我对 FFmpeg 的探索起初是从简单 demo 入坑，发现大部分 demo 都需要 sdl，再去了解过 sdl，可谓踩了不少坑，直到我上手 kxmovie、ijkplayer，思路才渐渐清晰起来。经过对比，ijkplayer 是基于 c 实现的项目，实现了跨平台，而 kxmovie 是偏 iOS 实现的项目；kxmovie 在播放 m3u8 有点卡顿的bug，而 ijkplayer 则没有。可知 kxmovie 无论是代码兼容性还是播放视频的效果都没有 ijkplayer 好。ijkplayer 是 Bilibili 开源的一个项目，它基于 FFmpeg 开发了支持移动端音视频解码、视频渲染、播放控制、状态监控等功能。通过 ijkplayer 源码的学习，我对 FFmpeg 有了大致了解，而本文主要聊聊音频相关的。</p>

<h4>FFmpeg 的导入</h4>

<p>&emsp;&emsp;ijkplayer ReadMe 里有关如何编译 FFmpeg 的介绍，只要注意下是否支持更多解码格式即可，将生成出的 .a 文件拖进项目里，为项目添加 libbz.tbd，libbz2.tbd ，再在<code>Build Settings</code>的<code>Library Search Paths</code>添加 项目中 FFmpeg 的.a文件的目录，如 <code>$(PROJECT_DIR)/your_project_name/ffmpeg/lib</code>，FFmpeg 的导入完成了。</p>

<h4>代码处理流程大致介绍</h4>

<p>&emsp;&emsp;我只挑了几个有意思的来总结下，像 ffplay.c 一来就两三千行代码，虽然流程都是套路，但是不记录一下的话，时间久了，挺容易没什么头绪。</p>

<p>&emsp;&emsp;负责底层调用的 ffplay.c，首先注册解码器，初始化 FFPlayer 和 VideoState 开启一条线程调用 <code>read_thread</code>函数。在函数中调用<code>avformat_open_input</code>打开多媒体文件，打开文件后<code>avformat_find_stream_info</code>获取文件中的流信息填充进<code>为ic-&gt;streams</code>，获取流信息后使用<code>av_find_best_stream</code>获取文件的音频和视频流，并准备对音频和视频信息进行解码。接着调用<code>stream_component_open</code>函数，通过<code>avcodec_find_decoder</code>找到<code>codec_id</code>已注册的音视频解码器，再就是<code>avcodec_open2</code>打开解码器准备音视频的解码，再从<code>audio_open</code>开启<code>sdl_audio_callback</code>回调。此时在<code>read_thread</code>函数中会循环读取<code>av_read_frame(ic, pkt)</code>包数据，并将包数据存入包队列以供解码时使用。而对于音频解码会起新的线程调用<code>audio_thread</code>（视频则是<code>video_thread</code>），取出包数据后，使用<code>avcodec_decode_audio4</code>将解码后的 Frame 交给帧队列。<code>sdl_audio_callback </code>里的<code>audio_decode_frame</code>负责从帧队列中取出 Frame <code>frame_queue_peek_readable(&amp;is-&gt;sampq)</code>，完成重采样后，将 data 通过<code>memcpy</code>拷贝的方式回调给高层使用。</p>

<p>&emsp;&emsp;ijkplayer.c 是对 ffplay.c 的封装，包括播放暂停，获取文件时长，可播放时长，seek到特定时间点播放等，也实现了播放器的状态的监听。</p>

<p>&emsp;&emsp;<code>ijksdl_aout_ios_audiounit</code>与<code>ijksdl_aout</code>的设计挺有趣，它们共同串联了从高层到 FFmpeg 层的操作，通过指针函数，在<code>ijksdl_aout_ios_audiounit </code>注册了高层音频调用实现，<code>ijksdl_aout</code>负责供 FFmpeg 调用，从而达到解藕的效果。</p>

<h4>实践</h4>

<p>先来张效果图</p>

<p><img src="https://cloud.githubusercontent.com/assets/5633917/19155771/461f07a8-8c12-11e6-9bd8-66fdbf4e3cde.gif" alt="" /></p>

<p>&emsp;&emsp;基于边学习边动手的原则，我完成了一个仅支持音频播放的 <a href="https://github.com/hawk0620/FFMusicPlayer">demo</a>，因为仅仅是支持音频，demo中对 ijkplayer 的几个文件做了点修改，比如剔除原来视频相关的代码，修改其仅从音频文件中取出封面</p>

<pre><code>....
switch (d-&gt;avctx-&gt;codec_type) {
    case AVMEDIA_TYPE_VIDEO:
        if (d-&gt;pkt_temp.data &amp;&amp; d-&gt;pkt_temp.size) {
            ffp-&gt;artist_data = d-&gt;pkt_temp.data;
            ffp-&gt;artist_size = d-&gt;pkt_temp.size;
            ffp-&gt;cover_data(ffp);
        }
    break;
....



void audio_cover_data(uint8_t *data, int size) {
    UIImage *image = nil;
    NSData *imgData = [NSData dataWithBytes:data length:size];

    CGDataProviderRef provider = CGDataProviderCreateWithCFData((__bridge CFDataRef)(imgData));
    if (provider) {
        CGImageRef imageRef = CGImageCreateWithJPEGDataProvider(provider, NULL, YES,  kCGRenderingIntentDefault);
        if (imageRef) {

            image = [UIImage imageWithCGImage:imageRef];
            CGImageRelease(imageRef);
        }
        CGDataProviderRelease(provider);
    }
}
</code></pre>

<h4>总结</h4>

<p>&emsp;&emsp;在学习和使用中还是发现了一点小遗憾，FFmpeg 还没有提供对 io 层的缓存支持，这导致了在播放网络文件的时候拖拽进度条会重新进行缓冲，也无法实现边播边存的功能，我尝试过获取pkt的data并在<code>av_read_frame</code>的ret&lt;0文件结束的情况下缓存起来，但这其实并没能保证帧顺序，拖拽过进度条之后的data也将会不完整，所以放弃了这种方案，官方的说法是在 libavformat/cache.c 中进行实现。</p>

<p>&emsp;&emsp;有个小问题是对于缓冲进度的计算有点小误差，playableDuration 无法与多媒体文件时长一致。我尝试在<code>av_read_frame</code>文件结束的地方</p>

<pre><code>SDL_LockMutex(wait_mutex);
SDL_CondWaitTimeout(is-&gt;continue_read_thread, wait_mutex, 10);
SDL_UnlockMutex(wait_mutex);
ffp_statistic_l(ffp);
</code></pre>

<p>之后发送一个通知，直接将缓冲进度条置为100%</p>

<p>&emsp;&emsp;还有个小问题是 ijkplayer 播放本地文件的时候，假如是一首2、30m的无损歌曲，播放器不会一下子把整个文件都解码进内存中，这时当seek到文件未进入到内存的部分，播放器就直接停止播放了，我试过修改<code>MAX_QUEUE_SIZE</code>的值也是无效，最后 bbcallen 回复我说：That should be an ffmpeg issue, take a look at the comment of avformat_seek_file()，如此看来也是暂时解决无望。</p>

<p>&emsp;&emsp;在 ijkplayer 的 某个issue 中看到了 bbcallen 貌似说b站的客户端也用系统原生来播放视频，我觉得<code>iOS</code>播放视频的话使用<code>MPMoviePlayerController</code>就好了。</p>

<p>&emsp;&emsp;当然，如果是直播项目，无疑是 FFmpeg 的用武之地。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[以仿朋友圈为例谈谈保持UITableView顺滑的技巧]]></title>
    <link href="http://hawk0620.github.io/blog/2016/07/10/feed-cell/"/>
    <updated>2016-07-10T09:07:03+08:00</updated>
    <id>http://hawk0620.github.io/blog/2016/07/10/feed-cell</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;引起UITableView卡顿比较常见的原因有cell的层级过多、cell中有触发离屏渲染的代码（譬如：cornerRadius、maskToBounds
同时使用）、像素是否对齐、是否使用UITableView自动计算cell高度的方法等。本文将从cell层级出发，以一个仿朋友圈的demo来讲述如何让列表保持顺滑，项目的源码可在文末获得。不可否认的是，过早的优化是魔鬼，请在项目出现性能瓶颈再考虑优化。</p>

<!--more-->


<p>首先看看reveal上页面层级的效果图</p>

<p><img src="https://cloud.githubusercontent.com/assets/5633917/16711988/2b08a274-46aa-11e6-9936-79cbdcaf3869.png" alt="" /></p>

<p>然后是9.3系统iPhone5的真机效果</p>

<p><img src="https://cloud.githubusercontent.com/assets/5633917/16712261/506d7242-46b4-11e6-9bad-6b4a5d05c0a5.gif" alt="" /></p>

<h4>1、绘制文本</h4>

<p>&emsp;&emsp;使用core text可以将文本绘制在一个<code>CGContextRef</code>上，最后再通过<code>UIGraphicsGetImageFromCurrentImageContext()</code>生成图片，再将图片赋值给<code>cell.contentView.layer</code>，从而达到减少cell层级的目的。</p>

<p>绘制普通文本（譬如用户昵称）在context上，相关注释在代码里：</p>

<pre><code>- (void)drawInContext:(CGContextRef)context withPosition:(CGPoint)p andFont:(UIFont *)font andTextColor:(UIColor *)color andHeight:(float)height andWidth:(float)width lineBreakMode:(CTLineBreakMode)lineBreakMode {
    CGSize size = CGSizeMake(width, height);
    // 翻转坐标系
    CGContextSetTextMatrix(context,CGAffineTransformIdentity);
    CGContextTranslateCTM(context,0,height);
    CGContextScaleCTM(context,1.0,-1.0);

    NSMutableDictionary * attributes = [StringAttributes attributeFont:font andTextColor:color lineBreakMode:lineBreakMode];

    // 创建绘制区域（路径）
    CGMutablePathRef path = CGPathCreateMutable();
    CGPathAddRect(path,NULL,CGRectMake(p.x, height-p.y-size.height,(size.width),(size.height)));

    // 创建AttributedString
    NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:self attributes:attributes];
    CFAttributedStringRef attributedString = (__bridge CFAttributedStringRef)attributedStr;

    // 绘制frame
    CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attributedString);
    CTFrameRef ctframe = CTFramesetterCreateFrame(framesetter, CFRangeMake(0,0),path,NULL);
    CTFrameDraw(ctframe,context);
    CGPathRelease(path);
    CFRelease(framesetter);
    CFRelease(ctframe);
    [[attributedStr mutableString] setString:@""];
    CGContextSetTextMatrix(context,CGAffineTransformIdentity);
    CGContextTranslateCTM(context,0, height);
    CGContextScaleCTM(context,1.0,-1.0);
}
</code></pre>

<p>绘制朋友圈内容文本（带链接）在context上，这里我还没有去实现文本多了会折叠的效果，与上面普通文本不同的是这里需要创建带链接的AttributeString和CTLineRef的逐行绘制：</p>

<pre><code>- (NSMutableAttributedString *)highlightText:(NSMutableAttributedString *)coloredString{
    // 创建带高亮的AttributedString
    NSString* string = coloredString.string;
    NSRange range = NSMakeRange(0,[string length]);
    NSDataDetector *linkDetector = [NSDataDetector dataDetectorWithTypes:NSTextCheckingTypeLink error:nil];
    NSArray *matches = [linkDetector matchesInString:string options:0 range:range];

    for(NSTextCheckingResult* match in matches) {
        [self.ranges addObject:NSStringFromRange(match.range)];
        UIColor *highlightColor = UIColorFromRGB(0x297bc1);
        [coloredString addAttribute:(NSString*)kCTForegroundColorAttributeName
                              value:(id)highlightColor.CGColor range:match.range];
    }

    return coloredString;
}

- (void)drawFramesetter:(CTFramesetterRef)framesetter
       attributedString:(NSAttributedString *)attributedString
              textRange:(CFRange)textRange
                 inRect:(CGRect)rect
                context:(CGContextRef)c {
    CGMutablePathRef path = CGPathCreateMutable();
    CGPathAddRect(path, NULL, rect);
    CTFrameRef frame = CTFramesetterCreateFrame(framesetter, textRange, path, NULL);

    CGFloat ContentHeight = CGRectGetHeight(rect);
    CFArrayRef lines = CTFrameGetLines(frame);
    NSInteger numberOfLines = CFArrayGetCount(lines);

    CGPoint lineOrigins[numberOfLines];
    CTFrameGetLineOrigins(frame, CFRangeMake(0, numberOfLines), lineOrigins);

    // 遍历每一行
    for (CFIndex lineIndex = 0; lineIndex &lt; numberOfLines; lineIndex++) {
        CGPoint lineOrigin = lineOrigins[lineIndex];
        CTLineRef line = CFArrayGetValueAtIndex(lines, lineIndex);

        CGFloat descent = 0.0f, ascent = 0.0f, lineLeading = 0.0f;
        CTLineGetTypographicBounds((CTLineRef)line, &amp;ascent, &amp;descent, &amp;lineLeading);

        CGFloat penOffset = (CGFloat)CTLineGetPenOffsetForFlush(line, NSTextAlignmentLeft, rect.size.width);
        CGFloat y = lineOrigin.y - descent - self.font.descender;

        // 设置每一行位置
        CGContextSetTextPosition(c, penOffset + self.xOffset, y - self.yOffset);
        CTLineDraw(line, c);

        // CTRunRef同一行中文本的不同样式，包括颜色、字体等，此处用途为处理链接高亮
        CFArrayRef runs = CTLineGetGlyphRuns(line);
        for (int j = 0; j &lt; CFArrayGetCount(runs); j++) {
            CGFloat runAscent, runDescent, lineLeading1;

            CTRunRef run = CFArrayGetValueAtIndex(runs, j);
            NSDictionary *attributes = (__bridge NSDictionary*)CTRunGetAttributes(run);
            // 判断是不是链接
            if (!CGColorEqualToColor((__bridge CGColorRef)([attributes valueForKey:@"CTForegroundColor"]), self.textColor.CGColor)) {
                CFRange range = CTRunGetStringRange(run);
                float offset = CTLineGetOffsetForStringIndex(line, range.location, NULL);

                // 得到链接的CGRect
                CGRect runRect;
                runRect.size.width = CTRunGetTypographicBounds(run, CFRangeMake(0,0), &amp;runAscent, &amp;runDescent, &amp;lineLeading1);
                runRect.size.height = self.font.lineHeight;
                runRect.origin.x = lineOrigin.x + offset+ self.xOffset;
                runRect.origin.y = lineOrigin.y;
                runRect.origin.y -= descent + self.yOffset;

                // 因为坐标系被翻转，链接正常的坐标需要通过CGAffineTransform计算得到
                CGAffineTransform transform = CGAffineTransformMakeTranslation(0, ContentHeight);
                transform = CGAffineTransformScale(transform, 1.f, -1.f);
                CGRect flipRect = CGRectApplyAffineTransform(runRect, transform);

                // 保存是链接的CGRect
                NSRange nRange = NSMakeRange(range.location, range.length);
                self.framesDict[NSStringFromRange(nRange)] = [NSValue valueWithCGRect:flipRect];

                // 保存同一条链接的不同CGRect，用于点击时背景色处理
                for (NSString *rangeString in self.ranges) {
                    NSRange range = NSRangeFromString(rangeString);
                    if (NSLocationInRange(nRange.location, range)) {
                        NSMutableArray *array = self.relationDict[rangeString];
                        if (array) {
                            [array addObject:NSStringFromCGRect(flipRect)];
                            self.relationDict[rangeString] = array;
                        } else {
                            self.relationDict[rangeString] = [NSMutableArray arrayWithObject:NSStringFromCGRect(flipRect)];
                        }
                    }
                }

            }
        }
    }

    CFRelease(frame);
    CFRelease(path);
}
</code></pre>

<p>上述方法运用起来就是：</p>

<pre><code>- (void)fillData:(CGContextRef)context {
    [self.nickname drawInContext:context withPosition:(CGPoint){kTextXOffset, kSpec} andFont:kNicknameFont
                    andTextColor:UIColorFromRGB(0x556c95) andHeight:self.nicknameSize.height
                        andWidth:self.nicknameSize.width lineBreakMode:kCTLineBreakByTruncatingTail];
    [self.drawer setText:self.contentString context:context contentSize:self.contentSize
         backgroundColor:[UIColor whiteColor] font:kContentTextFont textColor:[UIColor blackColor]
                   block:nil xOffset:kTextXOffset yOffset:kSpec * 2 + self.nicknameSize.height];
}

- (void)fillContents:(NSArray *)array {
    UIGraphicsBeginImageContextWithOptions(CGSizeMake(self.size.width, self.size.height), YES, 0);
    CGContextRef context = UIGraphicsGetCurrentContext();
    [UIColorFromRGB(0xffffff) set];
    CGContextFillRect(context, CGRectMake(0, 0, self.size.width, self.size.height));

    // 获取需要高亮的链接CGRect，并填充背景色
    if (array) {
        for (NSString *string in array) {
            CGRect rect = CGRectFromString(string);
            [UIColorFromRGB(0xe5e5e5) set];
            CGContextFillRect(context, rect);
        }
    }

    [self fillData:context];

    UIImage *temp = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    self.contentView.layer.contents = (__bridge id _Nullable)(temp.CGImage);
}
</code></pre>

<p>这样就完成了文本的显示。</p>

<h4>2、显示图片</h4>

<p>&emsp;&emsp;图片包括用户头像和朋友圈的内容，这里只是将CALayer添加到contentView.layer上，具体做法是继承了CALayer，实现部分功能。</p>

<p>通过链接显示图片：</p>

<pre><code>- (void)setContentsWithURLString:(NSString *)urlString {

    self.contents = (__bridge id _Nullable)([UIImage imageNamed:@"placeholder"].CGImage);
    @weakify(self)
    SDWebImageManager *manager = [SDWebImageManager sharedManager];
    [manager downloadImageWithURL:[NSURL URLWithString:urlString]
                          options:SDWebImageCacheMemoryOnly
                         progress:nil
                        completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) {
                            if (image) {
                                @strongify(self)
                                dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
                                    if (!_observer) {

                                        _observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopBeforeWaiting | kCFRunLoopExit, false, POPAnimationApplyRunLoopOrder, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) {
                                            self.contents = (__bridge id _Nullable)(image.CGImage);
                                        });

                                        if (_observer) {
                                            CFRunLoopAddObserver(CFRunLoopGetMain(), _observer,  kCFRunLoopCommonModes);
                                        }
                                    }
                                });
                                self.originImage = image;
                            }
                        }];
}
</code></pre>

<p>其他比较简单就不展开。</p>

<h4>3、显示小视频</h4>

<p>&emsp;&emsp;之前的一篇文章简单讲了怎么自己做一个播放器，这里就派上用场了。而显示小视频封面图片的CALayer同样在显示小视频的时候可以复用。</p>

<p>这里使用了<code>NSOperationQueue</code>来保障播放视频的流畅性，具体继承<code>NSOperation</code>的<code>VideoDecodeOperation</code>相关代码如下：</p>

<pre><code>- (void)main {

    @autoreleasepool {

        if (self.isCancelled) {
            _newVideoFrameBlock = nil;
            _decodeFinishedBlock = nil;
            return;
        }

        AVURLAsset *asset = [AVURLAsset URLAssetWithURL:[[NSURL alloc] initFileURLWithPath:self.filePath] options:nil];
        NSError *error;
        AVAssetReader* reader = [[AVAssetReader alloc] initWithAsset:asset error:&amp;error];
        if (error) {
            return;
        }

        NSArray* videoTracks = [asset tracksWithMediaType:AVMediaTypeVideo];
        AVAssetTrack* videoTrack = [videoTracks objectAtIndex:0];
        // 视频播放时，m_pixelFormatType=kCVPixelFormatType_32BGRA
        // 其他用途，如视频压缩，m_pixelFormatType=kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange
        int m_pixelFormatType = kCVPixelFormatType_32BGRA;
        NSDictionary* options = [NSDictionary dictionaryWithObject:[NSNumber numberWithInt: (int)m_pixelFormatType]
                                                            forKey:(id)kCVPixelBufferPixelFormatTypeKey];
        AVAssetReaderTrackOutput* videoReaderOutput = [[AVAssetReaderTrackOutput alloc]
                initWithTrack:videoTrack outputSettings:options];
        [reader addOutput:videoReaderOutput];
        [reader startReading];
        // 要确保nominalFrameRate&gt;0，之前出现过android拍的0帧视频
        if (self.isCancelled) {
            _newVideoFrameBlock = nil;
            _decodeFinishedBlock = nil;
            return;
        }

        while ([reader status] == AVAssetReaderStatusReading &amp;&amp; videoTrack.nominalFrameRate &gt; 0) {
            if (self.isCancelled) {
                _newVideoFrameBlock = nil;
                _decodeFinishedBlock = nil;
                return;
            }

            CMSampleBufferRef sampleBuffer = [videoReaderOutput copyNextSampleBuffer];
            CVImageBufferRef imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer);

            // Lock the base address of the pixel buffer
            CVPixelBufferLockBaseAddress(imageBuffer, 0);

            // Get the number of bytes per row for the pixel buffer
            size_t bytesPerRow = CVPixelBufferGetBytesPerRow(imageBuffer);

            // Get the pixel buffer width and height
            size_t width = CVPixelBufferGetWidth(imageBuffer);
            size_t height = CVPixelBufferGetHeight(imageBuffer);

            //Generate image to edit`
            unsigned char* pixel = (unsigned char *)CVPixelBufferGetBaseAddress(imageBuffer);

            CGColorSpaceRef colorSpace=CGColorSpaceCreateDeviceRGB();
            CGContextRef context=CGBitmapContextCreate(pixel, width, height, 8, bytesPerRow, colorSpace,
                                                       kCGBitmapByteOrder32Little|kCGImageAlphaPremultipliedFirst);
            if (context != NULL) {
                CGImageRef imageRef = CGBitmapContextCreateImage(context);

                CVPixelBufferUnlockBaseAddress(imageBuffer, 0);
                CGColorSpaceRelease(colorSpace);
                CGContextRelease(context);

                // 解码图片
                size_t width = CGImageGetWidth(imageRef);
                size_t height = CGImageGetHeight(imageRef);
                size_t bitsPerComponent = CGImageGetBitsPerComponent(imageRef);

                // CGImageGetBytesPerRow() calculates incorrectly in iOS 5.0, so defer to CGBitmapContextCreate
                size_t bytesPerRow = 0;
                CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
                CGColorSpaceModel colorSpaceModel = CGColorSpaceGetModel(colorSpace);
                CGBitmapInfo bitmapInfo = CGImageGetBitmapInfo(imageRef);

                if (colorSpaceModel == kCGColorSpaceModelRGB) {
                    uint32_t alpha = (bitmapInfo &amp; kCGBitmapAlphaInfoMask);
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassign-enum"
                    if (alpha == kCGImageAlphaNone) {
                        bitmapInfo &amp;= ~kCGBitmapAlphaInfoMask;
                        bitmapInfo |= kCGImageAlphaNoneSkipFirst;
                    } else if (!(alpha == kCGImageAlphaNoneSkipFirst || alpha == kCGImageAlphaNoneSkipLast)) {
                        bitmapInfo &amp;= ~kCGBitmapAlphaInfoMask;
                        bitmapInfo |= kCGImageAlphaPremultipliedFirst;
                    }
#pragma clang diagnostic pop
                }

                CGContextRef context = CGBitmapContextCreate(NULL, width, height, bitsPerComponent,
                                                             bytesPerRow, colorSpace, bitmapInfo);

                CGColorSpaceRelease(colorSpace);

                if (!context) {
                    if (self.newVideoFrameBlock) {
                        dispatch_async(dispatch_get_main_queue(), ^{
                            if (self.isCancelled) {
                                _newVideoFrameBlock = nil;
                                _decodeFinishedBlock = nil;
                                return;
                            }
                            self.newVideoFrameBlock(imageRef, self.filePath);
                            CGImageRelease(imageRef);
                        });
                    }
                } else {

                    CGContextDrawImage(context, CGRectMake(0.0f, 0.0f, width, height), imageRef);
                    CGImageRef inflatedImageRef = CGBitmapContextCreateImage(context);

                    CGContextRelease(context);
                    if (self.newVideoFrameBlock) {
                        dispatch_async(dispatch_get_main_queue(), ^{
                            if (self.isCancelled) {
                                _newVideoFrameBlock = nil;
                                _decodeFinishedBlock = nil;
                                return;
                            }
                            self.newVideoFrameBlock(inflatedImageRef, self.filePath);

                            CGImageRelease(inflatedImageRef);
                        });
                    }
                    CGImageRelease(imageRef);
                }

                if(sampleBuffer) {
                    CMSampleBufferInvalidate(sampleBuffer);
                    CFRelease(sampleBuffer);
                    sampleBuffer = NULL;

                } else {
                    break;
                }
            }

            [NSThread sleepForTimeInterval:CMTimeGetSeconds(videoTrack.minFrameDuration)];
        }

        if (self.isCancelled) {
            _newVideoFrameBlock = nil;
            _decodeFinishedBlock = nil;
            return;
        }
        if (self.decodeFinishedBlock) {
            self.decodeFinishedBlock(self.filePath);
        }
    }
}
</code></pre>

<p>解码图片是因为UIImage在界面需要显示的时候才开始解码，这样可能会造成主线程的卡顿，所以在子线程对其进行解压缩处理。</p>

<p>具体的使用：</p>

<pre><code>- (void)playVideoWithFilePath:(NSString *)filePath_ type:(NSString *)type {
    @weakify(self)
    [[VideoPlayerManager shareInstance] decodeVideo:filePath_
                              withVideoPerDataBlock:^(CGImageRef imageData, NSString *filePath) {
                                  @strongify(self)
                                  if ([type isEqualToString:@"video"]) {
                                      if ([filePath isEqualToString:self.filePath]) {
                                          [self.sources.firstObject
                                                  setContents:(__bridge id _Nullable)(imageData)];
                                      }
                                  }
                              } decodeFinishBlock:^(NSString *filePath){
                [self playVideoWithFilePath:filePath type:type];
            }];
}
</code></pre>

<h4>4、其他</h4>

<p>&emsp;&emsp;1、触摸交互是覆盖了以下方法实现：</p>

<pre><code>- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event
- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event
- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event
</code></pre>

<p>&emsp;&emsp;2、页面上FPS的测量是使用了YYKit项目中的YYFPSLabel。</p>

<p>&emsp;&emsp;3、测试数据是微博找的，其中小视频是Gif快手。</p>

<p>本文的代码在<a href="">https://github.com/hawk0620/PYQFeedDemo</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[聊聊动画引擎pop]]></title>
    <link href="http://hawk0620.github.io/blog/2016/04/30/talk-with-pop/"/>
    <updated>2016-04-30T23:51:12+08:00</updated>
    <id>http://hawk0620.github.io/blog/2016/04/30/talk-with-pop</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;iOS可以通过CADisplayLink实现自定义动画引擎，pop就是基于此实现的，而且比原生Core Animation更强大好用。譬如当ViewController侧滑返回的时候，系统会将Core Animation的动画会停止，而基于CADisplayLink实现的动画则不会停止，因而可以实现类似网易云音乐从播放页侧滑时hold住专辑封面图旋转的效果。</p>

<!--more-->


<h3>八一八魔性的pop</h3>

<h4>1、实用的宏</h4>

<pre><code>#define POP_ARRAY_COUNT(x) sizeof(x) / sizeof(x[0])



#define FB_PROPERTY_GET(stype, property, ctype) \
- (ctype)property { \
  return ((stype *)_state)-&gt;property; \
}

#define FB_PROPERTY_SET(stype, property, mutator, ctype, ...) \
- (void)mutator (ctype)value { \
  if (value == ((stype *)_state)-&gt;property) \
    return; \
  ((stype *)_state)-&gt;property = value; \
  __VA_ARGS__ \
}

#define FB_PROPERTY_SET_OBJ_COPY(stype, property, mutator, ctype, ...) \
- (void)mutator (ctype)value { \
  if (value == ((stype *)_state)-&gt;property) \
    return; \
  ((stype *)_state)-&gt;property = [value copy]; \
  __VA_ARGS__ \
}
</code></pre>

<h4>2、判定值的数据类型</h4>

<p>pop定义了支持的值的数据类型</p>

<pre><code>const POPValueType kPOPAnimatableSupportTypes[10] = {kPOPValueInteger, kPOPValueFloat, kPOPValuePoint, kPOPValueSize, kPOPValueRect, kPOPValueEdgeInsets, kPOPValueColor, kPOPValueSCNVector3, kPOPValueSCNVector4};
</code></pre>

<p>通过@encode指令，将给定类型编码的内部字符串与objcType对比，得到值的数据类型</p>

<pre><code>static bool FBCompareTypeEncoding(const char *objctype, POPValueType type)
{
  switch (type)
  {
    case kPOPValueFloat:
      return (strcmp(objctype, @encode(float)) == 0
              || strcmp(objctype, @encode(double)) == 0
              );

    case kPOPValuePoint:
      return (strcmp(objctype, @encode(CGPoint)) == 0
#if !TARGET_OS_IPHONE
              || strcmp(objctype, @encode(NSPoint)) == 0
#endif
              );

    case kPOPValueSize:
      return (strcmp(objctype, @encode(CGSize)) == 0
#if !TARGET_OS_IPHONE
              || strcmp(objctype, @encode(NSSize)) == 0
#endif
              );

    case kPOPValueRect:
      return (strcmp(objctype, @encode(CGRect)) == 0
#if !TARGET_OS_IPHONE
              || strcmp(objctype, @encode(NSRect)) == 0
#endif
              );
    case kPOPValueEdgeInsets:
#if TARGET_OS_IPHONE
      return strcmp(objctype, @encode(UIEdgeInsets)) == 0;
#else
      return false;
#endif

    case kPOPValueAffineTransform:
      return strcmp(objctype, @encode(CGAffineTransform)) == 0;

    case kPOPValueTransform:
      return strcmp(objctype, @encode(CATransform3D)) == 0;

    case kPOPValueRange:
      return strcmp(objctype, @encode(CFRange)) == 0
      || strcmp(objctype, @encode (NSRange)) == 0;

    case kPOPValueInteger:
      return (strcmp(objctype, @encode(int)) == 0
              || strcmp(objctype, @encode(unsigned int)) == 0
              || strcmp(objctype, @encode(short)) == 0
              || strcmp(objctype, @encode(unsigned short)) == 0
              || strcmp(objctype, @encode(long)) == 0
              || strcmp(objctype, @encode(unsigned long)) == 0
              || strcmp(objctype, @encode(long long)) == 0
              || strcmp(objctype, @encode(unsigned long long)) == 0
              );

    case kPOPValueSCNVector3:
#if SCENEKIT_SDK_AVAILABLE
      return strcmp(objctype, @encode(SCNVector3)) == 0;
#else
      return false;
#endif

    case kPOPValueSCNVector4:
#if SCENEKIT_SDK_AVAILABLE
      return strcmp(objctype, @encode(SCNVector4)) == 0;
#else
      return false;
#endif

    default:
      return false;
  }
}
</code></pre>

<h4>3、将值的数据类型标准化为Vector</h4>

<p>举个CGRect类型的例子：</p>

<pre><code>case kPOPValueRect:
      vec = Vector::new_cg_rect([value CGRectValue]);

Vector *Vector::new_cg_rect(const CGRect &amp;r)
  {
    Vector *v = new Vector(4);
    v-&gt;_values[0] = r.origin.x;
    v-&gt;_values[1] = r.origin.y;
    v-&gt;_values[2] = r.size.width;
    v-&gt;_values[3] = r.size.height;
    return v;
  }
</code></pre>

<p>通过Vector的两个参数<code>size_t _count;</code>、<code>CGFloat *_values;</code>将给定的类型抽象出来，实现解耦。此外还有一个好处，当创建属性动画为<code>kPOPLayerBounds</code>，但toValue属性赋值的是一个<code>NSNumber</code>，得益于<code>_values</code>是数组指针，并不会引发数组越界导致的crash，只是动画效果不可预期。</p>

<h4>4、基于NSRunLoop的动画更新机制</h4>

<pre><code>- (void)_scheduleProcessPendingList
{
  // see WebKit for magic numbers, eg http://trac.webkit.org/changeset/166540
  static const CFIndex CATransactionCommitRunLoopOrder = 2000000;
  static const CFIndex POPAnimationApplyRunLoopOrder = CATransactionCommitRunLoopOrder - 1;

  // lock
  OSSpinLockLock(&amp;_lock);

  if (!_pendingListObserver) {
    __weak POPAnimator *weakSelf = self;

    _pendingListObserver = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopBeforeWaiting | kCFRunLoopExit, false, POPAnimationApplyRunLoopOrder, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) {
      [weakSelf _processPendingList];
    });

    if (_pendingListObserver) {
      CFRunLoopAddObserver(CFRunLoopGetMain(), _pendingListObserver,  kCFRunLoopCommonModes);
    }
  }

  // unlock
  OSSpinLockUnlock(&amp;_lock);
}
</code></pre>

<p>在主线程RunLoop中添加观察者，监听了<code>kCFAllocatorDefault</code>、<code>kCFRunLoopBeforeWaiting</code>、<code>kCFRunLoopExit</code>事件，在收到回调的时候，处理<code>_pendingList</code>里的动画。</p>

<h4>5、更新动画的回调数组</h4>

<pre><code>static POPStaticAnimatablePropertyState _staticStates[] =
{
  /* CALayer */

  {kPOPLayerBackgroundColor,
    ^(CALayer *obj, CGFloat values[]) {
      POPCGColorGetRGBAComponents(obj.backgroundColor, values);
    },
    ^(CALayer *obj, const CGFloat values[]) {
      CGColorRef color = POPCGColorRGBACreate(values);
      [obj setBackgroundColor:color];
      CGColorRelease(color);
    },
    kPOPThresholdColor
  },

  {kPOPLayerBounds,
    ^(CALayer *obj, CGFloat values[]) {
      values_from_rect(values, [obj bounds]);
    },
    ^(CALayer *obj, const CGFloat values[]) {
      [obj setBounds:values_to_rect(values)];
    },
    kPOPThresholdPoint
  },
...
</code></pre>

<p>封装不同的动画行为，实现类似模板模式，只需统一调用，即可更新动画</p>

<pre><code>// write value
write(obj, currentVec-&gt;data());
</code></pre>

<h4>6、动画插值的动态实现</h4>

<pre><code>switch (type) {
      case kPOPAnimationSpring:
        advanced = advance(time, dt, obj);
        break;
      case kPOPAnimationDecay:
        advanced = advance(time, dt, obj);
        break;
      case kPOPAnimationBasic: {
        advanced = advance(time, dt, obj);
        computedProgress = true;
        break;
      }
      case kPOPAnimationCustom: {
        customFinished = [self _advance:obj currentTime:time elapsedTime:dt] ? false : true;
        advanced = true;
        break;
      }
      default:
        break;
    }
</code></pre>

<p>可以看出总共有四种动画插值的算法，以kPOPAnimationBasic为例：</p>

<pre><code>bool advance(CFTimeInterval time, CFTimeInterval dt, id obj) {
    // default timing function
    if (!timingFunction) {
      ((POPBasicAnimation *)self).timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionDefault];
    }

    // solve for normalized time, aka progresss [0, 1]
    CGFloat p = 1.0f;
    if (duration &gt; 0.0f) {
        // cap local time to duration
        CFTimeInterval t = MIN(time - startTime, duration) / duration;
        p = POPTimingFunctionSolve(timingControlPoints, t, SOLVE_EPS(duration));
        timeProgress = t;
    } else {
        timeProgress = 1.;
    }

    // interpolate and advance
    interpolate(valueType, valueCount, fromVec-&gt;data(), toVec-&gt;data(), currentVec-&gt;data(), p);
    progress = p;
    clampCurrentValue();

    return true;
  }
</code></pre>

<p>依照给定的<code>timingFunction</code>，使用<code>POPTimingFunctionSolve</code>计算贝塞尔曲线的变化率，再通过混合计算<code>#define MIX(a, b, f) ((a) + (f) * ((b) - (a)))</code>，最终得到动画的插值。</p>

<h3>小结</h3>

<p>pop中还有很多有意思的地方，譬如<code>TransformationMatrix</code>里的矩阵操作，这里就暂且不挖WebCore底层了。简而言之，无论性能(c++混编)、易用、容错，pop都有着作为引擎该有的特性，而它所暴露的和Core Animation相似的接口也让人极易上手！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[谈谈%@可以格式怎样的NSInteger]]></title>
    <link href="http://hawk0620.github.io/blog/2016/03/01/tan-tan-percent-at-ke-yi-ge-shi-zen-yang-de-nsinteger/"/>
    <updated>2016-03-01T16:25:26+08:00</updated>
    <id>http://hawk0620.github.io/blog/2016/03/01/tan-tan-percent-at-ke-yi-ge-shi-zen-yang-de-nsinteger</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;在荔枝面试时遇到一个这样的问题，age是NSInteger类型，</p>

<pre><code>UILabel *mylabel=[UILabel new]; 
mylabel.text=age?[NSString stringWithFormat:@"%@",age]:@"";
</code></pre>

<p>以上的代码编译通过，运行可能crash？</p>

<p>&emsp;&emsp;问题本身很容易答出，无非是NSInteger是基本类型，%@格式化的是Objective-C对象。所以运行时就会crash。但是面试官提出了一个这样的问题：当age是什么值时，运行不会crash？</p>

<!--more-->


<p>&emsp;&emsp;我当时没能答出来，回家后思考验证了一番，发现当age=0的时候，运行就不会crash。为什么age=0时，不会crash呢？%@的作用是格式Objective-C对象，也即是一个指针类型，就是说0代表的是个指针类型。用<code>NSLog(@"%p", 0);</code>打印结果是0x0，所以就不会出现crash。原来c语言定义了整型常量0可以转换成null指针，但不意味着null指针指向0x0的地址，而仅仅是字面量0转换成指针时会变成null指针。在C语言中，null和0的值是一样的，只是null用于指针和对象，0用于数值。</p>

<p>&emsp;&emsp;到这里也算是介绍完了，既然话匣子打开了，就顺便再说说荔枝的另一个题目。一个长度n的数组，其中有个元素的出现次数大于n>>1，求出这个元素（时间复杂度n，空间复杂度1）。由于面试时的紧张，我当时只想到了排序后的求解，并不是最优解。后来也是在家中想出了一个好的解法：只需遍历一遍数组，用一个key是元素，value是出现次数的字典，当没有匹配到key时，将元素作为key，value为1插入，当匹配到key的时候，将value取出加1再赋给key，并比较value的值是不是>2/n了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C序列化库protobuf的安装]]></title>
    <link href="http://hawk0620.github.io/blog/2016/01/10/protobuf-objc/"/>
    <updated>2016-01-10T17:59:29+08:00</updated>
    <id>http://hawk0620.github.io/blog/2016/01/10/protobuf-objc</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;protobuf是google开源的二进制序列化库，对网络传输或是流量有较高要求的移动应用可以使用二进制协议，而非文本协议，这时protobuf将是不错的选择。</p>

<!--more-->


<p>&emsp;&emsp;下面简单介绍下Mac系统下Objective-C语言的protobuf的安装：</p>

<p>1、在<a href="https://github.com/google/protobuf/releases">protobuf</a>下载面向Objective-C的protobuf库</p>

<p>2、cd到下载的目录，执行<code>./autogen.sh</code></p>

<p>3、再依次执行</p>

<pre><code>$ ./configure
$ make
$ make check
$ sudo make install
$ sudo ldconfig # refresh shared library cache.        
</code></pre>

<p>4、再执行<code>objectivec/DevTools/full_mac_build.sh</code>，执行完后会看到src目录下生成了protoc二进制文件</p>

<p>PS:如果执行过程遇到了</p>

<pre><code>native:
     [exec] xcode-select: error: tool 'xcodebuild' requires Xcode, but active developer directory '/Library/Developer/CommandLineTools' is a command line tools instance
</code></pre>

<p>可能是Xcode只有command line tools，而没有完整的Xcode UI，执行：
<code>brew install autoconf automake libtool gettext</code>即可。</p>

<p>5、如果一切顺利，那就恭喜你了，接下来可是收获的时刻了。我在src目录里创建了一个Person.proto的文件，并将以下内容拷贝进去：</p>

<pre><code>syntax = "proto2";

message Person {
  required string name = 1;
  required int32 id = 2;
  optional string email = 3;
}
</code></pre>

<p>注意：需要指明proto的语法规则是proto2还是proto3。</p>

<p>6、我在src目录下还创建了bulid/gen这样的目录，最后我在src目录的位置执行<code>protoc --proto_path=../src --objc_out=../src/build/gen ../src/Person.proto</code>，然后去bulid/gen/下找到你心仪的文件拖进项目使用吧（项目得引入了objc版的protobuf）。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2015年我读过的几本书]]></title>
    <link href="http://hawk0620.github.io/blog/2016/01/03/2015booklist/"/>
    <updated>2016-01-03T14:12:29+08:00</updated>
    <id>http://hawk0620.github.io/blog/2016/01/03/2015booklist</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;眨眼工作就快两个年头了，虽然在初创公司的经历有点坎坷，但是自身的成长却是多方面的，最大的转变是我不再唯技术论了，而是以一种玩的心态来做技术，关注起产品的交互、设计与体验，也认识到沟通是一项很重要的能力。下面介绍下过去一年对我产生影响的书吧：</p>

<!--more-->


<p>1、代码大全</p>

<p><img src="https://cloud.githubusercontent.com/assets/5633917/12077774/0eb669a8-b230-11e5-8875-d72917b8e196.jpg" alt="dd" /></p>

<p>ps:它是我从公司图书馆借来的，兴奋得在带回家的路上拍了下来。</p>

<p>这是本挺好的入门程序开发的书籍，讲述了很多编程规范，对养成良好的编码习惯很有帮助。</p>

<p>2、iOS开发进阶</p>

<p><img src="https://cloud.githubusercontent.com/assets/5633917/12077783/820060da-b230-11e5-8ccf-960af28f3ebb.jpg" alt="dd" /></p>

<p>介绍了很多工具集，开发一个iOS的方方面面，其中最推崇的就是Core Text一章。</p>

<p>3、iOS Core Animation</p>

<p><img src="https://cloud.githubusercontent.com/assets/5633917/12077788/9b7bbdd4-b230-11e5-8011-5143bb732526.jpg" alt="dd" /></p>

<p>从CALayer基础出发，完整地讲解了iOS动画的许多特性，但是缺乏实战案例。</p>

<p>4、AppCoda Beginning iOS 8 Programming with Swift</p>

<p><img src="https://cloud.githubusercontent.com/assets/5633917/12077797/ee139bb6-b230-11e5-8634-aee0a5714227.jpg" alt="dd" /></p>

<p>只能说是介绍如何用Swift做一个项目，缺乏深度。</p>

<p>5、The Swift Programming Language</p>

<p>苹果官方的语言书，怀着学C语言一样的初心去看。</p>

<p>6、WatchKit_by_Tutorial</p>

<p><img src="https://cloud.githubusercontent.com/assets/5633917/12077805/0fc0018c-b231-11e5-941c-30e9c735c18c.jpg" alt="dd" /></p>

<p>ps:上面说了这么多Swift&hellip;其实当时主管让我私下完成公司项目的APPLE Watch版，我在技术储备得差不多的时候，公司突然业务转型了，Watch版自然也不做了。</p>

<p>该书浅显易懂，一句话从零开发APPLE Watch。</p>

<p>7、微信力量</p>

<p><img src="https://cloud.githubusercontent.com/assets/5633917/12077813/73eed8c2-b231-11e5-86b7-6033c2526df1.jpg" alt="dd" /></p>

<p>开拓眼界的一本书，从而对微信团队更加肃然起敬。</p>

<p>8、Facebook效应</p>

<p><img src="https://cloud.githubusercontent.com/assets/5633917/12077818/a4151eb2-b231-11e5-8850-087517d7c4f6.jpg" alt="dd" /></p>

<p>让我跳出唯技术论的一本书，教会了我以一种玩的心态去做技术。</p>

<p>9、解忧杂货店</p>

<p><img src="https://cloud.githubusercontent.com/assets/5633917/12077829/f69e04d2-b231-11e5-828f-ceb5ee49ce0d.jpg" alt="dd" /></p>

<p>挺好看的一本小说。</p>

<p>&emsp;&emsp;目前正在拜读《iOS应用逆向工程》。希望2016年可以读更多的好书和开源代码～</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何实现方形图片裁剪器]]></title>
    <link href="http://hawk0620.github.io/blog/2016/01/01/crop-square-image/"/>
    <updated>2016-01-01T11:03:07+08:00</updated>
    <id>http://hawk0620.github.io/blog/2016/01/01/crop-square-image</id>
    <content type="html"><![CDATA[<h3>对微信方形图片裁剪器的剖析</h3>

<p>&emsp;&emsp;我在做的一个兴趣项目时需要将图片裁剪成方形，联想到微信也有裁剪方形图片的功能。微信—-更换头像—-从相册选择这一流程中会要求用户将已选的图片裁剪成方形。其顺滑的移动缩放图片体验，可以判断出应该是<code>UIScorllView</code>实现而非通过<code>UIPinchGestureRecognizer</code>和<code>UIPanGestureRecognizer</code>组合实现的。因为<code>UIScorllView</code>有一个<code>viewForZoomingInScrollView</code>代理方法，该方法能实现对图片的缩放，所以使用<code>UIScorllView</code>可以满足需求。</p>

<!--more-->


<h3>开始动手实现方形图片裁剪器</h3>

<p>&emsp;&emsp;有了以上的基础后，观察到在微信图片裁剪器中的图片是可以缩放到全屏的，即给我们很直观的感觉<code>UIScorllView</code>的<code>frame</code>应该是屏幕大小<code>CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height)</code>。</p>

<p>&emsp;&emsp;再创建好UIScrollView后加入UIImageView，<code>[self.scrollView addSubview:self.imageView];</code>，并且实现<code>UIScorllView</code>的代理方法。运行程序后，我发现UIImageView不会以屏幕中间的方形框作为移动边界，而是以屏幕作为移动的边界。想想也对，因为我把<code>UIScorllView</code>的<code>frame</code>设置为屏幕了。。。</p>

<p>&emsp;&emsp;这个时候我基本明白了<code>UIScorllView</code>的<code>frame</code>必须得是在屏幕中间的方形。在一番修改之后，我发现了基本上移动边界的问题解决了（下面会说没瑕疵是啥）。可是由于<code>UIScorllView</code>的<code>frame</code>不是全屏了，随之带来的问题是缩放或者移动的<code>UIImageView</code>超过了<code>UIScorllView</code>的<code>frame</code>就显示不了了。难道我又想错了吗？其实不然，不是还有个<code>clipsToBounds</code>属性嘛。</p>

<p>&emsp;&emsp;剩下的工作只有居中初次进入裁剪页面<code>UIImageView</code>，那么就居中<code>UIImageView</code>：</p>

<pre><code>self.imageView.center = CGPointMake(self.view.bounds.size.width/2.0, CGRectGetMidY(self.scrollView.frame) - CGRectGetMinY(self.scrollView.frame));
</code></pre>

<p>并且设置<code>UIScrollView</code>的<code>contentSize</code>:</p>

<pre><code>self.scrollView.contentSize = CGSizeMake(self.scrollView.bounds.size.width, self.scrollView.bounds.size.height);
</code></pre>

<p>&emsp;&emsp;这时终于可以长舒一口气了吧～编译运行：</p>

<p><img src="https://cloud.githubusercontent.com/assets/5633917/12069698/efbacbd6-b07f-11e5-8cd4-4c28b796920e.png" alt="dd" /></p>

<p>发现当图片的高度大于屏幕宽度时，<code>UIScrollView</code>的移动边界会出现图片顶端无法下移，而底端上移太多的问题。这时想起了<code>contentOffset</code>属性来设置高度大于宽度图片的居中位置：</p>

<pre><code>if (self.imageView.bounds.size.height &gt; viewWidth) {
    self.scrollView.contentOffset = CGPointMake(0, (self.imageView.frame.size.height - viewWidth)/2.0);
    self.scrollView.contentSize = CGSizeMake(self.scrollView.bounds.size.width, self.imageView.bounds.size.height);

} else {
    self.scrollView.contentSize = CGSizeMake(self.scrollView.bounds.size.width, self.scrollView.bounds.size.height);
    self.imageView.center = CGPointMake(viewWidth/2.0, CGRectGetMidY(self.scrollView.frame) - CGRectGetMinY(self.scrollView.frame));
}
</code></pre>

<p>大功告成！一个看似不复杂的图片裁剪器，里面却暗藏了许多小技巧。最后附上<a href="https://github.com/hawk0620/SquareCropDemo">源码链接</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSOperation初探]]></title>
    <link href="http://hawk0620.github.io/blog/2015/12/21/nsoperation/"/>
    <updated>2015-12-21T11:00:21+08:00</updated>
    <id>http://hawk0620.github.io/blog/2015/12/21/nsoperation</id>
    <content type="html"><![CDATA[<h3>NSOperation vs GCD</h3>

<p>&emsp;&emsp;如果对某个技术太执着，真的是件挺可怕的事情。在认识NSOperation之前，我单纯地以为GCD是多线程的不二法门，以致于只会无脑地：</p>

<pre><code>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
     // some handle
     dispatch_sync(dispatch_get_main_queue(), ^{
            // update ui
     });      
});
</code></pre>

<p>还有<code>dispatch_group_t</code>工作组，可以添加执行多个任务，通过<code>dispatch_group_notify</code>达到不阻塞的等待回调；<code>dispatch_source_t</code>轻易地监控许多诸如UNIX信号；<code>dispatch_barrier_async</code>解决恼人的读写问题等&hellip;</p>

<!--more-->


<p>我甚至认为：<code>NSOperation</code>是苹果为了造福小白而开发出的高级API。但是落实到具体的场景中，怎么方便地取消一个任务，怎么设置任务之间的依赖，怎么暂停一个任务、然后再继续，怎么设置最大的并发任务数&hellip;所有的这些，用GCD实现起来太麻烦了，但是<code>NSOperation</code>和<code>NSOperationQueue</code>就胜任这种场景。当然了，并不是GCD就一无是处了，根据具体场景配合使用是最佳的实现方案。</p>

<h3>NSOperation如何使用</h3>

<p>&emsp;&emsp;<code>NSOperation</code>的使用挺像Java里的<code>Runnable</code>，需要子类化来实现。有两个子类化<code>NSOperation</code>的方法：</p>

<p>1.重写main方法，这个方法的好处是简单，无需处理太多其它的状态值，只是不断地检测cancel状态：</p>

<pre><code>if (self.isCancelled)
     return;
</code></pre>

<p>最后，如果是通过delegate方式回调，需要在主线程回调出去：</p>

<pre><code>[(NSObject *)self.delegate performSelectorOnMainThread:@selector(xxxxxDidFinish:) withObject:self waitUntilDone:NO];
</code></pre>

<p>再说说重写main方法的坏处，它不是并发的，会阻塞主线程，所以需要加入到<code>NSOperationQueue</code>，而且它的灵活性低，在main方法返回的时候，operation就结束了。</p>

<p>2.比较推荐的是重写start方法，虽然会带来许多工作，比如KVO消息，但除了有较高的灵活性之外，它可以执行异步任务。</p>

<pre><code>- (void)start {
  @synchronized (self) {
    if ([self isCancelled])
    {
        [self willChangeValueForKey:@"isFinished"];
        self.finished = YES;
        [self didChangeValueForKey:@"isFinished"];
        return;
    }

    [self willChangeValueForKey:@"isExecuting"];
    self.executing = YES;
    [self didChangeValueForKey:@"isExecuting"];
    // your handle
    .....
  } 
}
</code></pre>

<p>然后在完成任务后（不管是fail还是finish），都需要再：</p>

<pre><code>[self willChangeValueForKey:@"isFinished"];
[self willChangeValueForKey:@"isExecuting"];

self.executing = NO;
self.finished = YES;

[self didChangeValueForKey:@"isExecuting"];
[self didChangeValueForKey:@"isFinished"];
</code></pre>

<p>处理的值，也可以通过block回调出去，所以建议有个类似这样的初始化方法：</p>

<pre><code>- (id)initWithRequest:(NSURLRequest *)request 
             progress:(DownloaderProgressBlock)progressBlock
            completed:(DownloaderCompletedBlock)completedBlock
            cancelled:(SDWebImageNoParamsBlock)cancelBlock
</code></pre>

<p>即使重写start方法的方式可以让任务异步，但还是推荐将operation加入到<code>NSOperationQueue</code>中，因为可以设置优先级，可以设置依赖等。</p>

<p>全文完～</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何在编译过程中改变app Icon]]></title>
    <link href="http://hawk0620.github.io/blog/2015/11/29/fun-with-app-icon/"/>
    <updated>2015-11-29T23:42:26+08:00</updated>
    <id>http://hawk0620.github.io/blog/2015/11/29/fun-with-app-icon</id>
    <content type="html"><![CDATA[<h3>为什么可以改变AppIcon</h3>

<p>&emsp;&emsp;为了说明为什么可以改变，首先来点题外话。相信我们都知道怎么给app换icon——把图片拖进工程的Images.xcassets->AppIcon.appiconset，很明显app icon位于<code>Project Name/Images.xcassets/AppIcon.appiconset/xxx.png</code>。当我们<code>cmd+r</code>运行工程时，会生成一个<code>/User/username/Library/Developer/.../Debug-iphoneos/Your Project Name.app</code>这样的路径，它包含了工程中所有的干货，当然app icons也在其中。</p>

<!--more-->


<p>假设你在工程中加了张名为AppIcon60x60@2x.png的icon，你可以在Build Phases点击+，再点击New Run Script，并添加如下代码：</p>

<pre><code>IFS=$'\n' #防止工程名中有空格引起的错误
echo $(find ${SRCROOT} -name "AppIcon60x60@2x.png")
echo "${BUILT_PRODUCTS_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}"
</code></pre>

<p>然后编译运行工程，你会在Xcode的<code>Report Navigator</code>（就是Xcode项目导航面板有着搜索、警告、断点那栏…）看到log出的信息。</p>

<p>&emsp;&emsp;竟然知道了icon的输入和输出路径，在编译过程中对输入来的icon进行加工，再输出到目标路径就可以对icon进行替换了。</p>

<h3>图片处理工具</h3>

<p>&emsp;&emsp;这里用到的图片加工工具是ImageMagick。你可以通过Homebrew安装：<code>brew update</code>、<code>brew install ImageMagick</code>、<code>brew install ghostscript</code>。安装成功后，打开Terminal然后cd到你含有图片的一个目录下：</p>

<pre><code>convert YourImageName.png -fill white -font Times-Bold -pointsize 18 -gravity south "Hello World" test.png
</code></pre>

<p>如果成功生成出了test.png，那么恭喜了！</p>

<h3>用Shell来搞定这一切</h3>

<p>我先贴上代码，然后再解释：</p>

<pre><code>IFS=$'\n'
buildNumber=$(/usr/libexec/PlistBuddy -c "Print CFBundleVersion" "${PROJECT_DIR}/${INFOPLIST_FILE}")
versionNumber=$(/usr/libexec/PlistBuddy -c "Print CFBundleShortVersionString" "${PROJECT_DIR}/${INFOPLIST_FILE}")
#1
PATH=${PATH}:/usr/local/bin
#2
function generateIcon () {
    BASE_IMAGE_NAME=$1

    TARGET_PATH="${BUILT_PRODUCTS_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/${BASE_IMAGE_NAME}"
    BASE_IMAGE_PATH=$(find ${SRCROOT} -name ${BASE_IMAGE_NAME})
    #3
    WIDTH=$(identify -format %w ${BASE_IMAGE_PATH})
    FONT_SIZE=$(echo "$WIDTH * .15" | bc -l)
    echo "font size $FONT_SIZE"
    #4
    if [ "${CONFIGURATION}" == "Debug" ]; then
    #5
    convert debugRibbon.png -resize ${WIDTH}x${WIDTH} resizedRibbon.png
    convert -background '#0008' -fill white -gravity center -size ${WIDTH}x40\
    -fill white -font Times-Boldr -pointsize ${FONT_SIZE} -gravity center caption:"${versionNumber}.${buildNumber}"\
    ${BASE_IMAGE_PATH} +swap -gravity south -composite /tmp/temp.png
    convert /tmp/temp.png resizedRibbon.png -composite ${TARGET_PATH}
    fi

}

#6
generateIcon "AppIcon60x60@2x.png"
generateIcon "AppIcon60x60@3x.png"
</code></pre>

<p>1、添加/user/local/bin路径到PATH变量，Homebrew也是安装在该路径下的。这样才能执行得了ImageMagick的命令；</p>

<p>2、以函数来接收不同设备的图片资源，作出分别的处理；</p>

<p>3、identify作为ImageMagick的函数来获取图片的information，使用<code>-format %w</code>的到图片的宽；</p>

<p>4、可以在Edit Scheme->Run->Info中指定CONFIGURATION；</p>

<p>5、接下去就是把debugRibbon.png缩小，将build number和version number加到图片上，最后合成并输出；</p>

<p>6、传入不同的icon文件名调用generateIcon。</p>

<p>最终效果：</p>

<p><img src="https://cloud.githubusercontent.com/assets/5633917/11458765/ae832a4c-9701-11e5-9a25-3d3a30099442.png" alt="alt tag" /></p>

<p>debugRibbon.png：</p>

<p><img src="https://cloud.githubusercontent.com/assets/5633917/11458863/c24d8a34-9703-11e5-8a9c-c301615f6dc5.png" alt="alt tag" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何在Objective-C的项目中使用Swift的第三方库]]></title>
    <link href="http://hawk0620.github.io/blog/2015/11/23/how-to-import-swift-into-objc/"/>
    <updated>2015-11-23T15:48:42+08:00</updated>
    <id>http://hawk0620.github.io/blog/2015/11/23/how-to-import-swift-into-objc</id>
    <content type="html"><![CDATA[<h3>让人惊艳的APNG</h3>

<p>&emsp;&emsp;以前只知道动图就是Gif，但是Gif有挺多缺点的，譬如有锯齿，不支持背景透明。后来知道了还有一种叫做APNG的动图格式，由于APNG是PNG的扩展，所以它支持半透明，自然就不会有锯齿的问题。要想在iOS中使用APNG动图，可以使用喵神（onevcat）用Swift开发的<a href="https://github.com/onevcat/APNGKit">APNGKit</a></p>

<!--more-->


<h3>神奇的Swift Bridging Header</h3>

<p>&emsp;&emsp;如果你的项目是Objective-C开发的（譬如像我手里的旧项目>_&lt;），其实也没有那么沮丧。接下来我将会简单说下步骤：</p>

<p>1、在Xcode中New File->Source->Header File，创建一个名为&#8221;YourProjectName-Bridging-Header.h&#8221;的头文件，注意此处一定要你的项目名称；</p>

<p>2、然后在build settings中搜索Swift Compiler，找到Objective-C Bridging Header选项，并修改它的值为你刚才创建的&#8221;ProjectName-Bridging-Header.h&#8221;；</p>

<p>3、接着再打开你的bridging header文件，并加入#import语句，譬如我使用APNGKit加入的是<code>#import "png.h"</code>；</p>

<p>4、还要在build settings中确保Product Module Name是你app target的名字，Defines Module置为YES，Embedded Content Contains Swift置为YES,Install Objective-C Compatibility Header置为YES；</p>

<p>5、虐心的事情终于结束了，最后在你想使用第三方库的.m文件中<code>#import "{YOUR\_APP\_MODULE\_NAME}-Swift.h"</code>，再#import第三方库的头文件即可。</p>

<p>PS：由于喵神的APNGKit没有提供每一帧的回调，我还下狠手修改了喵神的代码&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AutoLayout实现的动态TableView高度]]></title>
    <link href="http://hawk0620.github.io/blog/2015/11/21/daymic-tableview-height/"/>
    <updated>2015-11-21T18:15:37+08:00</updated>
    <id>http://hawk0620.github.io/blog/2015/11/21/daymic-tableview-height</id>
    <content type="html"><![CDATA[<p>本文将介绍下AutoLayout使用纯代码来实现TableView的动态高度。</p>

<p>效果图如下：
<img src="https://cloud.githubusercontent.com/assets/5633917/11318437/e0909810-908c-11e5-849b-4a40adc10c18.png" alt="dd" /></p>

<p>1、子类化一个UITableViewCell，定义三个控件：</p>

<pre><code>@property (nonatomic, strong) ZPLabel *titleLabel;
@property (nonatomic, strong) ZPLabel *subtitleLabel;
@property (nonatomic, strong) UIImageView *customImageView;
</code></pre>

<p>再在.m文件中创建这三个控件，并添加进<code>cell</code>的<code>contentView</code>中，最后为这三个控件添加约束，这里用到了<code>Masonry</code>：</p>

<!--more-->


<pre><code>// customImageView constraint
[self.customImageView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.top.equalTo(self.contentView.mas_top).with.offset(20);
    make.bottom.lessThanOrEqualTo(self.contentView.mas_bottom)
    .with.offset(-20);
        make.leading.equalTo(self.contentView.mas_leading).with
        .offset(20);
    make.width.equalTo(@100).with.priority(999);
    make.height.equalTo(@100).with.priority(999);
}];
// titleLabel constraint
[self.titleLabel mas_makeConstraints:^(MASConstraintMaker *make) {
   make.top.equalTo(self.contentView.mas_top).with.offset(20);
   make.trailing.equalTo(self.contentView.mas_trailing).with
       .offset(-20);
   make.leading.equalTo(self.customImageView.mas_trailing).with
   .offset(8);
}];
// subtitleLabel constraint
UIEdgeInsets subTitlePadding = UIEdgeInsetsMake(0, 8, -20, -20);
[self.subtitleLabel mas_makeConstraints:^(MASConstraintMaker *make) {
    make.top.equalTo(self.titleLabel.mas_bottom).with
   .offset(subTitlePadding.top);
   make.trailing.equalTo(self.contentView.mas_trailing).with
   .offset(subTitlePadding.right);
   make.bottom.lessThanOrEqualTo(self.contentView.mas_bottom).
   with.offset(subTitlePadding.bottom);
   make.leading.equalTo(self.customImageView.mas_trailing)
   .with.offset(subTitlePadding.left);
}];
</code></pre>

<p>2、在viewController中的<code>tableView:cellForRowAtIndexPath:</code>方法里对每次设置完<code>titleLabel </code>和<code>subtitleLabel</code>的text属性后都要调用<code>invalidateIntrinsicContentSize</code>来重新计算<code>label</code>的内置大小<code>intrinsicContentSize</code>：</p>

<pre><code>// cell title
NSString *title = item[@"title"];
[cell.titleLabel setText:title];
[cell.titleLabel invalidateIntrinsicContentSize];
// cell subtitle
NSString *subtitle = item[@"context"];
if (subtitle.length &gt; 200) {
   subtitle = [NSString stringWithFormat:@"%@...", [subtitle substringToIndex:200]];
}
[cell.subtitleLabel setText:subtitle];
[cell.subtitleLabel invalidateIntrinsicContentSize];
</code></pre>

<p>3、最后在<code>heightForImageCellAtIndexPath:</code>中通过重新布局和使用<code>systemLayoutSizeFittingSize:</code>计算出cell的高度：</p>

<pre><code>sizingCell.bounds = CGRectMake(0.0f, 0.0f, CGRectGetWidth(self.tableView.frame), CGRectGetHeight(sizingCell.bounds));

[sizingCell setNeedsLayout];
[sizingCell layoutIfNeeded];

CGSize size = [sizingCell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize];
return size.height + 1.0f;
</code></pre>

<p>最后附上<a href="https://github.com/hawk0620/DaymicTableDemo">源码链接</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[探索向～iOS视频播放]]></title>
    <link href="http://hawk0620.github.io/blog/2015/11/17/ios-play-video/"/>
    <updated>2015-11-17T21:50:18+08:00</updated>
    <id>http://hawk0620.github.io/blog/2015/11/17/ios-play-video</id>
    <content type="html"><![CDATA[<h4>从体验说起</h4>

<p>&emsp;&emsp;对比微信和Instagram可以发现播放视频的两个思路：微信的处理是把视频加载好后播放，这样确保了视频是完整的，用户很直观视频是否下载完成，不影响用户观看视频的体验；而Instagram的做法是边加载边播，当网络不给力的时候，视频就卡在那里，给用户增加了观看视频的焦虑，并且用户还得自己判断下视频是不是加载完成了，最不幸的是，当视频的网络请求不可达时，不能给出加载失败的提示引导用户重新加载，只能滑动列表触发刷新。</p>

<h4>播放视频的实现</h4>

<p>1、通过实践，我发现Instagram采用的应该是<code>AVPlayer</code>实现的。</p>

<!--more-->


<p><code>AVPlayerItem</code>可以通过远程URL创建出来，并且支持流的形式播放，还可以添加视频播放卡住和视频播放完成的两个观察者：</p>

<pre><code>[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(itemDidBufferPlaying:) name:AVPlayerItemPlaybackStalledNotification object:nil];
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(itemDidFinishPlaying:) name:AVPlayerItemDidPlayToEndTimeNotification object:nil];
</code></pre>

<p>但遗憾的是，我没有找到视频加载失败的观察者。</p>

<p>2、结合微信团队的技术分享<a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=207686973&amp;idx=1&amp;sn=1883a6c9fa0462dd5596b8890b6fccf6&amp;scene=0#wechat_redirect">链接</a>，得知微信的视频播放是采用<code>AVAssetReader</code>+<code>AVAssetReaderTrackOutput</code>，根据微信的思路，自己也尝试实现了一番：
buffer的转换：</p>

<pre><code>- (CGImageRef) imageFromSampleBuffer:(CMSampleBufferRef) sampleBuffer {
   CVImageBufferRef imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer);
   // Lock the base address of the pixel buffer
   CVPixelBufferLockBaseAddress(imageBuffer, 0);
   // Get the number of bytes per row for the pixel buffer
   size_t bytesPerRow = CVPixelBufferGetBytesPerRow(imageBuffer);
   // Get the pixel buffer width and height
   size_t width = CVPixelBufferGetWidth(imageBuffer);
   size_t height = CVPixelBufferGetHeight(imageBuffer);
   //Generate image to edit
   unsigned char* pixel = (unsigned char *)CVPixelBufferGetBaseAddress(imageBuffer);
   CGColorSpaceRef colorSpace=CGColorSpaceCreateDeviceRGB();
   CGContextRef context=CGBitmapContextCreate(pixel, width, height, 8, bytesPerRow, colorSpace, kCGBitmapByteOrder32Little|kCGImageAlphaPremultipliedFirst);
   CGImageRef image = CGBitmapContextCreateImage(context);
   CGContextRelease(context);
   CGColorSpaceRelease(colorSpace);
   return image;
}
</code></pre>

<p>视频的解码：</p>

<pre><code>AVURLAsset *asset = [AVURLAsset URLAssetWithURL:[[NSURL alloc] initFileURLWithPath:path] options:nil];
NSError *error;
AVAssetReader* reader = [[AVAssetReader alloc] initWithAsset:asset error:&amp;error];
NSArray* videoTracks = [asset tracksWithMediaType:AVMediaTypeVideo];
AVAssetTrack* videoTrack = [videoTracks objectAtIndex:0];

int m_pixelFormatType = kCVPixelFormatType_32BGRA;
NSDictionary* options = [NSDictionary dictionaryWithObject:[NSNumber numberWithInt: (int)m_pixelFormatType] forKey:(id)kCVPixelBufferPixelFormatTypeKey];
AVAssetReaderTrackOutput* videoReaderOutput = [[AVAssetReaderTrackOutput alloc] initWithTrack:videoTrack outputSettings:options];
[reader addOutput:videoReaderOutput];
[reader startReading];

// 读取视频每一个buffer转换成CGImageRef
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
   CMSampleBufferRef audioSampleBuffer = NULL;
   while ([reader status] == AVAssetReaderStatusReading &amp;&amp; videoTrack.nominalFrameRate &gt; 0) {
   CMSampleBufferRef sampleBuffer = [videoReaderOutput copyNextSampleBuffer];
   CGImageRef image = [self imageFromSampleBuffer:sampleBuffer];
   if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(mMovieDecoder:onNewVideoFrameReady:)]) {
        [self.delegate mMovieDecoder:self onNewVideoFrameReady:image];
    }
   if(sampleBuffer) {
       if(audioSampleBuffer) { // release old buffer.
            CFRelease(audioSampleBuffer);
            audioSampleBuffer = nil;
       }
       audioSampleBuffer = sampleBuffer;
   } else {
       break;
   }

// 休眠的间隙刚好是每一帧的间隔
   [NSThread sleepForTimeInterval:CMTimeGetSeconds(videoTrack.minFrameDuration)];
 }
 // decode finish
 float durationInSeconds = CMTimeGetSeconds(asset.duration);
  if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(mMovieDecoderOnDecodeFinished:duration:)]) {
     [self.delegate mMovieDecoderOnDecodeFinished:self duration:durationInSeconds];
   }
});
</code></pre>

<p>处理每一帧CGImageRef的回调：</p>

<pre><code>- (void)mMovieDecoder:(VideoDecoder *)decoder onNewVideoFrameReady:(CGImageRef)imgRef {
    __weak PlayBackView *weakView = self;
    dispatch_async(dispatch_get_main_queue(), ^{
        weakView.layer.contents = (__bridge id _Nullable)(imgRef);
    });
}
</code></pre>

<p>处理视频解码完成的回调：</p>

<pre><code>images即每一帧传上来的CGImageRef的数组
- (void)mMovieDecoderOnDecodeFinished:(VideoDecoder *)decoder images:(NSArray *)imgs duration:(float)duration {
    __weak PlayBackView *weakView = self;
    dispatch_async(dispatch_get_main_queue(), ^{
        weakView.layer.contents = nil;

        CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath: @"contents"];
        animation.calculationMode = kCAAnimationDiscrete;
        animation.duration = duration;
        animation.repeatCount = HUGE; //循环播放
        animation.values = images; // NSArray of CGImageRefs
        [weakView.layer addAnimation:animation forKey: @"contents"];
    });
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS拍视频前置摄像头翻转的解决]]></title>
    <link href="http://hawk0620.github.io/blog/2015/11/14/record-video-mirror/"/>
    <updated>2015-11-14T10:18:42+08:00</updated>
    <id>http://hawk0620.github.io/blog/2015/11/14/record-video-mirror</id>
    <content type="html"><![CDATA[<p>前不久在做iOS录制视频遇到了前置摄像头录制的时候视频翻转的问题，相比起以前我做拍照的翻转仅仅只需简单的把图片位置纠正：</p>

<pre><code>UIImage *newImage = [UIImage imageWithCGImage:[image CGImage] scale:1 orientation:UIImageOrientationLeftMirrored];
</code></pre>

<p>视频的翻转就比较麻烦，其大致思路是通过<code>CGAffineTransform</code>变换调整视频在屏幕中的位置，再使用<code>AVMutableVideoComposition</code>进行视频的重新组成，最后使用<code>AVAssetExportSession</code>进行视频的导出即可，以下是翻转以及裁剪出方形视频的代码：</p>

<!--more-->


<pre><code>// your own asset
AVAssetTrack *clipVideoTrack = [[asset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0];

AVMutableVideoComposition* videoComposition = [AVMutableVideoComposition videoComposition];
videoComposition.frameDuration = CMTimeMake(1, 30);

videoComposition.renderSize = CGSizeMake(clipVideoTrack.naturalSize.height, clipVideoTrack.naturalSize.height);

//create a video instruction
AVMutableVideoCompositionInstruction *instruction = [AVMutableVideoCompositionInstruction videoCompositionInstruction];
instruction.timeRange = CMTimeRangeMake(kCMTimeZero, CMTimeMakeWithSeconds(60, 30));

AVMutableVideoCompositionLayerInstruction* transformer = [AVMutableVideoCompositionLayerInstruction videoCompositionLayerInstructionWithAssetTrack:clipVideoTrack];
// 前方高能
CGAffineTransform finalTransform ＝ CGAffineTransformIdentity;
// 翻转，仅是前置摄像头需要
finalTransform = CGAffineTransformMakeScale(-1.0f, 1.0f);
// 视频竖直方向中间的位置
finalTransform = CGAffineTransformTranslate(finalTransform, clipVideoTrack.naturalSize.height, -(clipVideoTrack.naturalSize.width - clipVideoTrack.naturalSize.height) /2);
// finalTransform = CGAffineTransformTranslate(finalTransform, clipVideoTrack.naturalSize.height, 0);视频最顶部的位置
finalTransform = CGAffineTransformRotate(finalTransform, M_PI_2);
finalTransform = CGAffineTransformTranslate(finalTransform, 0.0f, clipVideoTrack.naturalSize.height);

[transformer setTransform:finalTransform atTime:kCMTimeZero];
instruction.layerInstructions = [NSArray arrayWithObject:transformer];
videoComposition.instructions = [NSArray arrayWithObject: instruction];

 // 导出
AVAssetExportSession *exporter = [[AVAssetExportSession alloc] initWithAsset:self.secondAsset presetName:AVAssetExportPresetHighestQuality] ;
exporter.videoComposition = videoComposition;
exporter.outputURL=[NSURL fileURLWithPath:outputPath];
exporter.outputFileType=AVFileTypeQuickTimeMovie;
[exporter exportAsynchronouslyWithCompletionHandler:^(void){
    // your handle with exporter.status
}];
</code></pre>

<p>补充一下，如果不是前置摄像头，如果要裁减出方形的视频只需要：</p>

<pre><code>CGAffineTransform t1 = CGAffineTransformMakeTranslation(track.naturalSize.height, -(track.naturalSize.width - track.naturalSize.height) /2 );
CGAffineTransform t2 = CGAffineTransformRotate(t1, M_PI_2);
</code></pre>

<p>如果需要拍出的视频自定义裁剪的区域，可以指定<code>cropRect</code>，代码如下：</p>

<pre><code>CGFloat cropOffX = cropRect.origin.x;
CGFloat cropOffY = cropRect.origin.y;
CGFloat cropWidth = cropRect.size.width;
CGFloat cropHeight = cropRect.size.height;
videoComposition.renderSize = CGSizeMake(cropWidth, cropHeight);
CGAffineTransform t1 = CGAffineTransformIdentity;
CGAffineTransform t2 = CGAffineTransformIdentity;
t1 = CGAffineTransformMakeTranslation(clipVideoTrack.naturalSize.height - cropOffX, 0 - cropOffY );
t2 = CGAffineTransformRotate(t1, M_PI_2 );
</code></pre>

<p>全文完～</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用CoreAnimation实现的播放按钮]]></title>
    <link href="http://hawk0620.github.io/blog/2015/11/07/player-button/"/>
    <updated>2015-11-07T19:42:48+08:00</updated>
    <id>http://hawk0620.github.io/blog/2015/11/07/player-button</id>
    <content type="html"><![CDATA[<p><img src="https://cloud.githubusercontent.com/assets/5633917/11263321/b48173c6-8ec4-11e5-8e66-5956767adc7d.gif" alt="alt tag" /></p>

<p> 最近做视频播放，需要做一个表示视频正在播放的按钮效果。记录一下实现这功能的经历。</p>

<!--more-->


<p> 首先我使用<code>CABasicAnimation</code>，在按钮的线条滑到下方终点时，通过动画完成的<code>delegate</code>方法:</p>

<pre><code>- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag
</code></pre>

<p> 让线条再到达上方的终点，并以此循环，最终实现线条一上一下的效果。但是在实际中，通过反复给<code>layer</code>添加动画，线条的速率得不到保证，最终会出现线条移动错乱的问题。</p>

<p> 在我陷入困苦之后，<code>CAKeyFrameAnimation</code>映入眼帘，我通过帧动画，把之前线条移到下方终点和上方终点的方法进行优化，帧动画的第一个位置是当前初始位置，其次是下方终点，上方终点，再是初始位置，并为每一帧动画计算了时间。通过帧动画实现了我的需求：）</p>

<p> 源码我已经放到了Github上面:
<a href="https://github.com/hawk0620/ZPPlayerButton">https://github.com/hawk0620/ZPPlayerButton</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义NavigationController转场动画]]></title>
    <link href="http://hawk0620.github.io/blog/2015/08/30/navigation-transition/"/>
    <updated>2015-08-30T08:29:21+08:00</updated>
    <id>http://hawk0620.github.io/blog/2015/08/30/navigation-transition</id>
    <content type="html"><![CDATA[<p> 这篇文章简单介绍下如何自定义UINavigationController转场动画，其大致的思路是:</p>

<!--more-->


<p> 1、实现<UINavigationControllerDelegate>协议的方法:</p>

<pre><code>- (id&lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController
                              animationControllerForOperation:(UINavigationControllerOperation)operation
                                           fromViewController:(UIViewController *)fromVC
                                             toViewController:(UIViewController *)toVC {
    if (fromVC == self &amp;&amp; [toVC isKindOfClass:[YourDestinationController class]]) {
        return [[TransitionAnimator alloc] init];
    }
    else {
        return nil;
    }
}
</code></pre>

<p>2、别忘了在viewDidAppear和viewWillDisappear方法中对delegate属性进行赋值：</p>

<pre><code>- (void)viewDidAppear:(BOOL)animated {
    [super viewDidAppear:animated];
    self.navigationController.delegate = self;
}

- (void)viewWillDisappear:(BOOL)animated {
    [super viewWillDisappear:animated];

    if (self.navigationController.delegate == self) {
        self.navigationController.delegate = nil;
    }
}
</code></pre>

<p>3、然后创建一个名为TransitionAnimator的NSObject子类，让其实现<UIViewControllerAnimatedTransitioning>协议：</p>

<pre><code>- (NSTimeInterval)transitionDuration:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext {
    return duration;
}
- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext {

}
</code></pre>

<p> 4、简单介绍下<code>animateTransition:</code>：</p>

<pre><code>// 返回当前ViewController
UIViewController *fromVC = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];
// 返回目标ViewController
UIViewController *toViewController = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];
// 返回容器视图
UIView *containerView = [transitionContext containerView];
// 返回动画时长
NSTimeInterval duration = [self transitionDuration:transitionContext];
// toViewController.view添加在containerView上
[containerView addSubview:toViewController.view];
</code></pre>

<p> 5、了解了这些基础知识之后，就可以自定义转场动画了，可以使用UIView类方法<code>animateWithDuration</code>，或者Core Animation添加动画:</p>

<pre><code>// 可以对view的alpha值，frame等属性进行
[UIView animateWithDuration:duration animations:^{

} completion:^(BOOL finished) {

    // 动画结束后别忘了告诉我们已经完成了～
    [transitionContext completeTransition:!transitionContext.transitionWasCancelled];
}];
</code></pre>

<p> 或者</p>

<pre><code>// 实现一个类似ping的转场
// -----动画开始------
UIBezierPath *circleMaskPathInitial = [UIBezierPath bezierPathWithOvalInRect:rect];
CGPoint extremePoint = CGPointMake(CGRectGetMidX(rect) - 0, CGRectGetMidY(rect) - CGRectGetHeight(toViewController.view.bounds));
CGFloat radius = sqrt((extremePoint.x*extremePoint.x) + (extremePoint.y*extremePoint.y));
UIBezierPath *circleMaskPathFinal = [UIBezierPath bezierPathWithOvalInRect:CGRectInset(rect, -radius, -radius)];

CAShapeLayer *maskLayer = [CAShapeLayer layer];
maskLayer.path = circleMaskPathFinal.CGPath;
toViewController.view.layer.mask = maskLayer;

CABasicAnimation *maskLayerAnimation = [CABasicAnimation animationWithKeyPath:@"path"];
maskLayerAnimation.fromValue = (__bridge id)(circleMaskPathInitial.CGPath);
maskLayerAnimation.toValue = (__bridge id)(circleMaskPathFinal.CGPath);
maskLayerAnimation.duration = duration;
maskLayerAnimation.delegate = self;
[maskLayer addAnimation:maskLayerAnimation forKey:@"path"];
// -----动画结束------

- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag {
    // 别忘了
    [self.transitionContext completeTransition:!transitionContext.transitionWasCancelled];
    [self.transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey].view.layer.mask = nil;
}
</code></pre>

<p> <img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/10/circle-interactive.gif" alt="" /></p>

<p> 虽然好像大致完成了自定义转场动画，但好像还是少了点什么～如果能在<code>popViewControllerAnimated</code>加上手势是不是更棒呢！</p>

<p> 先添加<code>interactivePopTransition</code>属性：</p>

<pre><code>@property (nonatomic, strong) UIPercentDrivenInteractiveTransition *interactivePopTransition;
</code></pre>

<p> 再实现<code>UINavigationControllerDelegate</code>另一个协议方法：</p>

<pre><code>- (id&lt;UIViewControllerInteractiveTransitioning&gt;)navigationController:(UINavigationController *)navigationController
                     interactionControllerForAnimationController:(id&lt;UIViewControllerAnimatedTransitioning&gt;)animationController {
    // Check if this is for our custom transition
    if ([animationController isKindOfClass:[YourCustomPopAnimator class]]) {
        return self.interactivePopTransition;
    }
    else {
        return nil;
    }
}
</code></pre>

<p>在<code>viewDidLoad</code>中添加手势：</p>

<pre><code>UIScreenEdgePanGestureRecognizer *popRecognizer = [[UIScreenEdgePanGestureRecognizer alloc] initWithTarget:self action:@selector(handlePopRecognizer:)];
popRecognizer.edges = UIRectEdgeLeft;
[self.view addGestureRecognizer:popRecognizer];
</code></pre>

<p>并实现手势方法：</p>

<pre><code>- (void)handlePopRecognizer:(UIScreenEdgePanGestureRecognizer*)recognizer {
    CGFloat progress = [recognizer translationInView:self.view].x / (self.view.bounds.size.width * 1.0);
    progress = MIN(1.0, MAX(0.0, progress));

    if (recognizer.state == UIGestureRecognizerStateBegan) {
        // Create a interactive transition and pop the view controller
        self.interactivePopTransition = [[UIPercentDrivenInteractiveTransition alloc] init];
        [self.navigationController popViewControllerAnimated:YES];
    }
    else if (recognizer.state == UIGestureRecognizerStateChanged) {
        // Update the interactive transition's progress
        [self.interactivePopTransition updateInteractiveTransition:progress];
    }
    else if (recognizer.state == UIGestureRecognizerStateEnded || recognizer.state == UIGestureRecognizerStateCancelled) {
        // Finish or cancel the interactive transition
        if (progress &gt; 0.5) {
            [self.interactivePopTransition finishInteractiveTransition];
        }
        else {
            [self.interactivePopTransition cancelInteractiveTransition];
        }

        self.interactivePopTransition = nil;
    }

}
</code></pre>

<p>最后推荐两篇更详细的教程：</p>

<p>1、<a href="http://dativestudios.com/blog/2013/09/29/interactive-transitions/">interactive-transitions</a>
2、<a href="http://www.raywenderlich.com/86521/how-to-make-a-view-controller-transition-animation-like-in-the-ping-app">实现ping转场动画</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 线程同步: @synchronized指令]]></title>
    <link href="http://hawk0620.github.io/blog/2015/06/02/ios-xian-cheng-tong-bu-at-synchronizedguan-jian-zi/"/>
    <updated>2015-06-02T07:59:59+08:00</updated>
    <id>http://hawk0620.github.io/blog/2015/06/02/ios-xian-cheng-tong-bu-at-synchronizedguan-jian-zi</id>
    <content type="html"><![CDATA[<p> 在之前的一个app中，因为对多线程同步的处理不够好，在某些极端情况下app会发生crash。本文简单介绍一下如何使用<code>@synchronized</code>指令来实现线程安全。苹果文档中对<code>@synchronized</code>指令的说明是：</p>

<p>1.<code>@synchronized</code>指令是Objective-C代码中快捷创建互斥锁的一种方式；</p>

<p>2.<code>@synchronized</code>指令像任何其他的互斥锁一样，防止同一时间不同的线程获取相同的锁。</p>

<p><code>@synchronized</code>指令的使用很简单，只需要传一个参数即可：</p>

<pre><code>@synchronized(key) { 
    // thread-safe code goes here 
}
</code></pre>

<!--more-->


<p>一个简单的例子：</p>

<p>定义一个全局的数组变量</p>

<pre><code>NSMutableArray *array;
</code></pre>

<p>初始化该数组</p>

<pre><code>array = [NSMutableArray arrayWithCapacity:5];
for (int i = 0; i &lt; 5; i++) {
    [array addObject:[NSString stringWithFormat:@"array-%i", i]];
}
</code></pre>

<p>创建更新数组的方法</p>

<pre><code>- (void)updateArray:(NSString *)value {

    for (int j = 0; j &lt; array.count; j++) {

        NSString *currentObject = [array objectAtIndex:j];
        [array replaceObjectAtIndex:j withObject:[currentObject stringByAppendingFormat:@"-%@", value]];

        NSLog(@"%@", [array objectAtIndex:j]);
    }
}
</code></pre>

<p>在不同的线程中调用修改数组的方法</p>

<pre><code>NSString *bla = @"bla";
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    [self updateArray:bla];
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    [self updateArray:bla];
}); 
</code></pre>

<p>得到如下结果</p>

<pre><code>array-0-bla
array-0-bla
array-1-bla
array-1-bla-bla
array-2-bla-bla
array-2-bla
array-3-bla
array-3-bla-bla
array-4-bla
array-4-bla-bla
</code></pre>

<p>显而易见，两个线程在争夺资源，当两个线程彼此作用时可能会导致app的crash。下面，修改一下更新数组的方法：</p>

<pre><code>- (void)updateArray:(NSString *)value {

    @synchronized (value) {
        for (int j = 0; j &lt; array.count; j++) {

            NSString *currentObject = [array objectAtIndex:j];
            [array replaceObjectAtIndex:j withObject:[currentObject stringByAppendingFormat:@"-%@", value]];

            NSLog(@"%@", [array objectAtIndex:j]);
        }
    }
}
</code></pre>

<p>看看结果：</p>

<pre><code>array-0-bla
array-1-bla
array-2-bla
array-3-bla
array-4-bla
array-0-bla-bla
array-1-bla-bla
array-2-bla-bla
array-3-bla-bla
array-4-bla-bla
</code></pre>

<p>这下感觉醒目多了～原因就是<code>@synchronized</code>指令的代码块暂停了其中一个线程，允许另一个线程访问代码块，一旦另一个线程完成工作，就取消暂停。</p>

<p>注意了，如果你使用相同的对象作为<code>@synchronized</code>的key，那么线程将会被暂停（正如刚才所见）。假如使用不同的对象作为<code>@synchronized</code>的key：</p>

<pre><code>NSString *bla = @"bla";
NSString *ola = @"ola";
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    [self updateArray:bla];
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    [self updateArray:ola];
});
</code></pre>

<p>再看看结果：</p>

<pre><code>array-0-bla
array-0-ola
array-1-bla
array-1-bla-ola
array-2-bla
array-2-bla-ola
array-3-bla
array-3-bla-ola
array-4-bla
array-4-bla-ola
</code></pre>

<p>像这种出现多个key的情况，使用</p>

<pre><code>@synchronized (array) { 
    ...
</code></pre>

<p>替换</p>

<pre><code>@synchronized (value) { 
    ...
</code></pre>

<p>这下妥妥了：</p>

<pre><code>array-0-bla
array-1-bla
array-2-bla
array-3-bla
array-4-bla
array-0-bla-ola
array-1-bla-ola
array-2-bla-ola
array-3-bla-ola
array-4-bla-ola
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GCD(semaphore)的日常]]></title>
    <link href="http://hawk0620.github.io/blog/2014/09/20/dispatch-semaphore/"/>
    <updated>2014-09-20T19:36:00+08:00</updated>
    <id>http://hawk0620.github.io/blog/2014/09/20/dispatch-semaphore</id>
    <content type="html"><![CDATA[<p> 当代码块在执行一些特定操作时，比如异步处理，有时需要等待代码块是否执行完成，这时可以通过<code>GCD</code>来帮助我们实现。</p>

<!--more-->


<h3>dispatch_semaphore简介</h3>

<p> <code>dispatch_semaphore_create</code>创建一个带初始值的semaphore；</p>

<p> <code>dispatch_semaphore_signal</code>增加semaphore的计数，并发送semaphore信号；</p>

<p> <code>dispatch_semaphore_wait</code>减少semaphore的计数，并等待semaphore信号的到达。</p>

<p> 示例代码：</p>

<pre><code>dispatch_semaphore_t sem = dispatch_semaphore_create(0);

[self singleBlock:^(id param){
    // your codes...
    dispatch_semaphore_signal(sem);
}];

dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSURLSession的日常]]></title>
    <link href="http://hawk0620.github.io/blog/2014/07/27/daily-nsurlsession/"/>
    <updated>2014-07-27T13:42:05+08:00</updated>
    <id>http://hawk0620.github.io/blog/2014/07/27/daily-nsurlsession</id>
    <content type="html"><![CDATA[<p> 在使用<code>NSURLSessionTaskDelegate</code>的时候，一开始并没有进入<code>URLSession:task:didCompleteWithError:</code>回调，阅读苹果给出的文档之后，成功解决。</p>

<!--more-->


<h3>NSURLSession简介</h3>

<p> <code>NSURLSession</code>是iOS7带来的诸多新特性之一，旨在替换<code>NSURLConnection</code>。<code>NSURLSession</code>的使用非常简单，步骤如下：</p>

<p> 1.创建并配置<code>NSURLSessionConfiguration</code>;</p>

<p> 2.通过步骤一的configuration创建<code>NSURLSession</code>;</p>

<p> 3.创建相应sessionTask(data、upload or download);</p>

<p> 4.调用<code>resume</code>启动task。</p>

<p> 给出一些例子代码：</p>

<pre><code>NSData *imageData = UIImageJPEGRepresentation([UIImage imageNamed:@"panda.jpg"], 0.6);

NSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration];
config.HTTPMaximumConnectionsPerHost = 1;
 [config setHTTPAdditionalHeaders:@{@"example_appkey": @"jfdeh79685eun"}];

NSURLSession *upLoadSession = [NSURLSession sessionWithConfiguration:config];
NSURL *url = [NSURL URLWithString:@"http://example.com"];
NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url];
[request setHTTPMethod:@"PUT"];

NSURLSessionUploadTask *uploadTask = [upLoadSession uploadTaskWithRequest:request fromData:imageData completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
    NSHTTPURLResponse *httpResp = (NSHTTPURLResponse*) response;
    if (!error  &amp;&amp; httpResp.statusCode == 200) {
        //handle...
    }
}];

[[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:YES];
[_uploadTask resume];
</code></pre>

<h2>使用NSURLSessionTaskDelegate</h2>

<p> 修改创建uploadSession方法：</p>

<pre><code>NSURLSession *upLoadSession = [NSURLSession sessionWithConfiguration:config delegate:self delegateQueue:nil];
</code></pre>

<p> 实现<code>&lt;NSURLSessionTaskDelegate&gt;</code>，该委托提供出了能计算上传进度的方法，代码如下：</p>

<pre><code>- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSent totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend
{
    NSLog(@"progress:%f",(double)totalBytesSent / (double)totalBytesExpectedToSend);
}
</code></pre>

<p> 将创建uploadTask方法更改为:</p>

<pre><code>NSURLSessionUploadTask *uploadTask = [upLoadSession uploadTaskWithRequest:request fromData:imageData];
</code></pre>

<p> 当然还有sessionTask完成时的回调：</p>

<pre><code>- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error
{
    dispatch_async(dispatch_get_main_queue(), ^{
        [[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:NO];
    });
    if (!error) {
        //handle..
    } else {
        // Alert for error
    }
}
</code></pre>

<p> 但是该委托方法没有被调用。苹果文档指出，如果使用自定义的委托来获取数据，那么以下方法必须被实现：</p>

<p> <code>URLSession:dataTask:didReceiveData:</code> 一点一点地从你发出地请求中取回数据；
 <code>URLSession:task:didCompleteWithError:</code> 数据被完全接收。</p>

<p> 由此可以看出，还需要实现<code>&lt;NSURLSessionDataDelegate&gt;</code>：</p>

<pre><code>-(void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data
{

}
</code></pre>

<p> 至此，成功进入<code>URLSession:task:didCompleteWithError:</code>。</p>
]]></content>
  </entry>
  
</feed>
