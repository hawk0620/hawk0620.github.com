<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Hawk 's blog]]></title>
  <link href="http://hawk0620.github.io/atom.xml" rel="self"/>
  <link href="http://hawk0620.github.io/"/>
  <updated>2018-05-30T21:37:05+08:00</updated>
  <id>http://hawk0620.github.io/</id>
  <author>
    <name><![CDATA[Hawk0620]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[理解数据库索引]]></title>
    <link href="http://hawk0620.github.io/blog/2018/05/29/understand-index/"/>
    <updated>2018-05-29T20:22:25+08:00</updated>
    <id>http://hawk0620.github.io/blog/2018/05/29/understand-index</id>
    <content type="html"><![CDATA[<p>在日常开发中，数据库降低了我们操作数据的门槛，我们只要编写特定的 SQL，就能对数据做增删改查操作。在简化的背后，往往都隐藏着性能优化的福利，数据库也是如此，我们知道假如没有索引，查询数据就会全表扫描，而索引就如书的目录一般，大大提高了查询效率。本文将对数据库索引进行介绍，认识索引的数据结构，同时也介绍索引的其他概念。</p>

<!--more-->


<h2>索引的数据结构</h2>

<p>索引在本质上是为了优化查找的速度，对于给定的数据，我们可以使用顺序查找，如果数据已经排好序，我们可以使用二分查找，如果查找的数据量不大，我们可以构造二叉查找树将查找放在内存中，而索引的数据结构是由平衡二叉树演化而来，在正式介绍索引的数据结构之前，让我们先来看看二叉查找树。</p>

<h3>二叉查找树</h3>

<p>二叉查找树要求左子树的键值总是小于根的键值，右子树的键值总是大于根的键值。</p>

<p><img src="https://user-images.githubusercontent.com/5633917/40524676-690b3df0-600e-11e8-9b95-fc14ca3874d0.jpg" alt="1527218750414" /></p>

<p><img src="https://user-images.githubusercontent.com/5633917/40524320-918f2bf8-600c-11e8-8c84-a2b44ae5da8b.jpg" alt="1527217930423" /></p>

<p>二叉查找树的问题是假如单支过长就会大大影响其查找效率，甚至退化成顺序查找</p>

<p><img src="https://user-images.githubusercontent.com/5633917/40524536-994d0d46-600d-11e8-9b6b-0bc62971d58c.jpg" alt="1527218408243" /></p>

<p>为了提高二叉树的查找效率，需要构造的这棵二叉树是平衡的——平衡二叉树要求任何结点的两个子树的高度最大差为1。平衡二叉树通常需要左旋、右旋来达到平衡。</p>

<p><img src="https://user-images.githubusercontent.com/5633917/40524836-711c70ee-600f-11e8-957e-e55fc7ce9ec0.jpg" alt="1527219158761" /></p>

<h3>B* 树</h3>

<h4>B- 树</h4>

<p>我们先来看看对 B 树的描述：</p>

<ul>
<li>B 树的 B 不是表示二叉，而是表示平衡</li>
<li>B 树并不是一颗二叉树，B 树是 n 叉的（n > 2）</li>
<li>每个结点有多个关键字，关键字之间又有指向孩子结点的指针</li>
<li>一个结点内的关键字都有序排列</li>
<li>所有叶子结点都在同一层</li>
</ul>


<p><img src="https://user-images.githubusercontent.com/5633917/40534616-2eb9a6ca-6039-11e8-9825-0b2a368046d9.jpg" alt="1527237093708" /></p>

<p>对于查找而言，B 树的查找类似二叉树，因为每个结点内的关键字都是排序好的 key[1&hellip;n]，我们可运用二分查找将查找关键字 k 与 key[i] 比较，从而找出相应区间的子树。</p>

<p>B 树查找的简化代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">Result</span> <span class="nf">BTreeSearch</span><span class="p">(</span><span class="n">BTNode</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">KeyType</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">BTNode</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// q 指向 p 的双亲</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">found</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">i</span> <span class="o">=</span> <span class="n">BinarySearch</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
</span><span class='line'>            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上述代码也可以使用递归。有了这些基本的认识后，不难发现 B 树的查找效率与树的高度有关，高度越小，查找的次数就越少。</p>

<p>接下来看看 B 树的插入和删除。
对插入而言，如果该结点还有空位置，直接插入，否则，会将结点分成两部分，中间位置的关键字插入到父结点中，如果父结点也不满足，再往上插，直到这个过程传到根结点。</p>

<p><img src="https://user-images.githubusercontent.com/5633917/40534843-e6d25d24-6039-11e8-8ad3-7dc8825f3a51.jpg" alt="1527237417928" /></p>

<p>插入15</p>

<p>删除比插入稍微复杂一点，如果删除一个关键字后，结点的关键字个数没有少于它的装填因子，则直接删除</p>

<p><img src="https://user-images.githubusercontent.com/5633917/40535168-effe9d9e-603a-11e8-9227-967f49c13d56.jpg" alt="1527237872376" /></p>

<p>删除8，16</p>

<p>否则分两种情况：</p>

<ul>
<li>如果左（右）兄弟结点的关键字个数大于装填因子，则将左（右）结点最大或最小关键字上移到父结点，再把父结点中大于或小于上移关键字的关键字下移到要被删除的结点中。</li>
</ul>


<p><img src="https://user-images.githubusercontent.com/5633917/40646654-663aaaf6-635c-11e8-8ec9-af89bc8727cd.jpg" alt="1527582084766" /></p>

<p>删除15</p>

<ul>
<li>如果左（右）兄弟结点的关键字个数等于装填因子，这时需要把删除关键字的结点与左（右）结点关键字和分割二者关键字的双亲结点关键字合并成一个结点，如果因此使双亲结点关键字个数小于装填因子，则对双亲结点也做同样处理，以致可能使整棵树的高度减少一层。</li>
</ul>


<p><img src="https://user-images.githubusercontent.com/5633917/40535534-f8a9475e-603b-11e8-8577-54b1eccfe6a4.jpg" alt="1527238316921" /></p>

<p>删除4后的结果</p>

<p>由上可知，B 树的插入和删除都是需要代价的，所以我们对数据库索引的建立也需要特别谨慎，否则不合理的索引反而降低了效率。</p>

<h4>B+ 树</h4>

<p>B+ 树是 B- 树的变形，常用于索引结构中，它与 B- 树的主要差异有：</p>

<ul>
<li>B+ 树中所有叶子结点包含了全部关键字，即非叶子结点的关键字也出现在叶子结点中</li>
<li>叶子结点的指针不再指向另一级索引，而是直接指向数据文件的记录</li>
<li>分支结点不包含关键字对应的存储地址，只包含指向各个子结点的指针</li>
<li>所有叶子结点链接成一个线性链表</li>
</ul>


<p><img src="https://user-images.githubusercontent.com/5633917/40647474-84e7313e-635e-11e8-9353-4580813a539b.jpg" alt="1527582980853" /></p>

<p>B 树和平衡二叉树的一个重要区别是结点的大小及其造成的树的高度不同，B+ 树的结点大小一般是一个磁盘块的大小，也就是数据页的大小，因此 B 树矮而胖，二叉树高而瘦。前面已经提到 B 树的查找效率和其高度有关，假设当前数据表的数据为 N，每个磁盘块的数据项的数量是 m，则有 h = ㏒(m+1)N，而 m = 磁盘块的大小 / 数据项的大小，磁盘块的大小又是固定的，故数据项的大小越小，树的高度也就越小。这就是为什么要求索引字段尽可能小的原因。同理，将数据不存储在分支结点，也是为了尽可能多的存放数据项。</p>

<h2>B+ 树索引</h2>

<p>B+ 树索引就是 B+ 树在数据库中的实现。B+ 索引在数据库中有一个特点是高扇出性，因此在数据库中，B+ 树的高度一般都在2～4层，这也就是说查找某一键值的行记录时最多只需要2到4次 IO。</p>

<p>B+ 树索引并不能找到一个给定键值的具体行。B+树索引能找到的只是被查找数据行所在的页。然后数据库通过把页读入到内存，再在内存中进行查找，最后得到要查找的数据。</p>

<h3>聚集索引和辅助索引</h3>

<p>B+ 树索引可分为聚集索引和辅助索引（secondary index），它们的主要区别是聚集索引要求以唯一的 key（一般是主键）来构造索引，文件中记录的物理存储顺序和索引顺序一致，由于实际的数据页只能按照一棵 B+ 树进行排序，因此每张表只能拥有一个聚集索引，辅助索引的 key 可以不是唯一的，辅助索引能提高聚集索引以外 key 的查找性能，这也会增加一定的开销。</p>

<p>下面表有三个列，分别是 id（主键）、name 和 salary，我们来看看聚集索引和辅助索引的原理：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/40635134-245f48c0-632b-11e8-9ff7-40612778be09.jpg" alt="1527560106240" /></p>

<p>以上是聚集索引</p>

<p><img src="https://user-images.githubusercontent.com/5633917/40635179-5a58fb60-632b-11e8-8b25-090e06820808.jpg" alt="1527560883816" /></p>

<p>以上是辅助索引</p>

<h3>联合索引</h3>

<p>我们已经介绍过了在单个列上使用索引，联合索引是指对表上的多个列进行索引，联合索引的本质也是一棵 B+ 树，下面看看联合索引的内部结构：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/40536633-6a475164-603f-11e8-830a-24bd0b69d702.png" alt="dff64b61-998e-47be-910d-02b596227f71" /></p>

<p>对上图而言，（1，1）、（1，2）、（2，1）、（2，4）、（3，1）、（3，2），数据按（a，b）的顺序进行了存放，第一列是升序排序的，第二列是根据第一列排序而排序的。</p>

<p>因此，对于查询 <code>SELECT*FROM TABLE WHERE a=xxx and b=xxx</code>，显然是可以使用（a，b）这个联合索引的。对于单个的a列查询 <code>SELECT*FROM TABLE WHERE a=xxx</code>，也可以使用这个（a，b）索引。但对于b列的查询 <code>SELECT*FROM TABLE WHERE b=xxx</code>，则不可以使用这棵B+树索引。可以发现叶子节点上的b值为1、2、1、4、1、2，显然不是排序的，因此对于b列的查询使用不到（a，b）的索引。</p>

<p>联合索引能在索引到第一个键值后对第二个键值进行排序。例如，查询某个用户的购物情况，并按照时间进行排序，最后取出最近三次的购买记录，这时使用联合索引可以避免多一次的排序操作，因为索引到某个用户 id 后，购买记录已经是有序的了。</p>

<p>正如前面所介绍的那样，联合索引（a，b）其实是根据列a、b进行排序，因此语句 <code>SELECT...FROM TABLE WHERE a=xxx ORDER BY b</code> 可以直接使用联合索引得到结果。</p>

<p>然而对于联合索引（a，b，c）来说，语句 <code>SELECT...FROM TABLE WHERE a=xxx AND b=xxx ORDER BY c</code> 或 <code>SELECT...FROM TABLE WHERE a=xxx ORDER BY b</code> 同样可以直接通过联合索引得到结果。</p>

<p>但对于语句 <code>SELECT...FROM TABLE WHERE a=xxx ORDER BY c</code>，联合索引不能直接得到结果，因为 c 是用不到索引的。</p>

<p>这就是索引最左前缀匹配的特性。根据该原则，我们建立联合索引时要考虑好查询尽可能地用得上索引，这也要求我们尽可能选择区分度高的列作为索引。</p>

<h3>小结</h3>

<ul>
<li>在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构。</li>
<li>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度。</li>
<li>在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的。</li>
<li>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li>
<li>在经常使用在where子句中的列上面创建索引，加快条件的判断速度。</li>
</ul>


<h2>哈希索引和位图索引</h2>

<p>最后再简单介绍下另外两种索引结构</p>

<h3>哈希索引</h3>

<p>哈希索引通过哈希算法来实现查找，其冲突解决采用链地址法，我们知道哈希算法的时间复杂度为 O(1)，所以哈希索引是非常高效的。</p>

<p>因为哈希索引的记录不以任何特定方式排序，这也导致哈希索引无法应用在范围查找中。</p>

<h3>位图索引</h3>

<p>位图索引（bitmap index）是为多个列查询设计的特殊索引，位图索引适合用于列上的值大量重复出现。</p>

<p>表结构：</p>

<table>
<thead>
<tr>
<th>ID </th>
<th> gender </th>
<th> income_level</th>
</tr>
</thead>
<tbody>
<tr>
<td>43123 </td>
<td> m </td>
<td> L1</td>
</tr>
<tr>
<td>65654 </td>
<td> f </td>
<td> L2</td>
</tr>
<tr>
<td>76534 </td>
<td> f </td>
<td> L1</td>
</tr>
<tr>
<td>12343 </td>
<td> m </td>
<td> L4</td>
</tr>
<tr>
<td>65765 </td>
<td> f </td>
<td> L3</td>
</tr>
</tbody>
</table>


<p>gender 的位图：</p>

<table>
<thead>
<tr>
<th></th>
<th>  </th>
<th>  </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> m </td>
<td> 10010 |</td>
</tr>
<tr>
<td></td>
<td> f </td>
<td> 01101 |</td>
</tr>
</tbody>
</table>


<p>income_level 的位图：</p>

<table>
<thead>
<tr>
<th></th>
<th>  </th>
<th>  </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> L1 </td>
<td> 10100 |</td>
</tr>
<tr>
<td></td>
<td> L2 </td>
<td> 01000 |</td>
</tr>
<tr>
<td></td>
<td> L3 </td>
<td> 00001 |</td>
</tr>
<tr>
<td></td>
<td> L4 </td>
<td> 00010 |</td>
</tr>
<tr>
<td></td>
<td> L5 </td>
<td> 00000 |</td>
</tr>
</tbody>
</table>


<p>上述表对于只以性别为条件的查询，位图索引并不能带来什么性能的提升。然而对查询 <code>Select * from t where gender = 'f' and income_level = 'L3'</code>，位图索引会执行两个位图的交操作（逻辑与）。即 gender 的位图 = f(01101) 和 income_level 的位图 = L2(01000) 的交得到位图 01000。显然对于多个列上大量重复数据项的查询，位图索引可以提高查找效率。此外，位图索引还有体积小的优点。</p>

<h2>总结</h2>

<p>本文是我学习数据库索引的笔记，仅仅介绍了数据库的几种索引的原理，并没有深入到更加底层的研究，只能对日常开发中如何建立索引、选择索引起到一定的指示作用，而对于查询性能的优化还是需要从大量的实践中总结出经验。</p>

<h4>参考文章</h4>

<p><a href="https://tech.meituan.com/mysql-index.html">MySQL索引原理及慢查询优化</a></p>

<p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL索引背后的数据结构及算法原理</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RunLoop 源码学习笔记]]></title>
    <link href="http://hawk0620.github.io/blog/2018/04/14/runloop-study-note/"/>
    <updated>2018-04-14T15:54:22+08:00</updated>
    <id>http://hawk0620.github.io/blog/2018/04/14/runloop-study-note</id>
    <content type="html"><![CDATA[<p>RunLoop 是个老生常谈的话题了，一直以来对 RunLoop 的认识还停留在 <a href="https://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a>（ YY 大神） 等业内好文当中，对于自个来说仍有些知识盲区：</p>

<ul>
<li>网上有文章用伪代码提到 <code>CheckIfExistMessagesInMainDispatchQueue();</code> ，代码看似提供了一次执行 main queue 的机会，为什么有这样的设计？</li>
<li>怎么理解在 kCFRunLoopBeforeSources 和 kCFRunLoopAfterWaiting 之间来检测是否卡顿？</li>
<li>我们能在代码中看到 <code>USE_DISPATCH_SOURCE_FOR_TIMERS</code> 这样的宏，到底 GCD 的 timer 与 RunLoop 有关吗？</li>
<li>能让 RunLoop 退出的几种方式</li>
</ul>


<!--more-->


<p>为了搞懂自己没理解清楚的问题，我下载了苹果开源的 CoreFoudation 来一窥究竟（ <a href="https://github.com/apple/swift-corelibs-foundation/">https://github.com/apple/swift-corelibs-foundation/</a>）。</p>

<h3>主函数 __CFRunLoopRun</h3>

<p>RunLoop 的事件循环机制主要由 <code>__CFRunLoopRun</code> 函数实现，其代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="kt">int32_t</span> <span class="nf">__CFRunLoopRun</span><span class="p">(</span><span class="n">CFRunLoopRef</span> <span class="n">rl</span><span class="p">,</span> <span class="n">CFRunLoopModeRef</span> <span class="n">rlm</span><span class="p">,</span> <span class="n">CFTimeInterval</span> <span class="n">seconds</span><span class="p">,</span> <span class="n">Boolean</span> <span class="n">stopAfterHandle</span><span class="p">,</span> <span class="n">CFRunLoopModeRef</span> <span class="n">previousMode</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#if __HAS_DISPATCH__</span>
</span><span class='line'>    <span class="c1">// 获取主线程消息端口，用于 main queue 事件的派发</span>
</span><span class='line'>    <span class="n">__CFPort</span> <span class="n">dispatchPort</span> <span class="o">=</span> <span class="n">CFPORT_NULL</span><span class="p">;</span>
</span><span class='line'>    <span class="n">Boolean</span> <span class="n">libdispatchQSafe</span> <span class="o">=</span> <span class="n">pthread_main_np</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY</span> <span class="o">&amp;&amp;</span> <span class="nb">NULL</span> <span class="o">==</span> <span class="n">previousMode</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span> <span class="o">==</span> <span class="n">_CFGetTSD</span><span class="p">(</span><span class="n">__CFTSDKeyIsInGCDMainQ</span><span class="p">)));</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">libdispatchQSafe</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">CFRunLoopGetMain</span><span class="p">()</span> <span class="o">==</span> <span class="n">rl</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">CFSetContainsValue</span><span class="p">(</span><span class="n">rl</span><span class="o">-&gt;</span><span class="n">_commonModes</span><span class="p">,</span> <span class="n">rlm</span><span class="o">-&gt;</span><span class="n">_name</span><span class="p">))</span>
</span><span class='line'>      <span class="c1">// 还需检查当前 RunLoopMode 是否在 _commonModes 的set集合中</span>
</span><span class='line'>      <span class="n">dispatchPort</span> <span class="o">=</span> <span class="n">_dispatch_get_main_queue_port_4CF</span><span class="p">();</span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span>
</span><span class='line'>    <span class="c1">// 初始 GCD timer</span>
</span><span class='line'>    <span class="kt">mach_port_name_t</span> <span class="n">modeQueuePort</span> <span class="o">=</span> <span class="n">MACH_PORT_NULL</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">rlm</span><span class="o">-&gt;</span><span class="n">_queue</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">modeQueuePort</span> <span class="o">=</span> <span class="n">_dispatch_runloop_root_queue_get_port_4CF</span><span class="p">(</span><span class="n">rlm</span><span class="o">-&gt;</span><span class="n">_queue</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">modeQueuePort</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">CRASH</span><span class="p">(</span><span class="s">&quot;Unable to get port for run loop mode queue (%d)&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 设置超时，即 - runUntilDate: 设置的参数，- run 方法的超时时间是无限大</span>
</span><span class='line'><span class="cp">#if __HAS_DISPATCH__</span>
</span><span class='line'>    <span class="kt">dispatch_source_t</span> <span class="n">timeout_timer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">__timeout_context</span> <span class="o">*</span><span class="n">timeout_context</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">__timeout_context</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">timeout_context</span><span class="p">));</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">seconds</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// instant timeout</span>
</span><span class='line'>        <span class="n">seconds</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span><span class='line'>        <span class="n">timeout_context</span><span class="o">-&gt;</span><span class="n">termTSR</span> <span class="o">=</span> <span class="mi">0ULL</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">seconds</span> <span class="o">&lt;=</span> <span class="n">TIMER_INTERVAL_LIMIT</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'><span class="cp">#if __HAS_DISPATCH__</span>
</span><span class='line'>  <span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">pthread_main_np</span><span class="p">()</span> <span class="o">?</span> <span class="n">__CFDispatchQueueGetGenericMatchingMain</span><span class="p">()</span> <span class="o">:</span> <span class="n">__CFDispatchQueueGetGenericBackground</span><span class="p">();</span>
</span><span class='line'>  <span class="n">timeout_timer</span> <span class="o">=</span> <span class="n">dispatch_source_create</span><span class="p">(</span><span class="n">DISPATCH_SOURCE_TYPE_TIMER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
</span><span class='line'>        <span class="n">dispatch_retain</span><span class="p">(</span><span class="n">timeout_timer</span><span class="p">);</span>
</span><span class='line'>  <span class="n">timeout_context</span><span class="o">-&gt;</span><span class="n">ds</span> <span class="o">=</span> <span class="n">timeout_timer</span><span class="p">;</span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'>  <span class="n">timeout_context</span><span class="o">-&gt;</span><span class="n">rl</span> <span class="o">=</span> <span class="p">(</span><span class="n">CFRunLoopRef</span><span class="p">)</span><span class="n">CFRetain</span><span class="p">(</span><span class="n">rl</span><span class="p">);</span>
</span><span class='line'>  <span class="n">timeout_context</span><span class="o">-&gt;</span><span class="n">termTSR</span> <span class="o">=</span> <span class="n">startTSR</span> <span class="o">+</span> <span class="n">__CFTimeIntervalToTSR</span><span class="p">(</span><span class="n">seconds</span><span class="p">);</span>
</span><span class='line'><span class="cp">#if __HAS_DISPATCH__</span>
</span><span class='line'>  <span class="n">dispatch_set_context</span><span class="p">(</span><span class="n">timeout_timer</span><span class="p">,</span> <span class="n">timeout_context</span><span class="p">);</span> <span class="c1">// source gets ownership of context</span>
</span><span class='line'>  <span class="n">dispatch_source_set_event_handler_f</span><span class="p">(</span><span class="n">timeout_timer</span><span class="p">,</span> <span class="n">__CFRunLoopTimeout</span><span class="p">);</span>
</span><span class='line'>        <span class="n">dispatch_source_set_cancel_handler_f</span><span class="p">(</span><span class="n">timeout_timer</span><span class="p">,</span> <span class="n">__CFRunLoopTimeoutCancel</span><span class="p">);</span>
</span><span class='line'>        <span class="kt">uint64_t</span> <span class="n">ns_at</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)((</span><span class="n">__CFTSRToTimeInterval</span><span class="p">(</span><span class="n">startTSR</span><span class="p">)</span> <span class="o">+</span> <span class="n">seconds</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000000000ULL</span><span class="p">);</span>
</span><span class='line'>        <span class="n">dispatch_source_set_timer</span><span class="p">(</span><span class="n">timeout_timer</span><span class="p">,</span> <span class="n">dispatch_time</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ns_at</span><span class="p">),</span> <span class="n">DISPATCH_TIME_FOREVER</span><span class="p">,</span> <span class="mi">1000ULL</span><span class="p">);</span>
</span><span class='line'>        <span class="n">dispatch_resume</span><span class="p">(</span><span class="n">timeout_timer</span><span class="p">);</span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// infinite timeout</span>
</span><span class='line'>        <span class="n">seconds</span> <span class="o">=</span> <span class="mf">9999999999.0</span><span class="p">;</span>
</span><span class='line'>        <span class="n">timeout_context</span><span class="o">-&gt;</span><span class="n">termTSR</span> <span class="o">=</span> <span class="n">UINT64_MAX</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>再往下就是 RunLoop 的主体 do-while 代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">do</span> <span class="p">{</span>
</span><span class='line'>      <span class="kt">voucher_mach_msg_state_t</span> <span class="n">voucherState</span> <span class="o">=</span> <span class="n">VOUCHER_MACH_MSG_STATE_UNCHANGED</span><span class="p">;</span>
</span><span class='line'>      <span class="kt">voucher_t</span> <span class="n">voucherCopy</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>      <span class="kt">uint8_t</span> <span class="n">msg_buffer</span><span class="p">[</span><span class="mi">3</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>      <span class="kt">mach_msg_header_t</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>      <span class="kt">mach_port_t</span> <span class="n">livePort</span> <span class="o">=</span> <span class="n">MACH_PORT_NULL</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">__CFPortSet</span> <span class="n">waitSet</span> <span class="o">=</span> <span class="n">rlm</span><span class="o">-&gt;</span><span class="n">_portSet</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">__CFRunLoopUnsetIgnoreWakeUps</span><span class="p">(</span><span class="n">rl</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1">// observer 收到 beforeTimers 的通知，RunLoop 即将处理 timer</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">rlm</span><span class="o">-&gt;</span><span class="n">_observerMask</span> <span class="o">&amp;</span> <span class="n">kCFRunLoopBeforeTimers</span><span class="p">)</span> <span class="n">__CFRunLoopDoObservers</span><span class="p">(</span><span class="n">rl</span><span class="p">,</span> <span class="n">rlm</span><span class="p">,</span> <span class="n">kCFRunLoopBeforeTimers</span><span class="p">);</span>
</span><span class='line'>      <span class="c1">// observer 收到 beforeSources 的通知，RunLoop 即将处理 source0 事件</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">rlm</span><span class="o">-&gt;</span><span class="n">_observerMask</span> <span class="o">&amp;</span> <span class="n">kCFRunLoopBeforeSources</span><span class="p">)</span> <span class="n">__CFRunLoopDoObservers</span><span class="p">(</span><span class="n">rl</span><span class="p">,</span> <span class="n">rlm</span><span class="p">,</span> <span class="n">kCFRunLoopBeforeSources</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1">// RunLoop 执行 block</span>
</span><span class='line'>      <span class="n">__CFRunLoopDoBlocks</span><span class="p">(</span><span class="n">rl</span><span class="p">,</span> <span class="n">rlm</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1">// RunLoop 处理 source0 事件</span>
</span><span class='line'>      <span class="n">Boolean</span> <span class="n">sourceHandledThisLoop</span> <span class="o">=</span> <span class="n">__CFRunLoopDoSources0</span><span class="p">(</span><span class="n">rl</span><span class="p">,</span> <span class="n">rlm</span><span class="p">,</span> <span class="n">stopAfterHandle</span><span class="p">);</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">sourceHandledThisLoop</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="c1">// RunLoop 执行 block</span>
</span><span class='line'>          <span class="n">__CFRunLoopDoBlocks</span><span class="p">(</span><span class="n">rl</span><span class="p">,</span> <span class="n">rlm</span><span class="p">);</span>
</span><span class='line'>     <span class="p">}</span>
</span><span class='line'>  
</span><span class='line'>      <span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>source0 事件可以是 UIEvent，如用户点击按钮</p>

<p><img src="https://user-images.githubusercontent.com/5633917/38467502-048498ac-3b6c-11e8-90fe-e0b620300f65.png" alt="source0-image" /></p>

<p>__CFRunLoopDoBlocks 可以是执行 block 或调用 performSelector 方法。</p>

<h3>CheckIfExistMessagesInMainDispatchQueue() 实现分析</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#if __HAS_DISPATCH__</span>
</span><span class='line'>        <span class="c1">// 使用 didDispatchPortLastTime 变量配合检查有没有 main queue 需要执行的</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">MACH_PORT_NULL</span> <span class="o">!=</span> <span class="n">dispatchPort</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">didDispatchPortLastTime</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">mach_msg_header_t</span> <span class="o">*</span><span class="p">)</span><span class="n">msg_buffer</span><span class="p">;</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">__CFRunLoopServiceMachPort</span><span class="p">(</span><span class="n">dispatchPort</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msg_buffer</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">livePort</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">voucherState</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">goto</span> <span class="n">handle_msg</span><span class="p">;</span> <span class="c1">// 执行 main queue 并将 didDispatchPortLastTime 设为 true</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">didDispatchPortLastTime</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面代码是 main queue 可能被本次 RunLoop 执行的一个机会，可以看到 if 语句里还加入了 didDispatchPortLastTime 这个变量，该变量作用很像是获取上次 RunLoop 有没有执行过 main queue 的标志，假如 <code>handle_msg</code> 执行了 main queue， didDispatchPortLastTime 会被设为 true，这样在下次 RunLoop ，!didDispatchPortLastTime 为 false，不会直接跳转执行 <code>handle_msg</code>。</p>

<p>但假如 <code>handle_msg</code> 执行了其他的分支（比如 timer），那么本次 RunLoop 将不再执行 main queue 了（即便有），来到下次 RunLoop 时，由于!didDispatchPortLastTime 为 true，如果有 main queue 的代码要执行，就会直接跳转到 <code>handle_msg</code> 处理 main queue，略过 RunLoop 休眠等代码。</p>

<p>为此我通过简单的代码配合 CoreFoundation 源码来验证。</p>

<p><img src="https://user-images.githubusercontent.com/5633917/38560281-de4cdd46-3d07-11e8-841f-4187b3674130.jpg" alt="161523259381_ pic" /></p>

<p>我在 timer 的回调里添加了执行 main queue 的方法，这么做的原因是想模拟下本次 RunLoop 没有执行 main queue 的情况。运行代码，timer 的回调执行完之后就进入到下一个 RunLoop 了，接着和预期的一致，来到了 <code>goto handle_msg;</code> 直接跳转去执行 main queue。</p>

<p><img src="https://user-images.githubusercontent.com/5633917/38560508-60a2939e-3d08-11e8-85a9-8b33deca79e1.jpg" alt="151523259187_ pic" /></p>

<p>对于第一个疑惑，可以看出系统之所以这么做是为了确保加进来的 main queue 能获得快速执行和跳过界面更新和休眠提升效率。</p>

<h3>利用 RunLoop 实现卡顿检测的原因</h3>

<p>接下来 RunLoop 准备休眠</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// 通知 RunLoop 的线程即将进入休眠</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">poll</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rlm</span><span class="o">-&gt;</span><span class="n">_observerMask</span> <span class="o">&amp;</span> <span class="n">kCFRunLoopBeforeWaiting</span><span class="p">))</span> <span class="n">__CFRunLoopDoObservers</span><span class="p">(</span><span class="n">rl</span><span class="p">,</span> <span class="n">rlm</span><span class="p">,</span> <span class="n">kCFRunLoopBeforeWaiting</span><span class="p">);</span>
</span><span class='line'>  <span class="n">__CFRunLoopSetSleeping</span><span class="p">(</span><span class="n">rl</span><span class="p">);</span>
</span><span class='line'>  <span class="c1">// do not do any user callouts after this point (after notifying of sleeping)</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Must push the local-to-this-activation ports in on every loop</span>
</span><span class='line'>        <span class="c1">// iteration, as this mode could be run re-entrantly and we don&#39;t</span>
</span><span class='line'>        <span class="c1">// want these ports to get serviced.</span>
</span><span class='line'><span class="cp">#if __HAS_DISPATCH__</span>
</span><span class='line'>        <span class="n">__CFPortSetInsert</span><span class="p">(</span><span class="n">dispatchPort</span><span class="p">,</span> <span class="n">waitSet</span><span class="p">);</span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">__CFRunLoopModeUnlock</span><span class="p">(</span><span class="n">rlm</span><span class="p">);</span>
</span><span class='line'>  <span class="n">__CFRunLoopUnlock</span><span class="p">(</span><span class="n">rl</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</code> 这一步实际上系统还会进行界面更新的操作，为验证我子类化并复写了 UIView 的 -drawRect:</p>

<p>首先添加 <code>__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</code> 的符号断点</p>

<p><img src="https://user-images.githubusercontent.com/5633917/38566863-57cb35be-3d17-11e8-8742-301c5221cb81.jpg" alt="171523352314_ pic" /></p>

<p>直至找到 callout 为 <code>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</code> 的 observer</p>

<p><img src="https://user-images.githubusercontent.com/5633917/38567061-d10aded4-3d17-11e8-8ce2-132187878bbc.jpg" alt="191523352370_ pic" /></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span><span class="p">(</span><span class="n">CFRunLoopObserverCallBack</span> <span class="n">func</span><span class="p">,</span> <span class="n">CFRunLoopObserverRef</span> <span class="n">observer</span><span class="p">,</span> <span class="n">CFRunLoopActivity</span> <span class="n">activity</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">func</span><span class="p">(</span><span class="n">observer</span><span class="p">,</span> <span class="n">activity</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">asm</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span> <span class="c1">// thwart tail-call optimization</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>结合源码由上图可知：
rdi 表示第一个参数，即 func 为 QuartzCore:CA::Transaction::observer_callback
rdx 表示第三个参数，十进制值为 32，十六进制表示是 0x0000000000000020，二进制简单对应为 0b100000，而这正好是 <code>kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),</code> 的值，所以得出结论 activity 为 kCFRunLoopBeforeWaiting。</p>

<p>再往下看堆栈，最终 UIView 将会调用 -drawRect: 方法</p>

<p><img src="https://user-images.githubusercontent.com/5633917/38567632-53054626-3d19-11e8-8670-f5f9bd38800e.jpg" alt="211523354018_ pic" /></p>

<p>从 kCFRunLoopBeforeSources 为起点到 kCFRunLoopBeforeWaiting 休眠前，这其中处理了大量的工作————执行 block，处理 source0，更新界面&hellip;做完这些之后 RunLoop 就休眠了，直到 RunLoop 被 timer、source、libdispatch 唤醒，唤醒后会发送休眠结束的 kCFRunLoopAfterWaiting 通知。我们知道屏幕的刷新率是 60fps，即 1/60s ≈ 16ms，假如一次 RunLoop 超过了这个时间，UI 线程有可能出现了卡顿，BeforeSources 到 AfterWaiting 可以粗略认为是一次 RunLoop 的起止。至于其他状态，譬如 BeforeWaiting，它在更新完界面之后有可能休眠了，此时 APP 已是不活跃的状态，不太可能造成卡顿；而 kCFRunLoopExit，它在 RunLoop 退出之后触发，主线程的 RunLoop 除了换 mode 又不太可能主动退出，这也不能用作卡顿检测。</p>

<h3>RunLoop 开始休眠</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/** </span>
</span><span class='line'><span class="cm">  这个 do-while 并不是死循环，__CFRunLoopServiceMachPort 是实际上使线程休眠的函数</span>
</span><span class='line'><span class="cm">  在 __CFRunLoopServiceMachPort 函数内部调用 mach_msg(...) 实现休眠</span>
</span><span class='line'><span class="cm">  USE_DISPATCH_SOURCE_FOR_TIMERS 在 iOS 系统上为 0</span>
</span><span class='line'><span class="cm">*/</span>
</span><span class='line'><span class="cp">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span>
</span><span class='line'>        <span class="k">do</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">mach_msg_header_t</span> <span class="o">*</span><span class="p">)</span><span class="n">msg_buffer</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">__CFRunLoopServiceMachPort</span><span class="p">(</span><span class="n">waitSet</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msg_buffer</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">livePort</span><span class="p">,</span> <span class="n">poll</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">TIMEOUT_INFINITY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">voucherState</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">voucherCopy</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">modeQueuePort</span> <span class="o">!=</span> <span class="n">MACH_PORT_NULL</span> <span class="o">&amp;&amp;</span> <span class="n">livePort</span> <span class="o">==</span> <span class="n">modeQueuePort</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="c1">// Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.</span>
</span><span class='line'>                <span class="k">while</span> <span class="p">(</span><span class="n">_dispatch_runloop_root_queue_perform_4CF</span><span class="p">(</span><span class="n">rlm</span><span class="o">-&gt;</span><span class="n">_queue</span><span class="p">));</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="n">rlm</span><span class="o">-&gt;</span><span class="n">_timerFired</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                    <span class="c1">// Leave livePort as the queue port, and service timers below</span>
</span><span class='line'>                    <span class="n">rlm</span><span class="o">-&gt;</span><span class="n">_timerFired</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span><span class='line'>                    <span class="k">break</span><span class="p">;</span>
</span><span class='line'>                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>                    <span class="k">if</span> <span class="p">(</span><span class="n">msg</span> <span class="o">&amp;&amp;</span> <span class="n">msg</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">mach_msg_header_t</span> <span class="o">*</span><span class="p">)</span><span class="n">msg_buffer</span><span class="p">)</span> <span class="n">free</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>                <span class="c1">// Go ahead and leave the inner loop.</span>
</span><span class='line'>                <span class="k">break</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="cp">#else</span>
</span><span class='line'>        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">mach_msg_header_t</span> <span class="o">*</span><span class="p">)</span><span class="n">msg_buffer</span><span class="p">;</span>
</span><span class='line'>        <span class="n">__CFRunLoopServiceMachPort</span><span class="p">(</span><span class="n">waitSet</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msg_buffer</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">livePort</span><span class="p">,</span> <span class="n">poll</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">TIMEOUT_INFINITY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">voucherState</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">voucherCopy</span><span class="p">);</span>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>


<p>线程休眠之后就不干活了，直到被 timer、source、libdispatch 唤醒。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// 在唤醒之后发送 kCFRunLoopAfterWaiting 通知</span>
</span><span class='line'>  <span class="n">__CFRunLoopUnsetSleeping</span><span class="p">(</span><span class="n">rl</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">poll</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rlm</span><span class="o">-&gt;</span><span class="n">_observerMask</span> <span class="o">&amp;</span> <span class="n">kCFRunLoopAfterWaiting</span><span class="p">))</span> <span class="n">__CFRunLoopDoObservers</span><span class="p">(</span><span class="n">rl</span><span class="p">,</span> <span class="n">rlm</span><span class="p">,</span> <span class="n">kCFRunLoopAfterWaiting</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h3><code>handle_msg</code> 事件源处理及 timer 分析</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="nl">handle_msg:</span><span class="p">;</span>
</span><span class='line'>        <span class="n">__CFRunLoopSetIgnoreWakeUps</span><span class="p">(</span><span class="n">rl</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">MACH_PORT_NULL</span> <span class="o">==</span> <span class="n">livePort</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">CFRUNLOOP_WAKEUP_FOR_NOTHING</span><span class="p">();</span>
</span><span class='line'>            <span class="c1">// handle nothing</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">livePort</span> <span class="o">==</span> <span class="n">rl</span><span class="o">-&gt;</span><span class="n">_wakeUpPort</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">CFRUNLOOP_WAKEUP_FOR_WAKEUP</span><span class="p">();</span>
</span><span class='line'>            <span class="c1">// do nothing on Mac OS</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'><span class="cp">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span>
</span><span class='line'>        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">modeQueuePort</span> <span class="o">!=</span> <span class="n">MACH_PORT_NULL</span> <span class="o">&amp;&amp;</span> <span class="n">livePort</span> <span class="o">==</span> <span class="n">modeQueuePort</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">CFRUNLOOP_WAKEUP_FOR_TIMER</span><span class="p">();</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__CFRunLoopDoTimers</span><span class="p">(</span><span class="n">rl</span><span class="p">,</span> <span class="n">rlm</span><span class="p">,</span> <span class="n">mach_absolute_time</span><span class="p">()))</span> <span class="p">{</span>
</span><span class='line'>                <span class="c1">// Re-arm the next timer, because we apparently fired early</span>
</span><span class='line'>                <span class="n">__CFArmNextTimerInMode</span><span class="p">(</span><span class="n">rlm</span><span class="p">,</span> <span class="n">rl</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'><span class="cp">#if USE_MK_TIMER_TOO</span>
</span><span class='line'>        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rlm</span><span class="o">-&gt;</span><span class="n">_timerPort</span> <span class="o">!=</span> <span class="n">MACH_PORT_NULL</span> <span class="o">&amp;&amp;</span> <span class="n">livePort</span> <span class="o">==</span> <span class="n">rlm</span><span class="o">-&gt;</span><span class="n">_timerPort</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 处理 NSTimer 或 CFRunLoopTimer 的回调</span>
</span><span class='line'>            <span class="n">CFRUNLOOP_WAKEUP_FOR_TIMER</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__CFRunLoopDoTimers</span><span class="p">(</span><span class="n">rl</span><span class="p">,</span> <span class="n">rlm</span><span class="p">,</span> <span class="n">mach_absolute_time</span><span class="p">()))</span> <span class="p">{</span>
</span><span class='line'>                <span class="c1">// Re-arm the next timer</span>
</span><span class='line'>                <span class="n">__CFArmNextTimerInMode</span><span class="p">(</span><span class="n">rlm</span><span class="p">,</span> <span class="n">rl</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'><span class="cp">#if __HAS_DISPATCH__</span>
</span><span class='line'>        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">livePort</span> <span class="o">==</span> <span class="n">dispatchPort</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 执行 main queue 的回调</span>
</span><span class='line'>            <span class="n">CFRUNLOOP_WAKEUP_FOR_DISPATCH</span><span class="p">();</span>
</span><span class='line'>            <span class="n">__CFRunLoopModeUnlock</span><span class="p">(</span><span class="n">rlm</span><span class="p">);</span>
</span><span class='line'>            <span class="n">__CFRunLoopUnlock</span><span class="p">(</span><span class="n">rl</span><span class="p">);</span>
</span><span class='line'>            <span class="n">_CFSetTSD</span><span class="p">(</span><span class="n">__CFTSDKeyIsInGCDMainQ</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">6</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
</span><span class='line'>            <span class="n">_CFSetTSD</span><span class="p">(</span><span class="n">__CFTSDKeyIsInGCDMainQ</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>            <span class="n">__CFRunLoopLock</span><span class="p">(</span><span class="n">rl</span><span class="p">);</span>
</span><span class='line'>            <span class="n">__CFRunLoopModeLock</span><span class="p">(</span><span class="n">rlm</span><span class="p">);</span>
</span><span class='line'>            <span class="n">sourceHandledThisLoop</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'>            <span class="n">didDispatchPortLastTime</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'>        <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 处理 source1 事件</span>
</span><span class='line'>            <span class="n">CFRUNLOOP_WAKEUP_FOR_SOURCE</span><span class="p">();</span>
</span><span class='line'>            <span class="c1">// Despite the name, this works for windows handles as well</span>
</span><span class='line'>            <span class="n">CFRunLoopSourceRef</span> <span class="n">rls</span> <span class="o">=</span> <span class="n">__CFRunLoopModeFindSourceForMachPort</span><span class="p">(</span><span class="n">rl</span><span class="p">,</span> <span class="n">rlm</span><span class="p">,</span> <span class="n">livePort</span><span class="p">);</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">rls</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'><span class="cp">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span>
</span><span class='line'>      <span class="kt">mach_msg_header_t</span> <span class="o">*</span><span class="n">reply</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>      <span class="n">sourceHandledThisLoop</span> <span class="o">=</span> <span class="n">__CFRunLoopDoSource1</span><span class="p">(</span><span class="n">rl</span><span class="p">,</span> <span class="n">rlm</span><span class="p">,</span> <span class="n">rls</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msgh_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reply</span><span class="p">)</span> <span class="o">||</span> <span class="n">sourceHandledThisLoop</span><span class="p">;</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">reply</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">mach_msg</span><span class="p">(</span><span class="n">reply</span><span class="p">,</span> <span class="n">MACH_SEND_MSG</span><span class="p">,</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="n">msgh_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MACH_PORT_NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MACH_PORT_NULL</span><span class="p">);</span>
</span><span class='line'>          <span class="n">CFAllocatorDeallocate</span><span class="p">(</span><span class="n">kCFAllocatorSystemDefault</span><span class="p">,</span> <span class="n">reply</span><span class="p">);</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>代码还是比较直观，一次 RunLoop 仅能执行一类事件源，我们注意到有两个处理 timer 的地方，其中第一处是</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span>
</span><span class='line'>        <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">modeQueuePort</span> <span class="o">!=</span> <span class="n">MACH_PORT_NULL</span> <span class="o">&amp;&amp;</span> <span class="n">livePort</span> <span class="o">==</span> <span class="n">modeQueuePort</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">CFRUNLOOP_WAKEUP_FOR_TIMER</span><span class="p">();</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__CFRunLoopDoTimers</span><span class="p">(</span><span class="n">rl</span><span class="p">,</span> <span class="n">rlm</span><span class="p">,</span> <span class="n">mach_absolute_time</span><span class="p">()))</span> <span class="p">{</span>
</span><span class='line'>                <span class="c1">// Re-arm the next timer, because we apparently fired early</span>
</span><span class='line'>                <span class="n">__CFArmNextTimerInMode</span><span class="p">(</span><span class="n">rlm</span><span class="p">,</span> <span class="n">rl</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>


<p>乍看这很像是 <code>dispatch_source_t</code> 的 timer 回调，而我在实际的调试中当创建
<code>dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());</code>
触发的 timer 回调并不是从这里面回调出来的，而是来自 main queue 的 block。如果使用创建队列的方式生成 timer，而回调又来自 GCD 的内部。上面已经说过 <code>USE_DISPATCH_SOURCE_FOR_TIMERS</code> 在 iOS 环境下是 0，那么如果 GCD 的 timer 依赖 RunLoop，我们怎又能在 iOS 上使用 GCD 的 tiemr。</p>

<p>大胆的猜测：GCD 的 tiemr 不依赖 RunLoop，GCD 实现了一套与 mk_timer 不同的机制。RunLoop 在这可能只是想表达下也能通过 GCD 实现 timer。</p>

<p>线程休眠后，当 NSTimer 或 CFRunLoopTimer 的时间到了，则由内核的 mk_timer 驱动</p>

<p><img src="https://user-images.githubusercontent.com/5633917/38627763-5334e362-3de2-11e8-9f05-1ea6d1c0cd95.JPG" alt="3c3e0e4f-4243-4b6b-bd7b-56c61625ee1f-2208-0000023d12c0dd01_tmp" /></p>

<p>追溯堆栈</p>

<p><img src="https://user-images.githubusercontent.com/5633917/38628196-609918d8-3de3-11e8-88bd-a144360a507f.JPG" alt="4e5d88d2-3995-48dc-a02a-a4e2d18c77ae-2208-0000023d0a7abe8c_tmp" /></p>

<h3>RunLoop 退出的几种方式</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// 再执行一下 block 或 performSelector 的代码</span>
</span><span class='line'><span class="n">__CFRunLoopDoBlocks</span><span class="p">(</span><span class="n">rl</span><span class="p">,</span> <span class="n">rlm</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/** </span>
</span><span class='line'><span class="cm">    进入以下任一 case 后就会退出 RunLoop </span>
</span><span class='line'><span class="cm">    结束就会调用 if (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span>
</span><span class='line'><span class="cm">  */</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">sourceHandledThisLoop</span> <span class="o">&amp;&amp;</span> <span class="n">stopAfterHandle</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">retVal</span> <span class="o">=</span> <span class="n">kCFRunLoopRunHandledSource</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">timeout_context</span><span class="o">-&gt;</span><span class="n">termTSR</span> <span class="o">&lt;</span> <span class="n">mach_absolute_time</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// 自身超时时间到了</span>
</span><span class='line'>      <span class="n">retVal</span> <span class="o">=</span> <span class="n">kCFRunLoopRunTimedOut</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">__CFRunLoopIsStopped</span><span class="p">(</span><span class="n">rl</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// 被外部调用 CFRunLoopStop 停止了</span>
</span><span class='line'>       <span class="n">__CFRunLoopUnsetStopped</span><span class="p">(</span><span class="n">rl</span><span class="p">);</span>
</span><span class='line'>      <span class="n">retVal</span> <span class="o">=</span> <span class="n">kCFRunLoopRunStopped</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rlm</span><span class="o">-&gt;</span><span class="n">_stopped</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// 被 _CFRunLoopStopMode 停止</span>
</span><span class='line'>      <span class="n">rlm</span><span class="o">-&gt;</span><span class="n">_stopped</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span><span class='line'>      <span class="n">retVal</span> <span class="o">=</span> <span class="n">kCFRunLoopRunStopped</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">__CFRunLoopModeIsEmpty</span><span class="p">(</span><span class="n">rl</span><span class="p">,</span> <span class="n">rlm</span><span class="p">,</span> <span class="n">previousMode</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// 检查上一个 mode 有没有执行完所有事件源</span>
</span><span class='line'>      <span class="n">retVal</span> <span class="o">=</span> <span class="n">kCFRunLoopRunFinished</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">retVal</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>解释下 <code>_CFRunLoopStopMode</code> 函数，该函数作用是通过停止当前 RunLoop 执行的某个 mode，对于当前 RunLoop 不包含的 mode，调用这个函数并不会产生效果，查找有没有包含 mode 的大致代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">struct</span> <span class="n">__CFRunLoopMode</span> <span class="n">srlm</span><span class="p">;</span>
</span><span class='line'><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">srlm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">srlm</span><span class="p">));</span>
</span><span class='line'><span class="n">_CFRuntimeSetInstanceTypeIDAndIsa</span><span class="p">(</span><span class="o">&amp;</span><span class="n">srlm</span><span class="p">,</span> <span class="n">__kCFRunLoopModeTypeID</span><span class="p">);</span>
</span><span class='line'><span class="n">srlm</span><span class="p">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">modeName</span><span class="p">;</span>
</span><span class='line'><span class="c1">// 寻找当前 modes 中有没有包含指定 modeName</span>
</span><span class='line'><span class="n">rlm</span> <span class="o">=</span> <span class="p">(</span><span class="n">CFRunLoopModeRef</span><span class="p">)</span><span class="n">CFSetGetValue</span><span class="p">(</span><span class="n">rl</span><span class="o">-&gt;</span><span class="n">_modes</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">srlm</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">rlm</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">__CFRunLoopModeLock</span><span class="p">(</span><span class="n">rlm</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">rlm</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们知道当 RunLoop 切换 mode 时，RunLoop 将会退出，并重新指定 mode 再进入，我猜测系统内部通过调用了 <code>_CFRunLoopStopMode</code> 来达到切换 mode 的效果。</p>

<h2>总结</h2>

<p>通过此次对 RunLoop 的学习，我对 RunLoop 的运行机制终于有了一些概念。在学习过程中也抛出了一些新的疑惑————譬如对系统怎样换 mode 感到好奇，希望以后能想办法搞懂。</p>

<p>参考链接</p>

<p><a href="https://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a></p>

<p><a href="http://v.youku.com/v_show/id_XODgxODkzODI0.html">iOS线下分享《RunLoop》by 孙源@sunnyxx</a></p>

<p><a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=400417748&amp;idx=1&amp;sn=0c5f6747dd192c5a0eea32bb4650c160&amp;scene=0">iOS 事件处理机制与图像渲染过程</a></p>

<p><a href="https://github.com/ming1016/study/wiki/%E6%A3%80%E6%B5%8BiOS%E7%9A%84APP%E6%80%A7%E8%83%BD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95">检测iOS的APP性能的一些方法</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[探秘 Mach-O 文件]]></title>
    <link href="http://hawk0620.github.io/blog/2018/03/22/study-mach-o-file/"/>
    <updated>2018-03-22T23:06:52+08:00</updated>
    <id>http://hawk0620.github.io/blog/2018/03/22/study-mach-o-file</id>
    <content type="html"><![CDATA[<p>之前负责项目的包体积优化学习了 Mach-O 文件的格式，那么 Mach-O 究竟是怎么样的文件，知道它的组成之后我们又能做点什么？本文会从 Mach-O 文件的介绍讲起，再看看认识它后的一些实际应用。</p>

<!--more-->


<p>由于本文篇幅有点长，这里添加了文章导航方便阅读</p>

<ul>
<li><a href="#Mach-O%20%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F">Mach-O 文件格式</a></li>
<li><a href="#%E5%87%8F%E5%B0%91%E5%8C%85%E5%A4%A7%E5%B0%8F">减少包大小</a></li>
<li><a href="#%E8%8E%B7%E5%8F%96%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88">获取调用堆栈</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E7%94%A8%20MachO%20%E6%96%87%E4%BB%B6%E5%85%B3%E8%81%94%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%E5%90%8D">如何用 MachO 文件关联类的方法名</a></li>
</ul>


<h3 id="Mach-O 文件格式">Mach-O 文件格式</h3>


<p>先让我们看看 Mach-O 的大致构成</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37776837-23a2b58c-2e21-11e8-8b97-f968d484319e.png" alt="" /></p>

<p>再使用 MachOView 一窥究竟</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37776371-15ac9b10-2e20-11e8-9dfe-850250c2a8bc.png" alt="" /></p>

<p>结合可知 Mach-O 文件包含了三部分内容：</p>

<ul>
<li>Header（头部），指明了 cpu 架构、大小端序、文件类型、Load Commands 个数等一些基本信息</li>
<li>Load Commands（加载命令)，正如官方的图所示，描述了怎样加载每个 Segment 的信息。在 Mach-O 文件中可以有多个 Segment，每个 Segment 可能包含一个或多个 Section。</li>
<li>Data（数据区），Segment 的具体数据，包含了代码和数据等。</li>
</ul>


<h4>Headers</h4>

<p>Mach-O 文件的头部定义如下：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37776955-6ac166f2-2e21-11e8-9408-e7a3836eff72.png" alt="" /></p>

<ul>
<li>magic 标志符 0xfeedface 是 32 位， 0xfeedfacf 是 64 位。</li>
<li>cputype 和 cpusubtype 确定 cpu 类型、平台</li>
<li>filetype 文件类型，可执行文件、符号文件（DSYM）、内核扩展等</li>
<li>ncmds 加载 Load Commands 的数量</li>
<li>flags dyld 加载的标志

<ul>
<li><code>MH_NOUNDEFS</code> 目标文件没有未定义的符号，</li>
<li><code>MH_DYLDLINK</code> 目标文件是动态链接输入文件，不能被再次静态链接,</li>
<li><code>MH_SPLIT_SEGS</code> 只读 segments 和 可读写 segments 分离，</li>
<li><code>MH_NO_HEAP_EXECUTION</code> 堆内存不可执行…</li>
</ul>
</li>
</ul>


<p>filetype 的定义有：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37776995-7e897378-2e21-11e8-9c86-913ba5277b39.png" alt="" /></p>

<p>flags 的定义有：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37777034-98bdef9e-2e21-11e8-900a-34108ae119fa.png" alt="" /></p>

<p>简单总结一下就是 Headers 能帮助校验 Mach-O 合法性和定位文件的运行环境。</p>

<h4>Load Commands</h4>

<p>Headers 之后就是 Load Commands，其占用的内存和加载命令的总数在 Headers 中已经指出。</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37777147-d5f832e8-2e21-11e8-8c69-8dba2d32a631.png" alt="" /></p>

<p>Load Commands 的定义比较简单：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37777211-f9635d98-2e21-11e8-9c0e-66560b6b3197.png" alt="" /></p>

<ul>
<li>cmd 字段，如上图它指出了 command 类型

<ul>
<li><code>LC_SEGMENT、LC_SEGMENT_64 </code> 将 segment 映射到进程的内存空间，</li>
<li><code>LC_UUID </code> 二进制文件 id，与符号表 uuid 对应，可用作符号表匹配，</li>
<li><code>LC_LOAD_DYLINKER</code> 启动动态加载器，</li>
<li><code>LC_SYMTAB </code> 描述在 <code>__LINKEDIT </code> 段的哪找字符串表、符号表，</li>
<li><code>LC_CODE_SIGNATURE</code> 代码签名等</li>
</ul>
</li>
<li>cmdsize 字段，主要用以计算出到下一个 command 的偏移量。</li>
</ul>


<h4>Segment &amp; Section</h4>

<p>这里先来看看 segment 的定义：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37777286-1b07ebf8-2e22-11e8-8587-4b4897f9dbc7.png" alt="" /></p>

<ul>
<li>cmd 就是上面分析的 command 类型</li>
<li>segname 在源码中定义的宏

<ul>
<li><code>#define  SEG_PAGEZERO    "__PAGEZERO" // 可执行文件捕获空指针的段 </code></li>
<li><code>#define  SEG_TEXT    "__TEXT" // 代码段，只读数据段 </code></li>
<li><code>#define  SEG_DATA    "__DATA"    // 数据段 </code></li>
<li><code>#define  SEG_LINKEDIT    "__LINKEDIT" // 包含动态链接器所需的符号、字符串表等数据 </code></li>
</ul>
</li>
<li>vmaddr 段的虚存地址（未偏移），由于 ALSR，程序会在进程加上一段偏移量（slide），真实的地址 = vm address + slide</li>
<li>vmsize 段的虚存大小</li>
<li>fileoff 段在文件的偏移</li>
<li>filesize 段在文件的大小</li>
<li>nsects 段中有多少个 section</li>
</ul>


<p>接着看看 section 的定义：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37777312-2f77f7f4-2e22-11e8-8736-12ab00714504.png" alt="" /></p>

<p><code>__Text</code> 和 <code>__Data</code> 都有自己的 section</p>

<ul>
<li>segname 就是所在段的名称</li>
<li>sectname section名称，部分列举：

<ul>
<li><code>Text.__text</code> 主程序代码</li>
<li><code>Text.__cstring</code> c 字符串</li>
<li><code>Text.__stubs</code> 桩代码</li>
<li><code>Text.__stub_helper</code></li>
<li><code>Data.__data</code> 初始化可变的数据</li>
<li><code>Data.__objc_imageinfo</code> 镜像信息 ，在运行时初始化时 <code>objc_init</code>，调用 <code>load_images</code> 加载新的镜像到 infolist 中<img src="https://user-images.githubusercontent.com/5633917/37777338-4106908e-2e22-11e8-94df-3328b570226f.png" alt="" /></li>
<li><code>Data.__la_symbol_ptr</code></li>
<li><code>Data.__nl_symbol_ptr</code></li>
<li><code>Data.__objc_classlist</code> 类列表</li>
<li><code>Data.__objc_classrefs</code> 引用的类</li>
</ul>
</li>
</ul>


<p>这节最后探究下 stubs，在 Xcode 中新建 C 项目，代码如下：</p>

<pre><code>#include &lt;stdio.h&gt;
int main(int argc, const char * argv[]) {
    printf("Hello, coder\n");
    return 0;
}
</code></pre>

<p>使用 <code>gcc -c main.c</code> 将其编译成 a.out 文件，调用 nm 命令查看 .o 文件的符号</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37777400-68692d3a-2e22-11e8-8d20-b42a4d88b86c.png" alt="" /></p>

<p>看到 <code>_printf </code> 是未定义的，也就是说并没有该函数的内存地址。nm 打印出的信息表明<code>dyld_stub_binder </code> 也是未定义的。
打开 Hopper 查看 .o 文件</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37777431-81613ff8-2e22-11e8-8ab5-ff4bbf8bffb0.png" alt="" /></p>

<p>可以看出 printf 会跳入 <code>__stubs</code> 中，地址也与 MachOView 看到的相对应</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37777470-96d8cd9c-2e22-11e8-8cea-cf107dbb7858.png" alt="" /></p>

<p>双击刚才  <code>__stubs</code>  中的地址，会跳转到 <code>__la_symbol_ptr</code></p>

<p><img src="https://user-images.githubusercontent.com/5633917/37777493-a96c4948-2e22-11e8-80f6-20bb35175ea5.png" alt="" /></p>

<p>在 MachOView 中查看 0x100001010 对应的数据为 0x10000f9c</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37777894-940abbe2-2e23-11e8-9000-2d1800633d4b.png" alt="" /></p>

<p>用 Hopper 搜索 0x10000f9c，跳转到 <code>stub_helper</code>，可知 <code>__la_symbol_ptr</code> 里的数据被 bind 成了  <code>stub_helper</code></p>

<p><img src="https://user-images.githubusercontent.com/5633917/37777951-b34195a8-2e23-11e8-93df-b659b770ba0f.png" alt="" /></p>

<p>由此可知，<code>__la_symbol_ptr</code> 中的数据被第一次调用时会通过 <code>dyld_stub_binder</code> 进行相关绑定，而 <code>__nl_symbol_ptr</code> 中的数据就是在动态库绑定时进行加载。</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37777997-d2a381fe-2e23-11e8-9ec0-3c6ab5e20447.png" alt="" /></p>

<p>所以 <code>__la_symbol_ptr</code> 中的数据在初始状态都被 bind 成  <code>stub_helper</code>，接着 <code>dyld_stub_binder </code> 会加载相应的动态链接库，执行具体的函数实现，此时 <code>__la_symbol_ptr</code> 也获取到了函数的真实地址，完成了一次近似懒加载的过程。</p>

<p>写到这里，算是快速过了一遍 Mach-O 文件的基本概念，接着聊聊可以怎样减少项目的体积。</p>

<h3 id="减少包大小">减少包大小</h3>


<p>iOS 的包主要由可执行文件、资源文件（图片）等文件组成，所以可以从这两大头文件入手优化。</p>

<h4>可执行文件瘦身</h4>

<p>我们的项目中难免会存在一些没使用的类或方法，由于 OC 的动态特性，编译器会对所有的源文件进行编译，找出并删除没用到的类或方法可以减少可执行文件大小。
上文中提到了 <code>__objc_classlist</code> 和 <code>__objc_classrefs </code>，它们分别表示项目中全部类列表和项目中被引用的类列表，那么取两者之差，就能删除一些项目中没使用的类文件。但是在删除过程中记住要在项目中全局搜索确认下，看看有没有通过字符串调用无引用的类的方法，原因还是 OC 是动态语言。
在看具体做法之前，顺带提一下我公司的项目组成。我们维护着俩客户端，共用着一个基础库（lib 库），可能有时由于产品的需求变更或者为了产品功能的预留导致 lib 库中只有着某个端使用的代码，我在上述的做法中对脚本做了稍微改进，以防删除了 lib 库的代码，导致另一个端跑不起来，下面介绍通用的做法：</p>

<ul>
<li>在控制台输入 <code>otool -v -s __objc_classlist </code> 和 <code>otool -v -s __objc_classrefs </code> 命令，逆向 <code>__DATA. __objc_classlist</code> 段和 <code>__DATA. __objc_classrefs </code> 段获取当前所有oc类和被引用的oc类。</li>
<li>取两者差集，得到没被引用的类的段地址</li>
<li>otool -o 二进制文件，获取段信息</li>
<li>通过脚本使用没被引用的类的段地址去段信息中匹配出具体类名</li>
</ul>


<h4>压缩图片资源</h4>

<p>这点就跟本文的主题没什么关系，不感兴趣可以略过。
压缩 app 中的图片是我做的另一个努力，虽然 Xcode 会压一遍，但是经我压缩后打包发现包还是会少个将近 1m，这里用到的工具是 ImageOptim，贴出我的三脚猫 python：</p>

<pre><code>all_file_size = 0
all_file_count = 0

def fileDriector(filePath):
    global all_file_size, all_file_count

    for file in os.listdir(filePath):
        if os.path.isdir(filePath + '/' + file):
            if file != 'Pods' and not file.startswith('.') and not file.endswith('.framework') \
                    and not file.endswith('.bundle') and not file.endswith('.a') and file != 'libs' \
                    or file.endswith('.xcassets') or file.endswith('.imageset'):
                the_path = filePath + '/' + file
                fileDriector(the_path)
        elif file.endswith('.png') or file.endswith('.jpg'):
            fileName = filePath + '/' + file

            comand_line = "echo %s | imageoptim" % fileName
            test = subprocess.Popen(comand_line, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            output = test.communicate()[0]

            numberList = re.findall('\.?\d+\.?\d*kb', output)
            lastSize = numberList[-1]

            lastSizeList = re.findall('\.?\d+\.?\d*', lastSize)
            saveSize = lastSizeList[0]
            if saveSize.startswith('.'):
                saveSize = '0' + saveSize

            finalSize = float(saveSize)
            all_file_size += finalSize
            all_file_count += 1
            print output
</code></pre>

<p>其他的一些减包方案就不展开了，接下来我试着分析一下 bestswifter 大神的 <code>BSBacktraceLogger </code></p>

<h3 id="获取调用堆栈">获取调用堆栈</h3>


<p>说到调用堆栈，我们很容易联想到 DSYM 文件，我们知道 Xcode build setting 有个 DEBUG INFOMATION FORMAT 的选项</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37778243-6492e91a-2e24-11e8-8fde-1ec051ffae0e.png" alt="" /></p>

<p>可以看到 Debug 模式下，符号表文件会存入可执行文件中，而 Release 模式则会生成出 DSYM 文件，我们平常使用 Bugly 等工具上传的就是这份 DSYM 文件，DSYM 也是种 Mach-O 文件。在 Debug 模式，由于符号表在内存中，这为我们符号化堆栈提供了可能性。</p>

<pre><code>bool bs_fillThreadStateIntoMachineContext(thread_t thread, _STRUCT_MCONTEXT *machineContext) {
    mach_msg_type_number_t state_count = BS_THREAD_STATE_COUNT;
    kern_return_t kr = thread_get_state(thread, BS_THREAD_STATE, (thread_state_t)&amp;machineContext-&gt;__ss, &amp;state_count);
    return (kr == KERN_SUCCESS);
}
</code></pre>

<p><code>thread_get_state </code> 函数获取线程执行状态（例如寄存器），传入 <code>_STRUCT_MCONTEXT </code> 结构体，<code>_STRUCT_MCONTEXT </code> 在不同的 cpu 架构会有所不同。</p>

<pre><code>uintptr_t bs_mach_instructionAddress(mcontext_t const machineContext){
    return machineContext-&gt;__ss.BS_INSTRUCTION_ADDRESS;
}

const uintptr_t instructionAddress = bs_mach_instructionAddress(&amp;machineContext);
</code></pre>

<p>获取当前指令的地址，也就是当前的栈帧，即当前被调用的函数。下面先讲下关于栈帧的概念。</p>

<h4>栈帧是什么</h4>

<p><img src="https://user-images.githubusercontent.com/5633917/37778363-bd21bbf6-2e24-11e8-8545-4acaf084d954.png" alt="" /></p>

<p>如上图，一个函数调用栈是由若干个栈帧组成，每个栈帧通过 FP 和 SP 划分界线，fun1 函数 SP 和 FP 的指向就是 main 函数的栈帧。所以说只要知道当前函数的栈帧就能获取上一个函数的栈帧，从而回溯出函数调用栈。</p>

<p>程序计数器（PC）作用是给出将要执行的下一条指令在内存中的地址，上面代码的 <code>BS_INSTRUCTION_ADDRESS</code>。其中 16 位为 %ip，32 位为 %eip，64 位为 %rip，arm 是 pc。</p>

<p>SP 是栈指针寄存器，指向栈顶。</p>

<p>FP 是栈基址寄存器，指向栈起始位置。</p>

<p>LR 寄存器在子程序调用时会存储 PC 的值，即返回值。</p>

<p>为了方便获取栈帧，干脆构造一个栈帧的结构体，以下代码来自 KSCrash，它的注释已经很好的讲明了结构体的原由，BSBacktraceLogger 与之类似。</p>

<pre><code>/** Represents an entry in a frame list.
 * This is modeled after the various i386/x64 frame walkers in the xnu source,
 * and seems to work fine in ARM as well. I haven't included the args pointer
 * since it's not needed in this context.
 */
typedef struct FrameEntry
{
    /** The previous frame in the list. */
    struct FrameEntry* previous;

    /** The instruction address. */
    uintptr_t return_address;
} FrameEntry;
</code></pre>

<p>之后，递归获取函数栈帧</p>

<pre><code>for(; i &lt; 50; i++) {
        backtraceBuffer[i] = frame.return_address;
        if(backtraceBuffer[i] == 0 ||
           frame.previous == 0 ||
           bs_mach_copyMem(frame.previous, &amp;frame, sizeof(frame)) != KERN_SUCCESS) {
            break;
        }
    }
</code></pre>

<h4>符号化</h4>

<p>符号化地址的大致思路分三步：1. 获取地址所在的内存镜像；2. 定位到内存镜像的符号表；3. 再从符号表中找到目标地址的符号。</p>

<h5>找到地址所在的内存镜像</h5>

<pre><code>uint32_t bs_imageIndexContainingAddress(const uintptr_t address) {
    const uint32_t imageCount = _dyld_image_count();
    const struct mach_header* header = 0;

    for(uint32_t iImg = 0; iImg &lt; imageCount; iImg++) {
        header = _dyld_get_image_header(iImg);
</code></pre>

<p> 遍历 image，得到指向 image header 的指针</p>

<pre><code>uintptr_t addressWSlide = address - (uintptr_t)_dyld_get_image_vmaddr_slide(iImg);
uintptr_t cmdPtr = bs_firstCmdAfterHeader(header);
</code></pre>

<p>对指针 +1 操作，返回指向 load command 的指针</p>

<pre><code>for(uint32_t iCmd = 0; iCmd &lt; header-&gt;ncmds; iCmd++) {
                const struct load_command* loadCmd = (struct load_command*)cmdPtr;
                if(loadCmd-&gt;cmd == LC_SEGMENT) {
                    const struct segment_command* segCmd = (struct segment_command*)cmdPtr;
                    if(addressWSlide &gt;= segCmd-&gt;vmaddr &amp;&amp;
                       addressWSlide &lt; segCmd-&gt;vmaddr + segCmd-&gt;vmsize) {
                        return iImg;
                    }
                }
</code></pre>

<p>如果某个 segment 包含这个地址，那么该地址应大于 segment 的起始地址，小于 segment 的起始地址 + segment 的大小。</p>

<h5>定位镜像的符号表</h5>

<p><code>__LINKEDIT</code> 段包含了符号表（symbol），字符串表（string），重定位表（relocation）。<code>LC_SYMTAB</code> 指明了 <code>__LINKEDIT</code> 段查找字符串和符号表的位置。我们可以结合 <code>SEG_LINKEDIT</code> 和 <code>LC_SYMTAB</code> 来找到 image 的符号表。
接下来看看段基址的获取：
虚拟地址偏移量 = 虚拟地址（vmaddr） &ndash; 文件偏移量（fileoff）
段基址 = 虚拟地址偏移量 +  ASLR的偏移量</p>

<pre><code>const uintptr_t imageVMAddrSlide = (uintptr_t)_dyld_get_image_vmaddr_slide(idx);
// ALSR
const uintptr_t addressWithSlide = address - imageVMAddrSlide;
const uintptr_t segmentBase = bs_segmentBaseOfImageIndex(idx) + imageVMAddrSlide;
</code></pre>

<p>有了段基址，获取符号表和字符串表就只是计算下 symoff 和 stroff 偏移量了：</p>

<pre><code>const BS_NLIST* symbolTable = (BS_NLIST*)(segmentBase + symtabCmd-&gt;symoff);
const uintptr_t stringTable = segmentBase + symtabCmd-&gt;stroff;
</code></pre>

<h5>找到最匹配的符号</h5>

<p>递归查找离 addressWithSlide 更近的函数入口地址，因为 addressWithSlide 肯定大于某个函数的入口。</p>

<pre><code>for(uint32_t iSym = 0; iSym &lt; symtabCmd-&gt;nsyms; iSym++) {
                // If n_value is 0, the symbol refers to an external object.
    if(symbolTable[iSym].n_value != 0) {
            uintptr_t symbolBase = symbolTable[iSym].n_value;
                 uintptr_t currentDistance = addressWithSlide - symbolBase;
                  if((addressWithSlide &gt;= symbolBase) &amp;&amp;
                       (currentDistance &lt;= bestDistance)) {
                        bestMatch = symbolTable + iSym;
                        bestDistance = currentDistance;
                    }
        }
}
</code></pre>

<h3 id="如何用 MachO 文件关联类的方法名">如何用 MachO 文件关联类的方法名</h3>


<p>MachO 文件的 <code>__Text</code> 段有 <code>__objc_classname</code> 和 <code>__objc_methname</code> 来表示类名和方法名，但是这两者之间是如何做到关联的呢？下面我以系统的计算器做例子，试着进一步研究下 MachO 文件。
使用 MachOView 打开系统计算机，先来看看 <code>__objc_classname</code> 和 <code>__objc_methname</code> 在 load commands 里的定义：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37772635-327d2624-2e16-11e8-98fb-b5cea70f5154.png" alt="" /></p>

<p><img src="https://user-images.githubusercontent.com/5633917/37772656-4669a46e-2e16-11e8-832f-6351a28979e0.png" alt="" /></p>

<p>我们顺着 <code>__objc_classname</code> 的偏移offset 109518 即 0x1ABCE 来到：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37772457-a6329546-2e15-11e8-807e-cbef3da6cbee.png" alt="" /></p>

<p>同理 <code>__objc_methname</code> 的偏移为 0x165E8：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37772866-f014900a-2e16-11e8-8ee2-04793df6d995.png" alt="" /></p>

<p>那么，怎样像 class-dump 那样将类和自个的方法名对应起来呢？
由于每个类的虚拟地址都在Data 段 <code>__objc_classlist</code> 中：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37773001-5c068688-2e17-11e8-8ca6-defa18ac7428.png" alt="" /></p>

<p>我们看到起始地址对应的是 0x1000298A8 这个地址，为了得到实际的地址需要用虚拟地址 &ndash; 段起始地址 + 文件偏移，经过一番计算，结果是0x298A8，来到文件偏移处，已经在DATA 段的 <code>__objc_data</code></p>

<p><img src="https://user-images.githubusercontent.com/5633917/37773272-210903b6-2e18-11e8-8d75-5612f5c24dbf.png" alt="" /></p>

<p>在这里会对应着类的结构体，代码拷自 class-dump</p>

<pre><code>struct cd_objc2_class {
    uint64_t isa;
    uint64_t superclass;
    uint64_t cache;
    uint64_t vtable;
    uint64_t data; // points to class_ro_t
    uint64_t reserved1;
    uint64_t reserved2;
    uint64_t reserved3;
};
</code></pre>

<p>data 是我们感兴趣的，它指向 <code>class_ro_t </code>，熟悉 runtime 的话应该知道 <code>class_ro_t </code> 存储了类在编译器就确定的属性、方法、协议等。
所以上图顺着找下去 0x100020A68 就是data 的内存地址，再用上面的公式计算得到 0x20A68，我们在 <code>__objc_const</code>找到那里：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37773857-aca7264a-2e19-11e8-848f-e40a00038f7f.png" alt="" /></p>

<p>这里就是对应着 <code>class_ro_t </code>，来看看它在 class-dump 里的定义：</p>

<pre><code>struct cd_objc2_class_ro_t {
    uint32_t flags;
    uint32_t instanceStart;
    uint32_t instanceSize;
    uint32_t reserved; // *** this field does not exist in the 32-bit version ***
    uint64_t ivarLayout;
    uint64_t name;
    uint64_t baseMethods;
    uint64_t baseProtocols;
    uint64_t ivars;
    uint64_t weakIvarLayout;
    uint64_t baseProperties;
};
</code></pre>

<p>最终 0x20A80 就是name，0x20A88 就是 baseMethods。name 对应的正好是 0x1ABCE，类名是 BitFieldBox。baseMethods 指向内存 0x100020A00，该地址对应的数据是 18 00 00 00 04 00 00 00 表示 entsize 和 count 方法数，在这8个字节之后就是 name 方法名，types 方法类型， imp 函数指针了，所以方法名处的数据为 0x1000165e8 刚好对应 initWithFrame:
将结论用 class-dump 验证可得 BitFieldBox 的第一个方法是 initWithFrame</p>

<p><img src="https://user-images.githubusercontent.com/5633917/37774620-b04a4212-2e1b-11e8-9e45-22098920b939.png" alt="" /></p>

<h3>总结</h3>

<p>最初学习 MachO 文件格式觉得挺抽象的，后来经过各种源码的阅读和融合，终于在一次次地探索中比较直观地认识了 MachO 文件，特别是在 MachO 文件关联类的方法名时对类在内存中的布局有了更进一步的认识。虽然我们平常开发基本不和 MachO 文件打交道，但是对它有个基本概念，无论是做崩溃分析、逆向等都是有帮助的。</p>

<h4>参考链接</h4>

<p><a href="http://satanwoo.github.io/2017/06/13/Macho-1/">深入剖析Macho (1)</a></p>

<p><a href="https://blog.csdn.net/jasonblog/article/details/49909163">iOS中线程Call Stack的捕获和解析（一）</a></p>

<p><a href="https://blog.csdn.net/jasonblog/article/details/49909209">iOS中线程Call Stack的捕获和解析（二）</a></p>

<p><a href="https://bestswifter.com/callstack/">获取任意线程调用栈的那些事</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 11 怎样为导航条上的 UIBarButtonItem 设置间距]]></title>
    <link href="http://hawk0620.github.io/blog/2018/01/06/ios11-barbuttonitem/"/>
    <updated>2018-01-06T14:28:20+08:00</updated>
    <id>http://hawk0620.github.io/blog/2018/01/06/ios11-barbuttonitem</id>
    <content type="html"><![CDATA[<p>以前我们常用 <code>fixedSpace</code> 的方式为 UINavigationBar 上的 UIBarButtonItem 设置间距：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">UIBarButtonItem</span> <span class="o">*</span><span class="n">negativeSpacer</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIBarButtonItem</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithBarButtonSystemItem</span><span class="o">:</span><span class="n">UIBarButtonSystemItemFixedSpace</span>
</span><span class='line'>                                                                                <span class="n">target</span><span class="o">:</span><span class="nb">nil</span>
</span><span class='line'>                                                                                <span class="n">action</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="n">negativeSpacer</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="o">-</span><span class="mi">8</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">navigationItem</span> <span class="n">setLeftBarButtonItems</span><span class="o">:</span><span class="p">@[</span><span class="n">negativeSpacer</span><span class="p">,</span> <span class="n">button</span><span class="p">]</span> <span class="n">animated</span><span class="o">:</span><span class="nb">NO</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>




<!--more-->


<p>然而在 iOS 11 下 <code>UIBarButtonItem</code> width 属性不但失效了，<code>UIBarButtonItem</code> 也开始使用 auto layout 布局，对此我们需要设置 <code>UIBarButtonItem</code> 子 view 的约束。除此之外，苹果还修改了 <code>UINavigationBar</code> 的实现。直到 iOS 10 <code>UINavigationBar</code> 都是采用手动布局，所有的子 view 都是直接加在 <code>UINavigationBar</code> 上。但是，从 iOS 11 开始， <code>UINavigationBar</code> 使用了 auto layout 来布局它的内容子 view，并且子 view 加在了 <code>_UINavigationBarContentView</code> 上。</p>

<p>先来看看 iOS 11 下 <code>UINavigationBar</code> 的视图层级：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">UINavigationBar</span>
</span><span class='line'>      <span class="o">|</span> <span class="n">_UIBarBackground</span>
</span><span class='line'>      <span class="o">|</span>    <span class="o">|</span> <span class="n">UIImageView</span>
</span><span class='line'>      <span class="o">|</span>    <span class="o">|</span> <span class="n">UIImageView</span>
</span><span class='line'>      <span class="o">|</span> <span class="n">_UINavigationBarLargeTitleView</span>
</span><span class='line'>      <span class="o">|</span>    <span class="o">|</span> <span class="n">UILabel</span>
</span><span class='line'>      <span class="o">|</span> <span class="n">_UINavigationBarContentView</span>
</span><span class='line'>      <span class="o">|</span>    <span class="o">|</span> <span class="n">_UIButtonBarStackView</span>
</span><span class='line'>      <span class="o">|</span>    <span class="o">|</span>    <span class="o">|</span> <span class="n">_UIButtonBarButton</span>
</span><span class='line'>      <span class="o">|</span>    <span class="o">|</span>    <span class="o">|</span>    <span class="o">|</span> <span class="n">_UIModernBarButton</span>
</span><span class='line'>      <span class="o">|</span>    <span class="o">|</span>    <span class="o">|</span>    <span class="o">|</span>    <span class="o">|</span> <span class="n">UIButtonLabel</span>
</span><span class='line'>      <span class="o">|</span> <span class="n">_UINavigationBarContentView</span>
</span><span class='line'>      <span class="o">|</span>    <span class="o">|</span> <span class="n">_UIButtonBarStackView</span>
</span><span class='line'>      <span class="o">|</span>    <span class="o">|</span>    <span class="o">|</span> <span class="n">_UITAMICAdaptorView</span> <span class="c1">// customView</span>
</span><span class='line'>      <span class="o">|</span>    <span class="o">|</span>    <span class="o">|</span>    <span class="o">|</span> <span class="n">UIBarButtonItem</span>
</span><span class='line'>      <span class="o">|</span>    <span class="o">|</span>    <span class="o">|</span>    <span class="o">|</span>    <span class="o">|</span> <span class="n">UIImageView</span>
</span><span class='line'>      <span class="o">|</span>    <span class="o">|</span>    <span class="o">|</span>    <span class="o">|</span>    <span class="o">|</span> <span class="n">UIButtonLabel</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过 View Debug 工具可知，原来是 stackView 限制了 customView 的宽度以及引起了偏移：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">contentView</span> <span class="o">|&lt;-</span><span class="n">fullWidth</span><span class="o">-----------&gt;|</span>
</span><span class='line'><span class="n">stackView</span>     <span class="o">|&lt;-</span><span class="n">stackViewWidth</span><span class="o">-&gt;|</span>
</span><span class='line'><span class="n">customView</span>    <span class="o">|&lt;-</span><span class="n">reducedWidth</span><span class="o">---&gt;|</span>
</span></code></pre></td></tr></table></div></figure>


<p>在此次深挖之前，贝聊客户端的开发小哥们由于项目工期紧以及适配 iOS 11 工作量大，暂时是通过设置 <code>UIButton</code> 的 <code>setContentEdgeInsets:</code> 来实现的，这在当时看来是以最小的改动完成了适配，直到 iOS 11.2 这个版本的推出，我们发现当侧滑返回时，导航条的返回按钮会被切掉一点角。（这个方法还有个小缺点是点击区域太小了）</p>

<p><img src="https://user-images.githubusercontent.com/5633917/34596594-044690be-f21c-11e7-8000-e045dd1f0822.png" alt="img1" /></p>

<p>碰巧的是，我的 leader 恰好发现了钉钉也有类似的问题。</p>

<p><img src="https://user-images.githubusercontent.com/5633917/34637834-7982edb8-f2f9-11e7-84f5-9fef5306e910.JPG" alt="" /></p>

<p>iOS 11 虽然已经推出好几个月了，这个问题可能还在困扰着部分同行，接下来就讲讲贝聊是如何解决这个问题的。</p>

<p>由于大家知道 fixed space 失效是系统换成了 auto layout 来实现，所以网上的大部分文章也都是修改 constraint。遗憾的是，我谷歌到挺多使用这种方式去修改要获取到 <code>UINavigationBar</code> 的私有子 view，譬如 <code>contentView</code> 或 <code>barStackView</code>，再为私有子 view 添加 leading 和 trailing 的约束等。</p>

<p>我并没有尝试这种方法的可行性，因为始终觉得获取私有子 view 的做法比较脆弱，苹果一旦更换实现，程序的健壮性不好保障。但可以确定的是，解决这个问题的思路大致是修改约束，设法摆脱 stackView 的限制。</p>

<p>在 auto layout 中，约束是使用 alignment rectangle 来确定视图的大小和位置。先看看 alignment rectangle 的作用是怎样，下图摘自《iOS Auto Layout Demystified》：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/34598265-97cfd8e0-f226-11e7-886f-3d0d2f0d79ce.jpeg" alt="img2" /></p>

<p><img src="https://user-images.githubusercontent.com/5633917/34598273-b0486090-f226-11e7-998a-9d695a1f4bbc.jpeg" alt="img3" /></p>

<p>书中对此的说明是，假如设计师给了你张带角标的气泡图片，程序只期望对气泡进行居中，而图片的 frame 却包含了角标部分，这时可以 override <code>alignmentRectForFrame:</code>、<code>frameForAlignmentRect</code>。<code>UIView</code> 也给出了相对简便的属性 <code>alignmentRectInsets</code>，需要注意的是，一旦设置了 <code>alignmentRectInsets</code>，view 的 frame 就会根据 alignment rectangle 和 <code>alignmentRectInsets</code> 计算出来。</p>

<p>有了以上的概念后，贝聊的修复方法是子类化一个 UIBarButtonItem 的 customView：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">BLNavigationItemCustomView</span>: <span class="nc">UIView</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">)</span> <span class="n">UIEdgeInsets</span> <span class="n">alignmentRectInsetsOverride</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">BLNavigationItemCustomView</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">UIEdgeInsets</span><span class="p">)</span><span class="nf">alignmentRectInsets</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">UIEdgeInsetsEqualToEdgeInsets</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">alignmentRectInsetsOverride</span><span class="p">,</span> <span class="n">UIEdgeInsetsZero</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">super</span><span class="p">.</span><span class="n">alignmentRectInsets</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">alignmentRectInsetsOverride</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>再就是创建 customView 时针对 iOS 11 做特殊处理，以返回按钮为例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="p">(@</span><span class="n">available</span><span class="p">(</span><span class="n">iOS</span> <span class="mf">11.0</span><span class="p">,</span> <span class="o">*</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">button</span><span class="p">.</span><span class="n">alignmentRectInsetsOverride</span> <span class="o">=</span> <span class="n">UIEdgeInsetsMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">offset</span><span class="p">));</span>
</span><span class='line'>    <span class="n">button</span><span class="p">.</span><span class="n">translatesAutoresizingMaskIntoConstraints</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">button</span><span class="p">.</span><span class="n">widthAnchor</span> <span class="n">constraintEqualToConstant</span><span class="o">:</span><span class="n">buttonWidth</span><span class="p">].</span><span class="n">active</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">button</span><span class="p">.</span><span class="n">heightAnchor</span> <span class="n">constraintEqualToConstant</span><span class="o">:</span><span class="mi">44</span><span class="p">].</span><span class="n">active</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>之所以设置 widthAnchor、heightAnchor 是前文提到的需要对 <code>UIBarButtonItem</code> 子 view 设置约束，我在实现时就遇到了怎么修改 frame 都无法撑大 customView 的情况，后来发现是没设置 widthAnchor。我们接着用 View Debug 来看看实现的效果：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/34602108-8b91454c-f239-11e7-9677-9c8434ec0d8a.jpeg" alt="img4" /></p>

<p>这儿有个问题就是 customView 有小部分超出了 stackView 的 bounds，导致了超出部分无法接收点击。有趣的是，使用 iOS 11 之前 fixed space 添加间距的做法可以减少 stackView 的 margin。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">UIBarButtonItem</span> <span class="o">*</span><span class="n">spacer</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIBarButtonItem</span> <span class="n">bl_barButtonItemSpacerWithWidth</span><span class="o">:-</span><span class="p">(</span><span class="n">offset</span><span class="p">)];</span>
</span><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">navigationItem</span><span class="p">.</span><span class="n">leftBarButtonItems</span> <span class="o">=</span> <span class="p">@[</span><span class="n">spacer</span><span class="p">,</span> <span class="n">barButtonItem</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>结合上 fixed space 和 alignmentRectInsets，customView 将不再超出它的父视图：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/34602516-04f734b8-f23b-11e7-809a-5574dc5f6b3e.jpeg" alt="img5" /></p>

<p>总之，我们需继承复写 <code> alignmentRectInsets</code> 的 <code>BLNavigationItemCustomView </code>，然后继续保持之前版本 fixed space 的处理，只针对 iOS 11 为 customView 新增约束，就可使间距问题在新旧系统得以解决。</p>

<h3>总结</h3>

<p>不客气的说，iOS 11 真的是一个挺难适配的版本，期间我都差点放弃对导航条间隔的适配了，好在最后还是顺利解决了。如果你有更好的方式解决，欢迎赐教。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何实现一个 AttributedLabel]]></title>
    <link href="http://hawk0620.github.io/blog/2017/11/27/attributed-label/"/>
    <updated>2017-11-27T23:46:34+08:00</updated>
    <id>http://hawk0620.github.io/blog/2017/11/27/attributed-label</id>
    <content type="html"><![CDATA[<p>Core Text 是苹果提供的富文本排版技术，可以定制开发图文混排功能，DTCoreText、Nimbus、YYLabel 等优秀的开源库底层都是基于 Core Text 的封装和扩展。本文将介绍 Core Text 的基本用法，逐步讲解我是如何封装一个 <a href="https://github.com/hawk0620/PYQFeedDemo">AttributedLabel</a> 的。</p>

<!--more-->


<h3>文本排版简述</h3>

<p>文本排版是根据给定的文本（text）、字体（font）、绘制区域（shape）、行高（line height）等相关属性，生成出字形（glyphs）布局在屏幕绘制区的适当位置。排版的核心就是将字符（characters）转换成字形，将字形排列成行（lines），再将行排成段落（paragraphs）。用代码表达就是下边寥寥几行。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CTFramesetterRef</span> <span class="n">framesetter</span> <span class="o">=</span> <span class="n">CTFramesetterCreateWithAttributedString</span><span class="p">((</span><span class="n">CFAttributedStringRef</span><span class="p">)</span><span class="n">attributedString</span><span class="p">);</span>
</span><span class='line'><span class="n">CTFrameRef</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">CTFramesetterCreateFrame</span><span class="p">(</span><span class="n">framesetter</span><span class="p">,</span> <span class="n">CFRangeMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="n">attributedString</span> <span class="n">length</span><span class="p">]),</span> <span class="n">path</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'><span class="n">CTFrameDraw</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的主要步骤有：</p>

<ol>
<li>创建 Attributed String；</li>
<li>创建 CTFramesetter，这是 Core Text 排版的核心类，它会贯穿整个排版过程；</li>
<li>创建 CGPath，即绘制的区域；</li>
<li>通过 CTFramesetter 和 CGPath 创建 CTFrame，然后可将其绘制在当前的 context 上；</li>
<li>别忘了调用 CFRelease 释放对象。</li>
</ol>


<p>在继续深入代码之前，先了解以下几个小概念：</p>

<h4>字形与字体</h4>

<p>简单说字体就是映射到字符的字形集合，以下就是字符 a （ascii 码为 97）的不同字形：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/33275706-6f4178aa-d3ce-11e7-921c-4afd1bb6b76a.png" alt="" /></p>

<p>而同一字体下字形也可能会有所不同，在英文中比较常见的如连字，典型的就是fi中 i 的点常与 f 的钩合并：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/33275829-b2a349ac-d3ce-11e7-931a-41dcd8c2f3ec.png" alt="" /></p>

<p>接下来说说字体，在开发中我们常说同一字体不同字号，比如  <code>[UIFont systemFontOfSize: 16]</code> 和 <code>[UIFont systemFontOfSize: 18]</code>，或者同一字体但是加粗显示，又如  <code>[UIFont systemFontOfSize: 16]</code> 和 <code>[UIFont boldSystemFontOfSize: 16]</code>，又或者斜体，然而这对于系统而言是完全不同的字体。这儿想说明的是：不同字号是不同的字体，粗体相对普通也是不同的字体，而给文本添加下划线却是个例外（下划线是系统额外画的一条装饰线）。</p>

<p>有时我们在开发中也会接触到字体的 Ascent 和 Descent，其实就是在于字形度量（Glyph metrics）打交道：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/33275873-d1a33c5e-d3ce-11e7-985d-5b8e7bc8b9e1.png" alt="" /></p>

<p>由上图可知，一个字符最高点到基线的偏移叫做 Ascent，最低点到基线的偏移叫做 Descent，单行的行高 Line Height 由 Ascent、Descent 与 Line Gap 相加得出。</p>

<h4>文本的绘制</h4>

<p><img src="https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/core_text_arch_2x.png" alt="" /></p>

<p>Core Text 需要使用 CTFramesetter 对文本进行布局，位于上图中最顶端的 CTFramesetter，它要求以 Attributed String 和绘制区域的形状（CGPath）作为入参，来创建 CTFrame（可以不止一个 CTFrame） ，顾名思义，这就是文本布局所在的 frame，确定好绘制区域后，framesetter 就能将段落样式（NSParagraphStyle）的 lineBreakMode、lineSpacing 等属性应用于此。
这里有必要提一下 CTRun，从 CTRun 我们可以获取许多重要的属性，这在开发排版功能的时候非常有用，下面这张图有助于我们了解什么是 CTRun：</p>

<p><img src="https://user-images.githubusercontent.com/5633917/33275976-20fb6826-d3cf-11e7-9add-089329fb271d.png" alt="" /></p>

<p>这一行文本可以认为是一个 CTLine 对象，由从左往右的顺序依次包含了默认字体样式、加粗字体样式、默认字体样式、小字号蓝色样式、正常字号蓝色样式和默认字体样式共 6 种 Attributed。每一种样式的字符则表示一个 CTRun 对象。</p>

<p>了解了这些概念之后，就可以实现排版功能了。</p>

<h3>实现一个简单的 AttributedLabel</h3>

<p>进入正题之前，再储备些基础知识。</p>

<h5>Core Foundation 内存管理规则</h5>

<p>Core Text 使用了 Core Foundation 基于 C 语言的 API，所以需要遵循 Core Foundation 的内存管理规则。</p>

<ul>
<li>创建方法名中含有 “Create” 或 “Copy”，需要调用 CFRelease 释放内存</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CTFramesetterRef</span> <span class="n">CTFramesetterCreateWithAttributedString</span><span class="p">(</span>
</span><span class='line'><span class="n">CFAttributedStringRef</span> <span class="n">string</span> <span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>返回 CF 对象方法名中不含 “Create” 和 “Copy”，无需手动释放内存</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CFStringRef</span> <span class="n">CFAttributedStringGetString</span><span class="p">(</span><span class="n">CFAttributedStringRef</span> <span class="n">aStr</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>明白了这点，就对项目中什么时候该调用 CFRelease，什么时候不该调用做到心中有数了。</p>

<p>关于 <code>__bridge</code> 关键字</p>

<ul>
<li><code>__bridge</code> 只是声明类型转变，但不做内存管理规则的转变。</li>
<li><code>__bridge_retained</code> 表示指针类型转变的同时，将内存管理由原来的 Objective-C 交给 Core Foundation 处理，即 ARC to MRC。</li>
<li><code>__bridge_transfer</code> 表示内存管理由 Core Foundation 交给 Objective-C，即 MRC to ARC。</li>
</ul>


<h5>关于坐标系</h5>

<p>另外，Core Text 最初是设计给 mac 的，它的坐标系是 mac 坐标系（原点在左下角），所以通常需要对坐标进行翻转，这也是下文提及为什么需要翻转的缘由。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CGContextSetTextMatrix</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">CGAffineTransformIdentity</span><span class="p">);</span>
</span><span class='line'><span class="n">CGContextTranslateCTM</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>
</span><span class='line'><span class="n">CGContextScaleCTM</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h5>借助下面这张类关系图让我们直奔主题。</h5>

<p><img src="https://user-images.githubusercontent.com/5633917/33276265-09758578-d3d0-11e7-9690-db644433aeec.png" alt="" /></p>

<h4>1.堪当重任的 CALayer</h4>

<p>相对于 UIView，CALayer 通常是比较“轻”的，我们在日常开发中接触 layer 比较多的还是设置 cornerRadius、contents、mask 或者做个动画等，而在这个项目中，依靠 layer 的 <code>- (void)display</code> 方法，让其充当了一个 “桥梁” 的作用。</p>

<p>先来了解下 <code>- (void)display</code> 方法，如文档里所说，layer 会在适当的时候调用该方法来更新 layer 的 contents，但是并不建议直接调用该方法，子类化可以重写该方法，并能直接设置 layer 的 contents。文档的最后一句话大大盘活了自定义的 AttributedLabel，当 AttributedLabel 需要改变 text、frame、font、attributedString…时，AttributedLabel 不用关心具体的绘制，只需告知下 layer 需要 display 即可。由于将 AttributedLabel 的 <code>+ (Class)layerClass</code> 返回了子类化的 layer。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">+</span> <span class="p">(</span><span class="kt">Class</span><span class="p">)</span><span class="nf">layerClass</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">ZPLabelLayer</span> <span class="n">class</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>layer 的 delegate 对象就是 AttributedLabel，所以 layer 就能通过它的 delegate 属性获取到 AttributedLabel 的上述属性，进一步调用 Core Text 绘制出新的 contents 进行设置。这是做这个项目时最干净利落的一个地方。</p>

<h4>2.文本高亮交互的处理</h4>

<p>如果无需处理高亮交互等定制（截断、附件）效果，我们在拿到 NSAttributedString 和 CGPath 即可将文本绘制到 context 上。对于链接而言，虽然我们能通过 NSDataDetector 标记出文本中哪些地方需要高亮显示，但是需求往往要能对链接进行点击跳转，在使用 CTFrameDraw 方法绘制文本时，既不知道高亮过的文本位置，更无法谈及对高亮文本的交互响应了。</p>

<p>幸运的是，Core Text 另外还有个稍微复杂点的绘制方法 CTLineDraw，从名字可以得知它是用来绘制 line 的，感观上要比 CTFrameDraw 的确要精细许多。我们先看看添加高亮功能的实现思路。</p>

<ul>
<li>能响应点击的回调 block</li>
<li>接受高亮颜色、range、backgroundColor 等</li>
</ul>


<p>假设上述高亮相关属性都由 AttributedLabel 处理，使用者每次添加高亮不仅要让 AttributedLabel 改变内部文本的 Attributed 属性，考虑到一段文本可能有多处高亮，其本身也还需要维护一个处理高亮的数组。然而对设置高亮来说，这本就是 NSAttributedString 能做到的事，若让 UI 层来处理这些逻辑并不是很好。再者，对于调用者来说，虽然可以将上述属性封装成 model 方便 AttributedLabel 使用，但如果想复用 NSAttributedString 就变得不可能了。看来交由 NSAttributedString 来处理高亮相关属性是最合适不过的了，这里通过创建 NSAttributedString 的 category 和  AssociatedObject 满足了需求。</p>

<p>最终从 NSAttributedString 中获取到高亮的 ranges，再配合 CTLineDraw 绘制行的时候获取到 run （文章前面介绍）的 range，先来看看代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">ranges</span> <span class="o">=</span> <span class="n">attributedStr</span><span class="p">.</span><span class="n">highlightRangeArray</span><span class="p">;</span>  <span class="c1">// 获取 ranges</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="c1">// 遍历行</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">CFIndex</span> <span class="n">lineIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">lineIndex</span> <span class="o">&lt;</span> <span class="n">numberOfLines</span><span class="p">;</span> <span class="n">lineIndex</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">CTLineRef</span> <span class="n">line</span> <span class="o">=</span> <span class="n">CFArrayGetValueAtIndex</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">lineIndex</span><span class="p">);</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>    <span class="n">CFArrayRef</span> <span class="n">runs</span> <span class="o">=</span> <span class="n">CTLineGetGlyphRuns</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
</span><span class='line'>    <span class="c1">// 遍历行的每一个 run</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">CFArrayGetCount</span><span class="p">(</span><span class="n">runs</span><span class="p">);</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">...</span>
</span><span class='line'>        <span class="n">CFRange</span> <span class="n">range</span> <span class="o">=</span> <span class="n">CTRunGetStringRange</span><span class="p">(</span><span class="n">run</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>             <span class="k">for</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">rangeString</span> <span class="k">in</span> <span class="n">self</span><span class="p">.</span><span class="n">ranges</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">NSRange</span> <span class="n">hightlightRange</span> <span class="o">=</span> <span class="n">NSRangeFromString</span><span class="p">(</span><span class="n">rangeString</span><span class="p">);</span>
</span><span class='line'>                    <span class="n">NSRange</span> <span class="n">lineRange</span> <span class="o">=</span> <span class="n">NSMakeRange</span><span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">location</span><span class="p">,</span> <span class="n">range</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
</span><span class='line'>            <span class="c1">// 得到属于高亮的 range</span>
</span><span class='line'>                    <span class="k">if</span> <span class="p">(</span><span class="n">NSIntersectionRange</span><span class="p">(</span><span class="n">hightlightRange</span><span class="p">,</span> <span class="n">lineRange</span><span class="p">).</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></code></pre></td></tr></table></div></figure>


<p>接下来获取具体的 CGRect，注意在获取 CGRect 时还需将坐标翻转：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CGAffineTransform</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">CGAffineTransformMakeTranslation</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">contentHeight</span><span class="p">);</span>
</span><span class='line'><span class="n">transform</span> <span class="o">=</span> <span class="n">CGAffineTransformScale</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="mf">1.f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.f</span><span class="p">);</span>
</span><span class='line'><span class="n">CGRect</span> <span class="n">flipRect</span> <span class="o">=</span> <span class="n">CGRectApplyAffineTransform</span><span class="p">(</span><span class="n">runRect</span><span class="p">,</span> <span class="n">transform</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 保存链接的CGRect</span>
</span><span class='line'><span class="n">NSRange</span> <span class="n">nRange</span> <span class="o">=</span> <span class="n">NSMakeRange</span><span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">location</span><span class="p">,</span> <span class="n">range</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
</span><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">framesDict</span><span class="p">[</span><span class="n">NSStringFromRange</span><span class="p">(</span><span class="n">nRange</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSValue</span> <span class="n">valueWithCGRect</span><span class="o">:</span><span class="n">flipRect</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>到这已经基本获取到高亮文本的位置，为什么说是基本呢？因为漏了个链接换行的问题，当链接换行显示时，就会产生多个 CTRun 对象，这些 CTRun 对应的 CGRect 都会存在 framesDict 中，当用户点击换行的链接某部分（range）时，它只能响应到 framesDict 中的一个 CGRect，而正确的做法是应该响应某个链接在 framesDict 中的所有 CGRect，只有这样才能完整的高亮出一条链接的所有部分，本质就是要将来自同一条链接的若干 CGRect 关联起来。</p>

<p>说了这么多，实现起来却不困难，这里采用了链接的 range 做为 key，CGRect 的数组做为 value，然后判断用户的 range 在不在链接的 range 中，若属于某条链接的 range，通过链接的 range 取出 CGRect 的数组渲染即可。</p>

<h4>3.字符串截断的处理</h4>

<p>当 UILabel 显示不全字符串的时候，系统会在文本的最后添加“…”。同样，AttributedLabel 也提供了添加“…”的默认处理，并在此基础上提供了让用户自定义截断内容的功能。这里的实现并不难，直接截取最后一行的文本，再不断倒序删除最后一行的字符直到最后一行能容纳得下 TruncationText 为止。</p>

<p>首先我们还是要调用 CoreText 的 API 获取到最后一行的 range：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CTFrameRef</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">CTFramesetterCreateFrame</span><span class="p">(</span><span class="n">framesetter</span><span class="p">,</span> <span class="n">CFRangeMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="n">self</span> <span class="n">length</span><span class="p">]),</span> <span class="n">path</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">CFArrayRef</span> <span class="n">lines</span> <span class="o">=</span> <span class="n">CTFrameGetLines</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>
</span><span class='line'><span class="n">NSInteger</span> <span class="n">numberOfLines</span> <span class="o">=</span> <span class="n">CFArrayGetCount</span><span class="p">(</span><span class="n">lines</span><span class="p">);</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="n">NSInteger</span> <span class="n">lastLineIndex</span> <span class="o">=</span> <span class="n">numberOfLines</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">numberOfLines</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="n">CTLineRef</span> <span class="n">line</span> <span class="o">=</span> <span class="n">CFArrayGetValueAtIndex</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">lastLineIndex</span><span class="p">);</span>
</span><span class='line'><span class="n">CFRange</span> <span class="n">lastLineRange</span> <span class="o">=</span> <span class="n">CTLineGetStringRange</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>接着使用最后一行的 range 从 AttributedString 中获取到子文本：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//截到最后一行</span>
</span><span class='line'><span class="n">NSUInteger</span> <span class="n">truncationAttributePosition</span> <span class="o">=</span> <span class="n">lastLineRange</span><span class="p">.</span><span class="n">location</span> <span class="o">+</span> <span class="n">lastLineRange</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
</span><span class='line'><span class="n">NSMutableAttributedString</span> <span class="o">*</span><span class="n">cutAttributedString</span> <span class="o">=</span> <span class="p">[[</span><span class="n">self</span> <span class="n">attributedSubstringFromRange</span><span class="o">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">truncationAttributePosition</span><span class="p">)]</span> <span class="n">mutableCopy</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="n">NSMutableAttributedString</span> <span class="o">*</span><span class="n">lastLineAttributeString</span> <span class="o">=</span> <span class="p">[[</span><span class="n">cutAttributedString</span> <span class="n">attributedSubstringFromRange</span><span class="o">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="n">lastLineRange</span><span class="p">.</span><span class="n">location</span><span class="p">,</span> <span class="n">lastLineRange</span><span class="p">.</span><span class="n">length</span><span class="p">)]</span> <span class="n">mutableCopy</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>递归调用每次删除子文本最后一个字符的方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSMutableAttributedString</span> <span class="o">*</span><span class="p">)</span><span class="nf">handleLastLineAttributeString:</span><span class="p">(</span><span class="n">NSMutableAttributedString</span> <span class="o">*</span><span class="p">)</span><span class="nv">attributeString</span> <span class="nf">withTruncationText:</span><span class="p">(</span><span class="n">NSMutableAttributedString</span> <span class="o">*</span><span class="p">)</span><span class="nv">truncationText</span> <span class="nf">width:</span><span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nv">width</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CTLineRef</span> <span class="n">truncationToken</span> <span class="o">=</span> <span class="n">CTLineCreateWithAttributedString</span><span class="p">((</span><span class="n">CFAttributedStringRef</span><span class="p">)</span><span class="n">attributeString</span><span class="p">);</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">lastLineWidth</span> <span class="o">=</span> <span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span><span class="n">CTLineGetTypographicBounds</span><span class="p">(</span><span class="n">truncationToken</span><span class="p">,</span> <span class="nb">nil</span><span class="p">,</span> <span class="nb">nil</span><span class="p">,</span><span class="nb">nil</span><span class="p">);</span>
</span><span class='line'>    <span class="n">CFRelease</span><span class="p">(</span><span class="n">truncationToken</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">lastLineWidth</span> <span class="o">&gt;</span> <span class="n">width</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSString</span> <span class="o">*</span><span class="n">lastLineString</span> <span class="o">=</span> <span class="n">attributeString</span><span class="p">.</span><span class="n">string</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">NSRange</span> <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="n">lastLineString</span> <span class="n">rangeOfComposedCharacterSequencesForRange</span><span class="o">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="n">lastLineString</span><span class="p">.</span><span class="n">length</span> <span class="o">-</span> <span class="n">truncationText</span><span class="p">.</span><span class="n">string</span><span class="p">.</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)];</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">[</span><span class="n">attributeString</span> <span class="n">deleteCharactersInRange</span><span class="o">:</span><span class="n">r</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>       <span class="k">return</span> <span class="p">[</span><span class="n">self</span> <span class="n">handleLastLineAttributeString</span><span class="o">:</span><span class="n">attributeString</span> <span class="n">withTruncationText</span><span class="o">:</span><span class="n">truncationText</span> <span class="n">width</span><span class="o">:</span><span class="n">width</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">attributeString</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>之所以递归删除是因为试过一下子截取 truncationText 的长度时会有用 <code>CTLineGetTypographicBounds</code> 计算宽度不准确的问题，不清楚这是否与不同字符的高矮胖瘦有关，如果你有更好的方法，欢迎 pr !!!</p>

<h4>4.为字符串添加附件</h4>

<p>我最初是想用“…查看更多”截断文本，再剔除“…”后，仅把“查看更多”当作可支持高亮点击的文本，然而在实现过程中大大破坏了下边两个方法的通用性，甚至实现的效果还差强人意。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">zp_highlightColor:</span><span class="p">(</span><span class="n">UIColor</span> <span class="o">*</span><span class="p">)</span><span class="nv">highlightColor</span> <span class="nf">backgroundColor:</span><span class="p">(</span><span class="n">UIColor</span> <span class="o">*</span><span class="p">)</span><span class="nv">backgroundColor</span> <span class="nf">highlightRange:</span><span class="p">(</span><span class="n">NSRange</span><span class="p">)</span><span class="nv">highlightRange</span> <span class="nf">tapAction:</span><span class="p">(</span><span class="n">ZPTapHightlightBlock</span><span class="p">)</span><span class="nv">tapAction</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSMutableAttributedString</span> <span class="o">*</span><span class="p">)</span><span class="nf">zp_joinWithTruncationText:</span><span class="p">(</span><span class="n">NSMutableAttributedString</span> <span class="o">*</span><span class="p">)</span><span class="nv">truncationText</span> <span class="nf">textRect:</span><span class="p">(</span><span class="n">CGRect</span><span class="p">)</span><span class="nv">textRect</span> <span class="nf">maximumNumberOfRows:</span><span class="p">(</span><span class="n">NSInteger</span><span class="p">)</span><span class="nv">maximumNumberOfRows</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>通常实现某个功能感到别扭时，往往都是方法没用对。最终通过查询文档及资料发现 Core Text 竟还有个 CTRunDelegate 的对象，CTRunDelegate 是 CTRun 的 delegate，它可被用来修改布局时的字形信息（glyph metrics）， 比如控制字符的 ascent、descent、width 等。换句话说，我们可以“撑开”一个字符到我们想要的高宽，在这个占位字符之上就可以添加自定义的视图（比如 UIButton）。unicode 中恰好有空白字符 <code>\uFFFC</code> 的表示，我们在字符串适当的位置插入空白字符来占位，再获取到空白字符的 CGRect 信息，就可以添加子视图在这之上了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">zp_deallocCallback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ref</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">ZPTextRunDelegate</span> <span class="o">*</span><span class="n">delegate</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge_transfer</span> <span class="n">ZPTextRunDelegate</span> <span class="o">*</span><span class="p">)(</span><span class="n">ref</span><span class="p">);</span>
</span><span class='line'>    <span class="n">delegate</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="n">CGFloat</span> <span class="nf">zp_ascentCallback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ref</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">ZPTextRunDelegate</span> <span class="o">*</span><span class="n">delegate</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge</span> <span class="n">ZPTextRunDelegate</span> <span class="o">*</span><span class="p">)(</span><span class="n">ref</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">delegate</span><span class="p">.</span><span class="n">ascent</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="n">CGFloat</span> <span class="nf">zp_descentCallback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ref</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">ZPTextRunDelegate</span> <span class="o">*</span><span class="n">delegate</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge</span> <span class="n">ZPTextRunDelegate</span> <span class="o">*</span><span class="p">)(</span><span class="n">ref</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">delegate</span><span class="p">.</span><span class="n">descent</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="n">CGFloat</span> <span class="nf">zp_widthCallback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ref</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">ZPTextRunDelegate</span> <span class="o">*</span><span class="n">delegate</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge</span> <span class="n">ZPTextRunDelegate</span> <span class="o">*</span><span class="p">)(</span><span class="n">ref</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">delegate</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="n">CTRunDelegateCallbacks</span> <span class="n">callbacks</span><span class="p">;</span>
</span><span class='line'><span class="n">callbacks</span><span class="p">.</span><span class="n">version</span> <span class="o">=</span> <span class="n">kCTRunDelegateCurrentVersion</span><span class="p">;</span>
</span><span class='line'><span class="n">callbacks</span><span class="p">.</span><span class="n">dealloc</span> <span class="o">=</span> <span class="n">zp_deallocCallback</span><span class="p">;</span>
</span><span class='line'><span class="n">callbacks</span><span class="p">.</span><span class="n">getAscent</span> <span class="o">=</span> <span class="n">zp_ascentCallback</span><span class="p">;</span>
</span><span class='line'><span class="n">callbacks</span><span class="p">.</span><span class="n">getDescent</span> <span class="o">=</span> <span class="n">zp_descentCallback</span><span class="p">;</span>
</span><span class='line'><span class="n">callbacks</span><span class="p">.</span><span class="n">getWidth</span> <span class="o">=</span> <span class="n">zp_widthCallback</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后要注意的是 CTRunDelegate 需要实现代理的委托，在委托方法中，对象并不遵循 ARC 内存管理，这里封装了 ZPTextRunDelegate 来管理属性，使用 <code> __bridge_transfer</code>  进行内存的转换，避免了内存泄露和过早释放的 bug。获取附件的位置和高亮那块的处理类似，就不再赘述。</p>

<h3>总结</h3>

<p>本文记录了如何造一个 AttributedLabel 的轮子，相信读者结合代码一起看会发现实现简单的 Core Text 排版功能并不难，而笔者在剥离业务代码、实现通用性、封装工具类上还是遇到不少技术挑战。建议大家在平常开发中能多造点轮子锻炼锻炼技术，也能提高 iOS 技术社区的活力。同时希望大家在用惯了业界标准的 YYText 时，顺带了解下 Core Text 的使用流程。</p>

<p>Github 地址：<a href="https://github.com/hawk0620/PYQFeedDemo">https://github.com/hawk0620/PYQFeedDemo</a></p>
]]></content>
  </entry>
  
</feed>
