<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[陈浩的技术博客]]></title>
  <link href="http://hawk0620.github.io/atom.xml" rel="self"/>
  <link href="http://hawk0620.github.io/"/>
  <updated>2015-11-17T23:13:01+08:00</updated>
  <id>http://hawk0620.github.io/</id>
  <author>
    <name><![CDATA[Hawk0620]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[“探索向～iOS视频播放”]]></title>
    <link href="http://hawk0620.github.io/blog/2015/11/17/ios-play-video/"/>
    <updated>2015-11-17T21:50:18+08:00</updated>
    <id>http://hawk0620.github.io/blog/2015/11/17/ios-play-video</id>
    <content type="html"><![CDATA[<h4>从体验说起</h4>

<p>&emsp;&emsp;对比微信和Instagram可以发现播放视频的两个思路：微信的处理是把视频加载好后播放，这样确保了视频是完整的，用户很直观视频是否下载完成，不影响用户观看视频的体验；而Instagram的做法是边加载边播，当网络不给力的时候，视频就卡在那里，给用户增加了观看视频的焦虑，并且用户还得自己判断下视频是不是加载完成了，最不幸的是，当视频的网络请求不可达时，不能给出加载失败的提示引导用户重新加载，只能滑动列表触发刷新。</p>

<h4>播放视频的实现</h4>

<p>1、通过实践，我发现Instagram采用的应该是<code>AVPlayer</code>实现的。</p>

<!--more-->


<p><code>AVPlayerItem</code>可以通过远程URL创建出来，并且支持流的形式播放，还可以添加视频播放卡住和视频播放完成的两个观察者：</p>

<pre><code>[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(itemDidBufferPlaying:) name:AVPlayerItemPlaybackStalledNotification object:nil];
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(itemDidFinishPlaying:) name:AVPlayerItemDidPlayToEndTimeNotification object:nil];
</code></pre>

<p>但遗憾的是，我没有找到视频加载失败的观察者。</p>

<p>2、结合微信团队的技术分享<a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=207686973&amp;idx=1&amp;sn=1883a6c9fa0462dd5596b8890b6fccf6&amp;scene=0#wechat_redirect">链接</a>，得知微信的视频播放是采用<code>AVAssetReader</code>+<code>AVAssetReaderTrackOutput</code>，根据微信的思路，自己也尝试实现了一番：
buffer的转换：</p>

<pre><code>- (CGImageRef) imageFromSampleBuffer:(CMSampleBufferRef) sampleBuffer {
   CVImageBufferRef imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer);
   // Lock the base address of the pixel buffer
   CVPixelBufferLockBaseAddress(imageBuffer, 0);
   // Get the number of bytes per row for the pixel buffer
   size_t bytesPerRow = CVPixelBufferGetBytesPerRow(imageBuffer);
   // Get the pixel buffer width and height
   size_t width = CVPixelBufferGetWidth(imageBuffer);
   size_t height = CVPixelBufferGetHeight(imageBuffer);
   //Generate image to edit
   unsigned char* pixel = (unsigned char *)CVPixelBufferGetBaseAddress(imageBuffer);
   CGColorSpaceRef colorSpace=CGColorSpaceCreateDeviceRGB();
   CGContextRef context=CGBitmapContextCreate(pixel, width, height, 8, bytesPerRow, colorSpace, kCGBitmapByteOrder32Little|kCGImageAlphaPremultipliedFirst);
   CGImageRef image = CGBitmapContextCreateImage(context);
   CGContextRelease(context);
   CGColorSpaceRelease(colorSpace);
   return image;
}
</code></pre>

<p>视频的解码：</p>

<pre><code>AVURLAsset *asset = [AVURLAsset URLAssetWithURL:[[NSURL alloc] initFileURLWithPath:path] options:nil];
NSError *error;
AVAssetReader* reader = [[AVAssetReader alloc] initWithAsset:asset error:&amp;error];
NSArray* videoTracks = [asset tracksWithMediaType:AVMediaTypeVideo];
AVAssetTrack* videoTrack = [videoTracks objectAtIndex:0];

int m_pixelFormatType = kCVPixelFormatType_32BGRA;
NSDictionary* options = [NSDictionary dictionaryWithObject:[NSNumber numberWithInt: (int)m_pixelFormatType] forKey:(id)kCVPixelBufferPixelFormatTypeKey];
AVAssetReaderTrackOutput* videoReaderOutput = [[AVAssetReaderTrackOutput alloc] initWithTrack:videoTrack outputSettings:options];
[reader addOutput:videoReaderOutput];
[reader startReading];

// 读取视频每一个buffer转换成CGImageRef
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
   CMSampleBufferRef audioSampleBuffer = NULL;
   while ([reader status] == AVAssetReaderStatusReading &amp;&amp; videoTrack.nominalFrameRate &gt; 0) {
   CMSampleBufferRef sampleBuffer = [videoReaderOutput copyNextSampleBuffer];
   CGImageRef image = [self imageFromSampleBuffer:sampleBuffer];
   if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(mMovieDecoder:onNewVideoFrameReady:)]) {
        [self.delegate mMovieDecoder:self onNewVideoFrameReady:image];
    }
   if(sampleBuffer) {
       if(audioSampleBuffer) { // release old buffer.
            CFRelease(audioSampleBuffer);
            audioSampleBuffer = nil;
       }
       audioSampleBuffer = sampleBuffer;
   } else {
       break;
   }

// 休眠的间隙刚好是每一帧的间隔
   [NSThread sleepForTimeInterval:CMTimeGetSeconds(videoTrack.minFrameDuration)];
 }
 // decode finish
 float durationInSeconds = CMTimeGetSeconds(asset.duration);
  if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(mMovieDecoderOnDecodeFinished:duration:)]) {
     [self.delegate mMovieDecoderOnDecodeFinished:self duration:durationInSeconds];
   }
});
</code></pre>

<p>处理每一帧CGImageRef的回调：</p>

<pre><code>- (void)mMovieDecoder:(VideoDecoder *)decoder onNewVideoFrameReady:(CGImageRef)imgRef {
    __weak PlayBackView *weakView = self;
    dispatch_async(dispatch_get_main_queue(), ^{
        weakView.layer.contents = (__bridge id _Nullable)(imgRef);
    });
}
</code></pre>

<p>处理视频解码完成的回调：</p>

<pre><code>images即每一帧传上来的CGImageRef的数组
- (void)mMovieDecoderOnDecodeFinished:(VideoDecoder *)decoder images:(NSArray *)imgs duration:(float)duration {
    __weak PlayBackView *weakView = self;
    dispatch_async(dispatch_get_main_queue(), ^{
        weakView.layer.contents = nil;

        CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath: @"contents"];
        animation.calculationMode = kCAAnimationDiscrete;
        animation.duration = duration;
        animation.repeatCount = HUGE; //循环播放
        animation.values = images; // NSArray of CGImageRefs
        [weakView.layer addAnimation:animation forKey: @"contents"];
    });
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS拍视频前置摄像头翻转的解决]]></title>
    <link href="http://hawk0620.github.io/blog/2015/11/14/record-video-mirror/"/>
    <updated>2015-11-14T10:18:42+08:00</updated>
    <id>http://hawk0620.github.io/blog/2015/11/14/record-video-mirror</id>
    <content type="html"><![CDATA[<p>前不久在做iOS录制视频遇到了前置摄像头录制的时候视频翻转的问题，相比起以前我做拍照的翻转仅仅只需简单的把图片位置纠正：</p>

<pre><code>UIImage *newImage = [UIImage imageWithCGImage:[image CGImage] scale:1 orientation:UIImageOrientationLeftMirrored];
</code></pre>

<p>视频的翻转就比较麻烦，其大致思路是通过<code>CGAffineTransform</code>变换调整视频在屏幕中的位置，再使用<code>AVMutableVideoComposition</code>进行视频的重新组成，最后使用<code>AVAssetExportSession</code>进行视频的导出即可，以下是翻转以及裁剪出方形视频的代码：</p>

<!--more-->


<pre><code>// your own asset
AVAssetTrack *clipVideoTrack = [[asset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0];

AVMutableVideoComposition* videoComposition = [AVMutableVideoComposition videoComposition];
videoComposition.frameDuration = CMTimeMake(1, 30);

videoComposition.renderSize = CGSizeMake(clipVideoTrack.naturalSize.height, clipVideoTrack.naturalSize.height);

//create a video instruction
AVMutableVideoCompositionInstruction *instruction = [AVMutableVideoCompositionInstruction videoCompositionInstruction];
instruction.timeRange = CMTimeRangeMake(kCMTimeZero, CMTimeMakeWithSeconds(60, 30));

AVMutableVideoCompositionLayerInstruction* transformer = [AVMutableVideoCompositionLayerInstruction videoCompositionLayerInstructionWithAssetTrack:clipVideoTrack];
// 前方高能
CGAffineTransform finalTransform ＝ CGAffineTransformIdentity;
// 翻转，仅是前置摄像头需要
finalTransform = CGAffineTransformMakeScale(-1.0f, 1.0f);
// 视频竖直方向中间的位置
finalTransform = CGAffineTransformTranslate(finalTransform, clipVideoTrack.naturalSize.height, -(clipVideoTrack.naturalSize.width - clipVideoTrack.naturalSize.height) /2);
// finalTransform = CGAffineTransformTranslate(finalTransform, clipVideoTrack.naturalSize.height, 0);视频最顶部的位置
finalTransform = CGAffineTransformRotate(finalTransform, M_PI_2);
finalTransform = CGAffineTransformTranslate(finalTransform, 0.0f, clipVideoTrack.naturalSize.height);

[transformer setTransform:finalTransform atTime:kCMTimeZero];
instruction.layerInstructions = [NSArray arrayWithObject:transformer];
videoComposition.instructions = [NSArray arrayWithObject: instruction];

 // 导出
AVAssetExportSession *exporter = [[AVAssetExportSession alloc] initWithAsset:self.secondAsset presetName:AVAssetExportPresetHighestQuality] ;
exporter.videoComposition = videoComposition;
exporter.outputURL=[NSURL fileURLWithPath:outputPath];
exporter.outputFileType=AVFileTypeQuickTimeMovie;
[exporter exportAsynchronouslyWithCompletionHandler:^(void){
    // your handle with exporter.status
}];
</code></pre>

<p>补充一下，如果不是前置摄像头，如果要裁减出方形的视频只需要：</p>

<pre><code>CGAffineTransform t1 = CGAffineTransformMakeTranslation(track.naturalSize.height, -(track.naturalSize.width - track.naturalSize.height) /2 );
CGAffineTransform t2 = CGAffineTransformRotate(t1, M_PI_2);
</code></pre>

<p>如果需要拍出的视频自定义裁剪的区域，可以指定<code>cropRect</code>，代码如下：</p>

<pre><code>CGFloat cropOffX = cropRect.origin.x;
CGFloat cropOffY = cropRect.origin.y;
CGFloat cropWidth = cropRect.size.width;
CGFloat cropHeight = cropRect.size.height;
videoComposition.renderSize = CGSizeMake(cropWidth, cropHeight);
CGAffineTransform t1 = CGAffineTransformIdentity;
CGAffineTransform t2 = CGAffineTransformIdentity;
t1 = CGAffineTransformMakeTranslation(clipVideoTrack.naturalSize.height - cropOffX, 0 - cropOffY );
t2 = CGAffineTransformRotate(t1, M_PI_2 );
</code></pre>

<p>全文完～</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用CoreAnimation实现的播放按钮]]></title>
    <link href="http://hawk0620.github.io/blog/2015/11/07/player-button/"/>
    <updated>2015-11-07T19:42:48+08:00</updated>
    <id>http://hawk0620.github.io/blog/2015/11/07/player-button</id>
    <content type="html"><![CDATA[<p><img src="http://7xkwuq.com1.z0.glb.clouddn.com/player_button.gif" alt="alt tag" /></p>

<p> 最近做视频播放，需要做一个表示视频正在播放的按钮效果。记录一下实现这功能的经历。</p>

<!--more-->


<p> 首先我使用<code>CABasicAnimation</code>，在按钮的线条滑到下方终点时，通过动画完成的<code>delegate</code>方法:</p>

<pre><code>- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag
</code></pre>

<p> 让线条再到达上方的终点，并以此循环，最终实现线条一上一下的效果。但是在实际中，通过反复给<code>layer</code>添加动画，线条的速率得不到保证，最终会出现线条移动错乱的问题。</p>

<p> 在我陷入困苦之后，<code>CAKeyFrameAnimation</code>映入眼帘，我通过帧动画，把之前线条移到下方终点和上方终点的方法进行优化，帧动画的第一个位置是当前初始位置，其次是下方终点，上方终点，再是初始位置，并为每一帧动画计算了时间。通过帧动画实现了我的需求：）</p>

<p> 源码我已经放到了Github上面:
<a href="https://github.com/hawk0620/ZPPlayerButton">https://github.com/hawk0620/ZPPlayerButton</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义NavigationController转场动画]]></title>
    <link href="http://hawk0620.github.io/blog/2015/08/30/navigation-transition/"/>
    <updated>2015-08-30T08:29:21+08:00</updated>
    <id>http://hawk0620.github.io/blog/2015/08/30/navigation-transition</id>
    <content type="html"><![CDATA[<p> 这篇文章简单介绍下如何自定义UINavigationController转场动画，其大致的思路是:</p>

<!--more-->


<p> 1、实现<UINavigationControllerDelegate>协议的方法:</p>

<pre><code>- (id&lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController
                              animationControllerForOperation:(UINavigationControllerOperation)operation
                                           fromViewController:(UIViewController *)fromVC
                                             toViewController:(UIViewController *)toVC {
    if (fromVC == self &amp;&amp; [toVC isKindOfClass:[YourDestinationController class]]) {
        return [[TransitionAnimator alloc] init];
    }
    else {
        return nil;
    }
}
</code></pre>

<p>2、别忘了在viewDidAppear和viewWillDisappear方法中对delegate属性进行赋值：</p>

<pre><code>- (void)viewDidAppear:(BOOL)animated {
    [super viewDidAppear:animated];
    self.navigationController.delegate = self;
}

- (void)viewWillDisappear:(BOOL)animated {
    [super viewWillDisappear:animated];

    if (self.navigationController.delegate == self) {
        self.navigationController.delegate = nil;
    }
}
</code></pre>

<p>3、然后创建一个名为TransitionAnimator的NSObject子类，让其实现<UIViewControllerAnimatedTransitioning>协议：</p>

<pre><code>- (NSTimeInterval)transitionDuration:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext {
    return duration;
}
- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext {

}
</code></pre>

<p> 4、简单介绍下<code>animateTransition:</code>：</p>

<pre><code>// 返回当前ViewController
UIViewController *fromVC = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];
// 返回目标ViewController
UIViewController *toViewController = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];
// 返回容器视图
UIView *containerView = [transitionContext containerView];
// 返回动画时长
NSTimeInterval duration = [self transitionDuration:transitionContext];
// toViewController.view添加在containerView上
[containerView addSubview:toViewController.view];
</code></pre>

<p> 5、了解了这些基础知识之后，就可以自定义转场动画了，可以使用UIView类方法<code>animateWithDuration</code>，或者Core Animation添加动画:</p>

<pre><code>// 可以对view的alpha值，frame等属性进行
[UIView animateWithDuration:duration animations:^{

} completion:^(BOOL finished) {

    // 动画结束后别忘了告诉我们已经完成了～
    [transitionContext completeTransition:!transitionContext.transitionWasCancelled];
}];
</code></pre>

<p> 或者</p>

<pre><code>// 实现一个类似ping的转场
// -----动画开始------
UIBezierPath *circleMaskPathInitial = [UIBezierPath bezierPathWithOvalInRect:rect];
CGPoint extremePoint = CGPointMake(CGRectGetMidX(rect) - 0, CGRectGetMidY(rect) - CGRectGetHeight(toViewController.view.bounds));
CGFloat radius = sqrt((extremePoint.x*extremePoint.x) + (extremePoint.y*extremePoint.y));
UIBezierPath *circleMaskPathFinal = [UIBezierPath bezierPathWithOvalInRect:CGRectInset(rect, -radius, -radius)];

CAShapeLayer *maskLayer = [CAShapeLayer layer];
maskLayer.path = circleMaskPathFinal.CGPath;
toViewController.view.layer.mask = maskLayer;

CABasicAnimation *maskLayerAnimation = [CABasicAnimation animationWithKeyPath:@"path"];
maskLayerAnimation.fromValue = (__bridge id)(circleMaskPathInitial.CGPath);
maskLayerAnimation.toValue = (__bridge id)(circleMaskPathFinal.CGPath);
maskLayerAnimation.duration = duration;
maskLayerAnimation.delegate = self;
[maskLayer addAnimation:maskLayerAnimation forKey:@"path"];
// -----动画结束------

- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag {
    // 别忘了
    [self.transitionContext completeTransition:!transitionContext.transitionWasCancelled];
    [self.transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey].view.layer.mask = nil;
}
</code></pre>

<p> <img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/10/circle-interactive.gif" alt="" /></p>

<p> 虽然好像大致完成了自定义转场动画，但好像还是少了点什么～如果能在<code>popViewControllerAnimated</code>加上手势是不是更棒呢！</p>

<p> 先添加<code>interactivePopTransition</code>属性：</p>

<pre><code>@property (nonatomic, strong) UIPercentDrivenInteractiveTransition *interactivePopTransition;
</code></pre>

<p> 再实现<code>UINavigationControllerDelegate</code>另一个协议方法：</p>

<pre><code>- (id&lt;UIViewControllerInteractiveTransitioning&gt;)navigationController:(UINavigationController *)navigationController
                     interactionControllerForAnimationController:(id&lt;UIViewControllerAnimatedTransitioning&gt;)animationController {
    // Check if this is for our custom transition
    if ([animationController isKindOfClass:[YourCustomPopAnimator class]]) {
        return self.interactivePopTransition;
    }
    else {
        return nil;
    }
}
</code></pre>

<p>在<code>viewDidLoad</code>中添加手势：</p>

<pre><code>UIScreenEdgePanGestureRecognizer *popRecognizer = [[UIScreenEdgePanGestureRecognizer alloc] initWithTarget:self action:@selector(handlePopRecognizer:)];
popRecognizer.edges = UIRectEdgeLeft;
[self.view addGestureRecognizer:popRecognizer];
</code></pre>

<p>并实现手势方法：</p>

<pre><code>- (void)handlePopRecognizer:(UIScreenEdgePanGestureRecognizer*)recognizer {
    CGFloat progress = [recognizer translationInView:self.view].x / (self.view.bounds.size.width * 1.0);
    progress = MIN(1.0, MAX(0.0, progress));

    if (recognizer.state == UIGestureRecognizerStateBegan) {
        // Create a interactive transition and pop the view controller
        self.interactivePopTransition = [[UIPercentDrivenInteractiveTransition alloc] init];
        [self.navigationController popViewControllerAnimated:YES];
    }
    else if (recognizer.state == UIGestureRecognizerStateChanged) {
        // Update the interactive transition's progress
        [self.interactivePopTransition updateInteractiveTransition:progress];
    }
    else if (recognizer.state == UIGestureRecognizerStateEnded || recognizer.state == UIGestureRecognizerStateCancelled) {
        // Finish or cancel the interactive transition
        if (progress &gt; 0.5) {
            [self.interactivePopTransition finishInteractiveTransition];
        }
        else {
            [self.interactivePopTransition cancelInteractiveTransition];
        }

        self.interactivePopTransition = nil;
    }

}
</code></pre>

<p>最后推荐两篇更详细的教程：</p>

<p>1、<a href="http://dativestudios.com/blog/2013/09/29/interactive-transitions/">interactive-transitions</a>
2、<a href="http://www.raywenderlich.com/86521/how-to-make-a-view-controller-transition-animation-like-in-the-ping-app">实现ping转场动画</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 线程同步: @synchronized指令]]></title>
    <link href="http://hawk0620.github.io/blog/2015/06/02/ios-xian-cheng-tong-bu-at-synchronizedguan-jian-zi/"/>
    <updated>2015-06-02T07:59:59+08:00</updated>
    <id>http://hawk0620.github.io/blog/2015/06/02/ios-xian-cheng-tong-bu-at-synchronizedguan-jian-zi</id>
    <content type="html"><![CDATA[<p> 在之前的一个app中，因为对多线程同步的处理不够好，在某些极端情况下app会发生crash。本文简单介绍一下如何使用<code>@synchronized</code>指令来实现线程安全。苹果文档中对<code>@synchronized</code>指令的说明是：</p>

<p>1.<code>@synchronized</code>指令是Objective-C代码中快捷创建互斥锁的一种方式；</p>

<p>2.<code>@synchronized</code>指令像任何其他的互斥锁一样，防止同一时间不同的线程获取相同的锁。</p>

<p><code>@synchronized</code>指令的使用很简单，只需要传一个参数即可：</p>

<pre><code>@synchronized(key) { 
    // thread-safe code goes here 
}
</code></pre>

<!--more-->


<p>一个简单的例子：</p>

<p>定义一个全局的数组变量</p>

<pre><code>NSMutableArray *array;
</code></pre>

<p>初始化该数组</p>

<pre><code>array = [NSMutableArray arrayWithCapacity:5];
for (int i = 0; i &lt; 5; i++) {
    [array addObject:[NSString stringWithFormat:@"array-%i", i]];
}
</code></pre>

<p>创建更新数组的方法</p>

<pre><code>- (void)updateArray:(NSString *)value {

    for (int j = 0; j &lt; array.count; j++) {

        NSString *currentObject = [array objectAtIndex:j];
        [array replaceObjectAtIndex:j withObject:[currentObject stringByAppendingFormat:@"-%@", value]];

        NSLog(@"%@", [array objectAtIndex:j]);
    }
}
</code></pre>

<p>在不同的线程中调用修改数组的方法</p>

<pre><code>NSString *bla = @"bla";
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    [self updateArray:bla];
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    [self updateArray:bla];
}); 
</code></pre>

<p>得到如下结果</p>

<pre><code>array-0-bla
array-0-bla
array-1-bla
array-1-bla-bla
array-2-bla-bla
array-2-bla
array-3-bla
array-3-bla-bla
array-4-bla
array-4-bla-bla
</code></pre>

<p>显而易见，两个线程在争夺资源，当两个线程彼此作用时可能会导致app的crash。下面，修改一下更新数组的方法：</p>

<pre><code>- (void)updateArray:(NSString *)value {

    @synchronized (value) {
        for (int j = 0; j &lt; array.count; j++) {

            NSString *currentObject = [array objectAtIndex:j];
            [array replaceObjectAtIndex:j withObject:[currentObject stringByAppendingFormat:@"-%@", value]];

            NSLog(@"%@", [array objectAtIndex:j]);
        }
    }
}
</code></pre>

<p>看看结果：</p>

<pre><code>array-0-bla
array-1-bla
array-2-bla
array-3-bla
array-4-bla
array-0-bla-bla
array-1-bla-bla
array-2-bla-bla
array-3-bla-bla
array-4-bla-bla
</code></pre>

<p>这下感觉醒目多了～原因就是<code>@synchronized</code>指令的代码块暂停了其中一个线程，允许另一个线程访问代码块，一旦另一个线程完成工作，就取消暂停。</p>

<p>注意了，如果你使用相同的对象作为<code>@synchronized</code>的key，那么线程将会被暂停（正如刚才所见）。假如使用不同的对象作为<code>@synchronized</code>的key：</p>

<pre><code>NSString *bla = @"bla";
NSString *ola = @"ola";
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    [self updateArray:bla];
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    [self updateArray:ola];
});
</code></pre>

<p>再看看结果：</p>

<pre><code>array-0-bla
array-0-ola
array-1-bla
array-1-bla-ola
array-2-bla
array-2-bla-ola
array-3-bla
array-3-bla-ola
array-4-bla
array-4-bla-ola
</code></pre>

<p>像这种出现多个key的情况，使用</p>

<pre><code>@synchronized (array) { 
    ...
</code></pre>

<p>替换</p>

<pre><code>@synchronized (value) { 
    ...
</code></pre>

<p>这下妥妥了：</p>

<pre><code>array-0-bla
array-1-bla
array-2-bla
array-3-bla
array-4-bla
array-0-bla-ola
array-1-bla-ola
array-2-bla-ola
array-3-bla-ola
array-4-bla-ola
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GCD(semaphore)的日常]]></title>
    <link href="http://hawk0620.github.io/blog/2014/09/20/dispatch-semaphore/"/>
    <updated>2014-09-20T19:36:00+08:00</updated>
    <id>http://hawk0620.github.io/blog/2014/09/20/dispatch-semaphore</id>
    <content type="html"><![CDATA[<p> 当代码块在执行一些特定操作时，比如异步处理，有时需要等待代码块是否执行完成，这时可以通过<code>GCD</code>来帮助我们实现。</p>

<!--more-->


<h3>dispatch_semaphore简介</h3>

<p> <code>dispatch_semaphore_create</code>创建一个带初始值的semaphore；</p>

<p> <code>dispatch_semaphore_signal</code>增加semaphore的计数，并发送semaphore信号；</p>

<p> <code>dispatch_semaphore_wait</code>减少semaphore的计数，并等待semaphore信号的到达。</p>

<p> 示例代码：</p>

<pre><code>dispatch_semaphore_t sem = dispatch_semaphore_create(0);

[self singleBlock:^(id param){
    // your codes...
    dispatch_semaphore_signal(sem);
}];

dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSURLSession的日常]]></title>
    <link href="http://hawk0620.github.io/blog/2014/07/27/daily-nsurlsession/"/>
    <updated>2014-07-27T13:42:05+08:00</updated>
    <id>http://hawk0620.github.io/blog/2014/07/27/daily-nsurlsession</id>
    <content type="html"><![CDATA[<p> 在使用<code>NSURLSessionTaskDelegate</code>的时候，一开始并没有进入<code>URLSession:task:didCompleteWithError:</code>回调，阅读苹果给出的文档之后，成功解决。</p>

<!--more-->


<h3>NSURLSession简介</h3>

<p> <code>NSURLSession</code>是iOS7带来的诸多新特性之一，旨在替换<code>NSURLConnection</code>。<code>NSURLSession</code>的使用非常简单，步骤如下：</p>

<p> 1.创建并配置<code>NSURLSessionConfiguration</code>;</p>

<p> 2.通过步骤一的configuration创建<code>NSURLSession</code>;</p>

<p> 3.创建相应sessionTask(data、upload or download);</p>

<p> 4.调用<code>resume</code>启动task。</p>

<p> 给出一些例子代码：</p>

<pre><code>NSData *imageData = UIImageJPEGRepresentation([UIImage imageNamed:@"panda.jpg"], 0.6);

NSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration];
config.HTTPMaximumConnectionsPerHost = 1;
 [config setHTTPAdditionalHeaders:@{@"example_appkey": @"jfdeh79685eun"}];

NSURLSession *upLoadSession = [NSURLSession sessionWithConfiguration:config];
NSURL *url = [NSURL URLWithString:@"http://example.com"];
NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url];
[request setHTTPMethod:@"PUT"];

NSURLSessionUploadTask *uploadTask = [upLoadSession uploadTaskWithRequest:request fromData:imageData completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
    NSHTTPURLResponse *httpResp = (NSHTTPURLResponse*) response;
    if (!error  &amp;&amp; httpResp.statusCode == 200) {
        //handle...
    }
}];

[[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:YES];
[_uploadTask resume];
</code></pre>

<h2>使用NSURLSessionTaskDelegate</h2>

<p> 修改创建uploadSession方法：</p>

<pre><code>NSURLSession *upLoadSession = [NSURLSession sessionWithConfiguration:config delegate:self delegateQueue:nil];
</code></pre>

<p> 实现<code>&lt;NSURLSessionTaskDelegate&gt;</code>，该委托提供出了能计算上传进度的方法，代码如下：</p>

<pre><code>- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSent totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend
{
    NSLog(@"progress:%f",(double)totalBytesSent / (double)totalBytesExpectedToSend);
}
</code></pre>

<p> 将创建uploadTask方法更改为:</p>

<pre><code>NSURLSessionUploadTask *uploadTask = [upLoadSession uploadTaskWithRequest:request fromData:imageData];
</code></pre>

<p> 当然还有sessionTask完成时的回调：</p>

<pre><code>- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error
{
    dispatch_async(dispatch_get_main_queue(), ^{
        [[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:NO];
    });
    if (!error) {
        //handle..
    } else {
        // Alert for error
    }
}
</code></pre>

<p> 但是该委托方法没有被调用。苹果文档指出，如果使用自定义的委托来获取数据，那么以下方法必须被实现：</p>

<p> <code>URLSession:dataTask:didReceiveData:</code> 一点一点地从你发出地请求中取回数据；
 <code>URLSession:task:didCompleteWithError:</code> 数据被完全接收。</p>

<p> 由此可以看出，还需要实现<code>&lt;NSURLSessionDataDelegate&gt;</code>：</p>

<pre><code>-(void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data
{

}
</code></pre>

<p> 至此，成功进入<code>URLSession:task:didCompleteWithError:</code>。</p>
]]></content>
  </entry>
  
</feed>
