<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[陈浩的技术博客]]></title>
  <link href="http://hawk0620.github.io/atom.xml" rel="self"/>
  <link href="http://hawk0620.github.io/"/>
  <updated>2016-01-10T19:34:08+08:00</updated>
  <id>http://hawk0620.github.io/</id>
  <author>
    <name><![CDATA[Hawk0620]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Objective-C序列化库protobuf的安装]]></title>
    <link href="http://hawk0620.github.io/blog/2016/01/10/protobuf-objc/"/>
    <updated>2016-01-10T17:59:29+08:00</updated>
    <id>http://hawk0620.github.io/blog/2016/01/10/protobuf-objc</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;protobuf是google开源的二进制序列化库，对网络传输或是流量有较高要求的移动应用可以使用二进制协议，而非文本协议，这时protobuf将是不错的选择。</p>

<!--more-->


<p>&emsp;&emsp;下面简单介绍下Mac系统下Objective-C语言的protobuf的安装：</p>

<p>1、在<a href="https://github.com/google/protobuf/releases">protobuf</a>下载面向Objective-C的protobuf库</p>

<p>2、cd到下载的目录，执行<code>./autogen.sh</code></p>

<p>3、再依次执行</p>

<pre><code>$ ./configure
$ make
$ make check
$ sudo make install
$ sudo ldconfig # refresh shared library cache.        
</code></pre>

<p>4、再执行<code>objectivec/DevTools/full_mac_build.sh</code>，执行完后会看到src目录下生成了protoc二进制文件</p>

<p>PS:如果执行过程遇到了</p>

<pre><code>native:
     [exec] xcode-select: error: tool 'xcodebuild' requires Xcode, but active developer directory '/Library/Developer/CommandLineTools' is a command line tools instance
</code></pre>

<p>可能是Xcode只有command line tools，而没有完整的Xcode UI，执行：
<code>brew install autoconf automake libtool gettext</code>即可。</p>

<p>5、如果一切顺利，那就恭喜你了，接下来可是收获的时刻了。我在src目录里创建了一个Person.proto的文件，并将以下内容拷贝进去：</p>

<pre><code>syntax = "proto2";

message Person {
  required string name = 1;
  required int32 id = 2;
  optional string email = 3;
}
</code></pre>

<p>注意：需要指明proto的语法规则是proto2还是proto3。</p>

<p>6、我在src目录下还创建了bulid/gen这样的目录，最后我在src目录的位置执行<code>protoc --proto_path=../src --objc_out=../src/build/gen ../src/Person.proto</code>，然后去bulid/gen/下找到你心仪的文件拖进项目使用吧（项目得引入了objc版的protobuf）。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2015年我读过的几本书]]></title>
    <link href="http://hawk0620.github.io/blog/2016/01/03/2015booklist/"/>
    <updated>2016-01-03T14:12:29+08:00</updated>
    <id>http://hawk0620.github.io/blog/2016/01/03/2015booklist</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;眨眼工作就快两个年头了，虽然在初创公司的经历有点坎坷，但是自身的成长却是多方面的，最大的转变是我不再唯技术论了，而是以一种玩的心态来做技术，关注起产品的交互、设计与体验，也认识到沟通是一项很重要的能力。下面介绍下过去一年对我产生影响的书吧：</p>

<!--more-->


<p>1、代码大全</p>

<p><img src="https://cloud.githubusercontent.com/assets/5633917/12077774/0eb669a8-b230-11e5-8875-d72917b8e196.jpg" alt="dd" /></p>

<p>ps:它是我从公司图书馆借来的，兴奋得在带回家的路上拍了下来。</p>

<p>这是本挺好的入门程序开发的书籍，讲述了很多编程规范，对养成良好的编码习惯很有帮助。</p>

<p>2、iOS开发进阶</p>

<p><img src="https://cloud.githubusercontent.com/assets/5633917/12077783/820060da-b230-11e5-8ccf-960af28f3ebb.jpg" alt="dd" /></p>

<p>介绍了很多工具集，开发一个iOS的方方面面，其中最推崇的就是Core Text一章。</p>

<p>3、iOS Core Animation</p>

<p><img src="https://cloud.githubusercontent.com/assets/5633917/12077788/9b7bbdd4-b230-11e5-8011-5143bb732526.jpg" alt="dd" /></p>

<p>从CALayer基础出发，完整地讲解了iOS动画的许多特性，但是缺乏实战案例。</p>

<p>4、AppCoda Beginning iOS 8 Programming with Swift</p>

<p><img src="https://cloud.githubusercontent.com/assets/5633917/12077797/ee139bb6-b230-11e5-8634-aee0a5714227.jpg" alt="dd" /></p>

<p>只能说是介绍如何用Swift做一个项目，缺乏深度。</p>

<p>5、The Swift Programming Language</p>

<p>苹果官方的语言书，怀着学C语言一样的初心去看。</p>

<p>6、WatchKit_by_Tutorial</p>

<p><img src="https://cloud.githubusercontent.com/assets/5633917/12077805/0fc0018c-b231-11e5-941c-30e9c735c18c.jpg" alt="dd" /></p>

<p>ps:上面说了这么多Swift&hellip;其实当时主管让我私下完成公司项目的APPLE Watch版，我在技术储备得差不多的时候，公司突然业务转型了，Watch版自然也不做了。</p>

<p>该书浅显易懂，一句话从零开发APPLE Watch。</p>

<p>7、微信力量</p>

<p><img src="https://cloud.githubusercontent.com/assets/5633917/12077813/73eed8c2-b231-11e5-86b7-6033c2526df1.jpg" alt="dd" /></p>

<p>开拓眼界的一本书，从而对微信团队更加肃然起敬。</p>

<p>8、Facebook效应</p>

<p><img src="https://cloud.githubusercontent.com/assets/5633917/12077818/a4151eb2-b231-11e5-8850-087517d7c4f6.jpg" alt="dd" /></p>

<p>让我跳出唯技术论的一本书，教会了我以一种玩的心态去做技术。</p>

<p>9、解忧杂货店</p>

<p><img src="https://cloud.githubusercontent.com/assets/5633917/12077829/f69e04d2-b231-11e5-828f-ceb5ee49ce0d.jpg" alt="dd" /></p>

<p>挺好看的一本小说。</p>

<p>&emsp;&emsp;目前正在拜读《iOS应用逆向工程》。希望2016年可以读更多的好书和开源代码～</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何实现方形图片裁剪器]]></title>
    <link href="http://hawk0620.github.io/blog/2016/01/01/crop-square-image/"/>
    <updated>2016-01-01T11:03:07+08:00</updated>
    <id>http://hawk0620.github.io/blog/2016/01/01/crop-square-image</id>
    <content type="html"><![CDATA[<h3>对微信方形图片裁剪器的剖析</h3>

<p>&emsp;&emsp;我在做的一个兴趣项目时需要将图片裁剪成方形，联想到微信也有裁剪方形图片的功能。微信—-更换头像—-从相册选择这一流程中会要求用户将已选的图片裁剪成方形。其顺滑的移动缩放图片体验，可以判断出应该是<code>UIScorllView</code>实现而非通过<code>UIPinchGestureRecognizer</code>和<code>UIPanGestureRecognizer</code>组合实现的。因为<code>UIScorllView</code>有一个<code>viewForZoomingInScrollView</code>代理方法，该方法能实现对图片的缩放，所以使用<code>UIScorllView</code>可以满足需求。</p>

<!--more-->


<h3>开始动手实现方形图片裁剪器</h3>

<p>&emsp;&emsp;有了以上的基础后，观察到在微信图片裁剪器中的图片是可以缩放到全屏的，即给我们很直观的感觉<code>UIScorllView</code>的<code>frame</code>应该是屏幕大小<code>CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height)</code>。</p>

<p>&emsp;&emsp;再创建好UIScrollView后加入UIImageView，<code>[self.scrollView addSubview:self.imageView];</code>，并且实现<code>UIScorllView</code>的代理方法。运行程序后，我发现UIImageView不会以屏幕中间的方形框作为移动边界，而是以屏幕作为移动的边界。想想也对，因为我把<code>UIScorllView</code>的<code>frame</code>设置为屏幕了。。。</p>

<p>&emsp;&emsp;这个时候我基本明白了<code>UIScorllView</code>的<code>frame</code>必须得是在屏幕中间的方形。在一番修改之后，我发现了基本上移动边界的问题解决了（下面会说没瑕疵是啥）。可是由于<code>UIScorllView</code>的<code>frame</code>不是全屏了，随之带来的问题是缩放或者移动的<code>UIImageView</code>超过了<code>UIScorllView</code>的<code>frame</code>就显示不了了。难道我又想错了吗？其实不然，不是还有个<code>clipsToBounds</code>属性嘛。</p>

<p>&emsp;&emsp;剩下的工作只有居中初次进入裁剪页面<code>UIImageView</code>，那么就居中<code>UIImageView</code>：</p>

<pre><code>self.imageView.center = CGPointMake(self.view.bounds.size.width/2.0, CGRectGetMidY(self.scrollView.frame) - CGRectGetMinY(self.scrollView.frame));
</code></pre>

<p>并且设置<code>UIScrollView</code>的<code>contentSize</code>:</p>

<pre><code>self.scrollView.contentSize = CGSizeMake(self.scrollView.bounds.size.width, self.scrollView.bounds.size.height);
</code></pre>

<p>&emsp;&emsp;这时终于可以长舒一口气了吧～编译运行：</p>

<p><img src="https://cloud.githubusercontent.com/assets/5633917/12069698/efbacbd6-b07f-11e5-8cd4-4c28b796920e.png" alt="dd" /></p>

<p>发现当图片的高度大于屏幕宽度时，<code>UIScrollView</code>的移动边界会出现图片顶端无法下移，而底端上移太多的问题。这时想起了<code>contentOffset</code>属性来设置高度大于宽度图片的居中位置：</p>

<pre><code>if (self.imageView.bounds.size.height &gt; viewWidth) {
    self.scrollView.contentOffset = CGPointMake(0, (self.imageView.frame.size.height - viewWidth)/2.0);
    self.scrollView.contentSize = CGSizeMake(self.scrollView.bounds.size.width, self.imageView.bounds.size.height);

} else {
    self.scrollView.contentSize = CGSizeMake(self.scrollView.bounds.size.width, self.scrollView.bounds.size.height);
    self.imageView.center = CGPointMake(viewWidth/2.0, CGRectGetMidY(self.scrollView.frame) - CGRectGetMinY(self.scrollView.frame));
}
</code></pre>

<p>大功告成！一个看似不复杂的图片裁剪器，里面却暗藏了许多小技巧。最后附上<a href="https://github.com/hawk0620/SquareCropDemo">源码链接</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSOperation初探]]></title>
    <link href="http://hawk0620.github.io/blog/2015/12/21/nsoperation/"/>
    <updated>2015-12-21T11:00:21+08:00</updated>
    <id>http://hawk0620.github.io/blog/2015/12/21/nsoperation</id>
    <content type="html"><![CDATA[<h3>NSOperation vs GCD</h3>

<p>&emsp;&emsp;如果对某个技术太执着，真的是件挺可怕的事情。在认识NSOperation之前，我单纯地以为GCD是多线程的不二法门，以致于只会无脑地：</p>

<pre><code>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
     // some handle
     dispatch_sync(dispatch_get_main_queue(), ^{
            // update ui
     });      
});
</code></pre>

<p>还有<code>dispatch_group_t</code>工作组，可以添加执行多个任务，通过<code>dispatch_group_notify</code>达到不阻塞的等待回调；<code>dispatch_source_t</code>轻易地监控许多诸如UNIX信号；<code>dispatch_barrier_async</code>解决恼人的读写问题等&hellip;</p>

<!--more-->


<p>我甚至认为：<code>NSOperation</code>是苹果为了造福小白而开发出的高级API。但是落实到具体的场景中，怎么方便地取消一个任务，怎么设置任务之间的依赖，怎么暂停一个任务、然后再继续，怎么设置最大的并发任务数&hellip;所有的这些，用GCD实现起来太麻烦了，但是<code>NSOperation</code>和<code>NSOperationQueue</code>就胜任这种场景。当然了，并不是GCD就一无是处了，根据具体场景配合使用是最佳的实现方案。</p>

<h3>NSOperation如何使用</h3>

<p>&emsp;&emsp;<code>NSOperation</code>的使用挺像Java里的<code>Runnable</code>，需要子类化来实现。有两个子类化<code>NSOperation</code>的方法：</p>

<p>1.重写main方法，这个方法的好处是简单，无需处理太多其它的状态值，只是不断地检测cancel状态：</p>

<pre><code>if (self.isCancelled)
     return;
</code></pre>

<p>最后，如果是通过delegate方式回调，需要在主线程回调出去：</p>

<pre><code>[(NSObject *)self.delegate performSelectorOnMainThread:@selector(xxxxxDidFinish:) withObject:self waitUntilDone:NO];
</code></pre>

<p>再说说重写main方法的坏处，它不是并发的，会阻塞主线程，所以需要加入到<code>NSOperationQueue</code>，而且它的灵活性低，在main方法返回的时候，operation就结束了。</p>

<p>2.比较推荐的是重写start方法，虽然会带来许多工作，比如KVO消息，但除了有较高的灵活性之外，它可以执行异步任务。</p>

<pre><code>- (void)start {
  @synchronized (self) {
    if ([self isCancelled])
    {
        [self willChangeValueForKey:@"isFinished"];
        self.finished = YES;
        [self didChangeValueForKey:@"isFinished"];
        return;
    }

    [self willChangeValueForKey:@"isExecuting"];
    self.executing = YES;
    [self didChangeValueForKey:@"isExecuting"];
    // your handle
    .....
  } 
}
</code></pre>

<p>然后在完成任务后（不管是fail还是finish），都需要再：</p>

<pre><code>[self willChangeValueForKey:@"isFinished"];
[self willChangeValueForKey:@"isExecuting"];

self.executing = NO;
self.finished = YES;

[self didChangeValueForKey:@"isExecuting"];
[self didChangeValueForKey:@"isFinished"];
</code></pre>

<p>处理的值，也可以通过block回调出去，所以建议有个类似这样的初始化方法：</p>

<pre><code>- (id)initWithRequest:(NSURLRequest *)request 
             progress:(DownloaderProgressBlock)progressBlock
            completed:(DownloaderCompletedBlock)completedBlock
            cancelled:(SDWebImageNoParamsBlock)cancelBlock
</code></pre>

<p>即使重写start方法的方式可以让任务异步，但还是推荐将operation加入到<code>NSOperationQueue</code>中，因为可以设置优先级，可以设置依赖等。</p>

<p>全文完～</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何在编译过程中改变app Icon]]></title>
    <link href="http://hawk0620.github.io/blog/2015/11/29/fun-with-app-icon/"/>
    <updated>2015-11-29T23:42:26+08:00</updated>
    <id>http://hawk0620.github.io/blog/2015/11/29/fun-with-app-icon</id>
    <content type="html"><![CDATA[<h3>为什么可以改变AppIcon</h3>

<p>&emsp;&emsp;为了说明为什么可以改变，首先来点题外话。相信我们都知道怎么给app换icon——把图片拖进工程的Images.xcassets->AppIcon.appiconset，很明显app icon位于<code>Project Name/Images.xcassets/AppIcon.appiconset/xxx.png</code>。当我们<code>cmd+r</code>运行工程时，会生成一个<code>/User/username/Library/Developer/.../Debug-iphoneos/Your Project Name.app</code>这样的路径，它包含了工程中所有的干货，当然app icons也在其中。</p>

<!--more-->


<p>假设你在工程中加了张名为AppIcon60x60@2x.png的icon，你可以在Build Phases点击+，再点击New Run Script，并添加如下代码：</p>

<pre><code>IFS=$'\n' #防止工程名中有空格引起的错误
echo $(find ${SRCROOT} -name "AppIcon60x60@2x.png")
echo "${BUILT_PRODUCTS_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}"
</code></pre>

<p>然后编译运行工程，你会在Xcode的<code>Report Navigator</code>（就是Xcode项目导航面板有着搜索、警告、断点那栏…）看到log出的信息。</p>

<p>&emsp;&emsp;竟然知道了icon的输入和输出路径，在编译过程中对输入来的icon进行加工，再输出到目标路径就可以对icon进行替换了。</p>

<h3>图片处理工具</h3>

<p>&emsp;&emsp;这里用到的图片加工工具是ImageMagick。你可以通过Homebrew安装：<code>brew update</code>、<code>brew install ImageMagick</code>、<code>brew install ghostscript</code>。安装成功后，打开Terminal然后cd到你含有图片的一个目录下：</p>

<pre><code>convert YourImageName.png -fill white -font Times-Bold -pointsize 18 -gravity south "Hello World" test.png
</code></pre>

<p>如果成功生成出了test.png，那么恭喜了！</p>

<h3>用Shell来搞定这一切</h3>

<p>我先贴上代码，然后再解释：</p>

<pre><code>IFS=$'\n'
buildNumber=$(/usr/libexec/PlistBuddy -c "Print CFBundleVersion" "${PROJECT_DIR}/${INFOPLIST_FILE}")
versionNumber=$(/usr/libexec/PlistBuddy -c "Print CFBundleShortVersionString" "${PROJECT_DIR}/${INFOPLIST_FILE}")
#1
PATH=${PATH}:/usr/local/bin
#2
function generateIcon () {
    BASE_IMAGE_NAME=$1

    TARGET_PATH="${BUILT_PRODUCTS_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/${BASE_IMAGE_NAME}"
    BASE_IMAGE_PATH=$(find ${SRCROOT} -name ${BASE_IMAGE_NAME})
    #3
    WIDTH=$(identify -format %w ${BASE_IMAGE_PATH})
    FONT_SIZE=$(echo "$WIDTH * .15" | bc -l)
    echo "font size $FONT_SIZE"
    #4
    if [ "${CONFIGURATION}" == "Debug" ]; then
    #5
    convert debugRibbon.png -resize ${WIDTH}x${WIDTH} resizedRibbon.png
    convert -background '#0008' -fill white -gravity center -size ${WIDTH}x40\
    -fill white -font Times-Boldr -pointsize ${FONT_SIZE} -gravity center caption:"${versionNumber}.${buildNumber}"\
    ${BASE_IMAGE_PATH} +swap -gravity south -composite /tmp/temp.png
    convert /tmp/temp.png resizedRibbon.png -composite ${TARGET_PATH}
    fi

}

#6
generateIcon "AppIcon60x60@2x.png"
generateIcon "AppIcon60x60@3x.png"
</code></pre>

<p>1、添加/user/local/bin路径到PATH变量，Homebrew也是安装在该路径下的。这样才能执行得了ImageMagick的命令；</p>

<p>2、以函数来接收不同设备的图片资源，作出分别的处理；</p>

<p>3、identify作为ImageMagick的函数来获取图片的information，使用<code>-format %w</code>的到图片的宽；</p>

<p>4、可以在Edit Scheme->Run->Info中指定CONFIGURATION；</p>

<p>5、接下去就是把debugRibbon.png缩小，将build number和version number加到图片上，最后合成并输出；</p>

<p>6、传入不同的icon文件名调用generateIcon。</p>

<p>最终效果：</p>

<p><img src="https://cloud.githubusercontent.com/assets/5633917/11458765/ae832a4c-9701-11e5-9a25-3d3a30099442.png" alt="alt tag" /></p>

<p>debugRibbon.png：</p>

<p><img src="https://cloud.githubusercontent.com/assets/5633917/11458863/c24d8a34-9703-11e5-8a9c-c301615f6dc5.png" alt="alt tag" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何在Objective-C的项目中使用Swift的第三方库]]></title>
    <link href="http://hawk0620.github.io/blog/2015/11/23/how-to-import-swift-into-objc/"/>
    <updated>2015-11-23T15:48:42+08:00</updated>
    <id>http://hawk0620.github.io/blog/2015/11/23/how-to-import-swift-into-objc</id>
    <content type="html"><![CDATA[<h3>让人惊艳的APNG</h3>

<p>&emsp;&emsp;以前只知道动图就是Gif，但是Gif有挺多缺点的，譬如有锯齿，不支持背景透明。后来知道了还有一种叫做APNG的动图格式，由于APNG是PNG的扩展，所以它支持半透明，自然就不会有锯齿的问题。要想在iOS中使用APNG动图，可以使用喵神（onevcat）用Swift开发的<a href="https://github.com/onevcat/APNGKit">APNGKit</a></p>

<!--more-->


<h3>神奇的Swift Bridging Header</h3>

<p>&emsp;&emsp;如果你的项目是Objective-C开发的（譬如像我手里的旧项目>_&lt;），其实也没有那么沮丧。接下来我将会简单说下步骤：</p>

<p>1、在Xcode中New File->Source->Header File，创建一个名为&#8221;YourProjectName-Bridging-Header.h&#8221;的头文件，注意此处一定要你的项目名称；</p>

<p>2、然后在build settings中搜索Swift Compiler，找到Objective-C Bridging Header选项，并修改它的值为你刚才创建的&#8221;ProjectName-Bridging-Header.h&#8221;；</p>

<p>3、接着再打开你的bridging header文件，并加入#import语句，譬如我使用APNGKit加入的是<code>#import "png.h"</code>；</p>

<p>4、还要在build settings中确保Product Module Name是你app target的名字，Defines Module置为YES，Embedded Content Contains Swift置为YES,Install Objective-C Compatibility Header置为YES；</p>

<p>5、虐心的事情终于结束了，最后在你想使用第三方库的.m文件中<code>#import "{YOUR\_APP\_MODULE\_NAME}-Swift.h"</code>，再#import第三方库的头文件即可。</p>

<p>PS：由于喵神的APNGKit没有提供每一帧的回调，我还下狠手修改了喵神的代码&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AutoLayout实现的动态TableView高度]]></title>
    <link href="http://hawk0620.github.io/blog/2015/11/21/daymic-tableview-height/"/>
    <updated>2015-11-21T18:15:37+08:00</updated>
    <id>http://hawk0620.github.io/blog/2015/11/21/daymic-tableview-height</id>
    <content type="html"><![CDATA[<p>本文将介绍下AutoLayout使用纯代码来实现TableView的动态高度。</p>

<p>效果图如下：
<img src="https://cloud.githubusercontent.com/assets/5633917/11318437/e0909810-908c-11e5-849b-4a40adc10c18.png" alt="dd" /></p>

<p>1、子类化一个UITableViewCell，定义三个控件：</p>

<pre><code>@property (nonatomic, strong) ZPLabel *titleLabel;
@property (nonatomic, strong) ZPLabel *subtitleLabel;
@property (nonatomic, strong) UIImageView *customImageView;
</code></pre>

<p>再在.m文件中创建这三个控件，并添加进<code>cell</code>的<code>contentView</code>中，最后为这三个控件添加约束，这里用到了<code>Masonry</code>：</p>

<!--more-->


<pre><code>// customImageView constraint
[self.customImageView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.top.equalTo(self.contentView.mas_top).with.offset(20);
    make.bottom.lessThanOrEqualTo(self.contentView.mas_bottom)
    .with.offset(-20);
        make.leading.equalTo(self.contentView.mas_leading).with
        .offset(20);
    make.width.equalTo(@100).with.priority(999);
    make.height.equalTo(@100).with.priority(999);
}];
// titleLabel constraint
[self.titleLabel mas_makeConstraints:^(MASConstraintMaker *make) {
   make.top.equalTo(self.contentView.mas_top).with.offset(20);
   make.trailing.equalTo(self.contentView.mas_trailing).with
       .offset(-20);
   make.leading.equalTo(self.customImageView.mas_trailing).with
   .offset(8);
}];
// subtitleLabel constraint
UIEdgeInsets subTitlePadding = UIEdgeInsetsMake(0, 8, -20, -20);
[self.subtitleLabel mas_makeConstraints:^(MASConstraintMaker *make) {
    make.top.equalTo(self.titleLabel.mas_bottom).with
   .offset(subTitlePadding.top);
   make.trailing.equalTo(self.contentView.mas_trailing).with
   .offset(subTitlePadding.right);
   make.bottom.lessThanOrEqualTo(self.contentView.mas_bottom).
   with.offset(subTitlePadding.bottom);
   make.leading.equalTo(self.customImageView.mas_trailing)
   .with.offset(subTitlePadding.left);
}];
</code></pre>

<p>2、在viewController中的<code>tableView:cellForRowAtIndexPath:</code>方法里对每次设置完<code>titleLabel </code>和<code>subtitleLabel</code>的text属性后都要调用<code>invalidateIntrinsicContentSize</code>来重新计算<code>label</code>的内置大小<code>intrinsicContentSize</code>：</p>

<pre><code>// cell title
NSString *title = item[@"title"];
[cell.titleLabel setText:title];
[cell.titleLabel invalidateIntrinsicContentSize];
// cell subtitle
NSString *subtitle = item[@"context"];
if (subtitle.length &gt; 200) {
   subtitle = [NSString stringWithFormat:@"%@...", [subtitle substringToIndex:200]];
}
[cell.subtitleLabel setText:subtitle];
[cell.subtitleLabel invalidateIntrinsicContentSize];
</code></pre>

<p>3、最后在<code>heightForImageCellAtIndexPath:</code>中通过重新布局和使用<code>systemLayoutSizeFittingSize:</code>计算出cell的高度：</p>

<pre><code>sizingCell.bounds = CGRectMake(0.0f, 0.0f, CGRectGetWidth(self.tableView.frame), CGRectGetHeight(sizingCell.bounds));

[sizingCell setNeedsLayout];
[sizingCell layoutIfNeeded];

CGSize size = [sizingCell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize];
return size.height + 1.0f;
</code></pre>

<p>最后附上<a href="https://github.com/hawk0620/DaymicTableDemo">源码链接</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[探索向～iOS视频播放]]></title>
    <link href="http://hawk0620.github.io/blog/2015/11/17/ios-play-video/"/>
    <updated>2015-11-17T21:50:18+08:00</updated>
    <id>http://hawk0620.github.io/blog/2015/11/17/ios-play-video</id>
    <content type="html"><![CDATA[<h4>从体验说起</h4>

<p>&emsp;&emsp;对比微信和Instagram可以发现播放视频的两个思路：微信的处理是把视频加载好后播放，这样确保了视频是完整的，用户很直观视频是否下载完成，不影响用户观看视频的体验；而Instagram的做法是边加载边播，当网络不给力的时候，视频就卡在那里，给用户增加了观看视频的焦虑，并且用户还得自己判断下视频是不是加载完成了，最不幸的是，当视频的网络请求不可达时，不能给出加载失败的提示引导用户重新加载，只能滑动列表触发刷新。</p>

<h4>播放视频的实现</h4>

<p>1、通过实践，我发现Instagram采用的应该是<code>AVPlayer</code>实现的。</p>

<!--more-->


<p><code>AVPlayerItem</code>可以通过远程URL创建出来，并且支持流的形式播放，还可以添加视频播放卡住和视频播放完成的两个观察者：</p>

<pre><code>[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(itemDidBufferPlaying:) name:AVPlayerItemPlaybackStalledNotification object:nil];
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(itemDidFinishPlaying:) name:AVPlayerItemDidPlayToEndTimeNotification object:nil];
</code></pre>

<p>但遗憾的是，我没有找到视频加载失败的观察者。</p>

<p>2、结合微信团队的技术分享<a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=207686973&amp;idx=1&amp;sn=1883a6c9fa0462dd5596b8890b6fccf6&amp;scene=0#wechat_redirect">链接</a>，得知微信的视频播放是采用<code>AVAssetReader</code>+<code>AVAssetReaderTrackOutput</code>，根据微信的思路，自己也尝试实现了一番：
buffer的转换：</p>

<pre><code>- (CGImageRef) imageFromSampleBuffer:(CMSampleBufferRef) sampleBuffer {
   CVImageBufferRef imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer);
   // Lock the base address of the pixel buffer
   CVPixelBufferLockBaseAddress(imageBuffer, 0);
   // Get the number of bytes per row for the pixel buffer
   size_t bytesPerRow = CVPixelBufferGetBytesPerRow(imageBuffer);
   // Get the pixel buffer width and height
   size_t width = CVPixelBufferGetWidth(imageBuffer);
   size_t height = CVPixelBufferGetHeight(imageBuffer);
   //Generate image to edit
   unsigned char* pixel = (unsigned char *)CVPixelBufferGetBaseAddress(imageBuffer);
   CGColorSpaceRef colorSpace=CGColorSpaceCreateDeviceRGB();
   CGContextRef context=CGBitmapContextCreate(pixel, width, height, 8, bytesPerRow, colorSpace, kCGBitmapByteOrder32Little|kCGImageAlphaPremultipliedFirst);
   CGImageRef image = CGBitmapContextCreateImage(context);
   CGContextRelease(context);
   CGColorSpaceRelease(colorSpace);
   return image;
}
</code></pre>

<p>视频的解码：</p>

<pre><code>AVURLAsset *asset = [AVURLAsset URLAssetWithURL:[[NSURL alloc] initFileURLWithPath:path] options:nil];
NSError *error;
AVAssetReader* reader = [[AVAssetReader alloc] initWithAsset:asset error:&amp;error];
NSArray* videoTracks = [asset tracksWithMediaType:AVMediaTypeVideo];
AVAssetTrack* videoTrack = [videoTracks objectAtIndex:0];

int m_pixelFormatType = kCVPixelFormatType_32BGRA;
NSDictionary* options = [NSDictionary dictionaryWithObject:[NSNumber numberWithInt: (int)m_pixelFormatType] forKey:(id)kCVPixelBufferPixelFormatTypeKey];
AVAssetReaderTrackOutput* videoReaderOutput = [[AVAssetReaderTrackOutput alloc] initWithTrack:videoTrack outputSettings:options];
[reader addOutput:videoReaderOutput];
[reader startReading];

// 读取视频每一个buffer转换成CGImageRef
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
   CMSampleBufferRef audioSampleBuffer = NULL;
   while ([reader status] == AVAssetReaderStatusReading &amp;&amp; videoTrack.nominalFrameRate &gt; 0) {
   CMSampleBufferRef sampleBuffer = [videoReaderOutput copyNextSampleBuffer];
   CGImageRef image = [self imageFromSampleBuffer:sampleBuffer];
   if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(mMovieDecoder:onNewVideoFrameReady:)]) {
        [self.delegate mMovieDecoder:self onNewVideoFrameReady:image];
    }
   if(sampleBuffer) {
       if(audioSampleBuffer) { // release old buffer.
            CFRelease(audioSampleBuffer);
            audioSampleBuffer = nil;
       }
       audioSampleBuffer = sampleBuffer;
   } else {
       break;
   }

// 休眠的间隙刚好是每一帧的间隔
   [NSThread sleepForTimeInterval:CMTimeGetSeconds(videoTrack.minFrameDuration)];
 }
 // decode finish
 float durationInSeconds = CMTimeGetSeconds(asset.duration);
  if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(mMovieDecoderOnDecodeFinished:duration:)]) {
     [self.delegate mMovieDecoderOnDecodeFinished:self duration:durationInSeconds];
   }
});
</code></pre>

<p>处理每一帧CGImageRef的回调：</p>

<pre><code>- (void)mMovieDecoder:(VideoDecoder *)decoder onNewVideoFrameReady:(CGImageRef)imgRef {
    __weak PlayBackView *weakView = self;
    dispatch_async(dispatch_get_main_queue(), ^{
        weakView.layer.contents = (__bridge id _Nullable)(imgRef);
    });
}
</code></pre>

<p>处理视频解码完成的回调：</p>

<pre><code>images即每一帧传上来的CGImageRef的数组
- (void)mMovieDecoderOnDecodeFinished:(VideoDecoder *)decoder images:(NSArray *)imgs duration:(float)duration {
    __weak PlayBackView *weakView = self;
    dispatch_async(dispatch_get_main_queue(), ^{
        weakView.layer.contents = nil;

        CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath: @"contents"];
        animation.calculationMode = kCAAnimationDiscrete;
        animation.duration = duration;
        animation.repeatCount = HUGE; //循环播放
        animation.values = images; // NSArray of CGImageRefs
        [weakView.layer addAnimation:animation forKey: @"contents"];
    });
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS拍视频前置摄像头翻转的解决]]></title>
    <link href="http://hawk0620.github.io/blog/2015/11/14/record-video-mirror/"/>
    <updated>2015-11-14T10:18:42+08:00</updated>
    <id>http://hawk0620.github.io/blog/2015/11/14/record-video-mirror</id>
    <content type="html"><![CDATA[<p>前不久在做iOS录制视频遇到了前置摄像头录制的时候视频翻转的问题，相比起以前我做拍照的翻转仅仅只需简单的把图片位置纠正：</p>

<pre><code>UIImage *newImage = [UIImage imageWithCGImage:[image CGImage] scale:1 orientation:UIImageOrientationLeftMirrored];
</code></pre>

<p>视频的翻转就比较麻烦，其大致思路是通过<code>CGAffineTransform</code>变换调整视频在屏幕中的位置，再使用<code>AVMutableVideoComposition</code>进行视频的重新组成，最后使用<code>AVAssetExportSession</code>进行视频的导出即可，以下是翻转以及裁剪出方形视频的代码：</p>

<!--more-->


<pre><code>// your own asset
AVAssetTrack *clipVideoTrack = [[asset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0];

AVMutableVideoComposition* videoComposition = [AVMutableVideoComposition videoComposition];
videoComposition.frameDuration = CMTimeMake(1, 30);

videoComposition.renderSize = CGSizeMake(clipVideoTrack.naturalSize.height, clipVideoTrack.naturalSize.height);

//create a video instruction
AVMutableVideoCompositionInstruction *instruction = [AVMutableVideoCompositionInstruction videoCompositionInstruction];
instruction.timeRange = CMTimeRangeMake(kCMTimeZero, CMTimeMakeWithSeconds(60, 30));

AVMutableVideoCompositionLayerInstruction* transformer = [AVMutableVideoCompositionLayerInstruction videoCompositionLayerInstructionWithAssetTrack:clipVideoTrack];
// 前方高能
CGAffineTransform finalTransform ＝ CGAffineTransformIdentity;
// 翻转，仅是前置摄像头需要
finalTransform = CGAffineTransformMakeScale(-1.0f, 1.0f);
// 视频竖直方向中间的位置
finalTransform = CGAffineTransformTranslate(finalTransform, clipVideoTrack.naturalSize.height, -(clipVideoTrack.naturalSize.width - clipVideoTrack.naturalSize.height) /2);
// finalTransform = CGAffineTransformTranslate(finalTransform, clipVideoTrack.naturalSize.height, 0);视频最顶部的位置
finalTransform = CGAffineTransformRotate(finalTransform, M_PI_2);
finalTransform = CGAffineTransformTranslate(finalTransform, 0.0f, clipVideoTrack.naturalSize.height);

[transformer setTransform:finalTransform atTime:kCMTimeZero];
instruction.layerInstructions = [NSArray arrayWithObject:transformer];
videoComposition.instructions = [NSArray arrayWithObject: instruction];

 // 导出
AVAssetExportSession *exporter = [[AVAssetExportSession alloc] initWithAsset:self.secondAsset presetName:AVAssetExportPresetHighestQuality] ;
exporter.videoComposition = videoComposition;
exporter.outputURL=[NSURL fileURLWithPath:outputPath];
exporter.outputFileType=AVFileTypeQuickTimeMovie;
[exporter exportAsynchronouslyWithCompletionHandler:^(void){
    // your handle with exporter.status
}];
</code></pre>

<p>补充一下，如果不是前置摄像头，如果要裁减出方形的视频只需要：</p>

<pre><code>CGAffineTransform t1 = CGAffineTransformMakeTranslation(track.naturalSize.height, -(track.naturalSize.width - track.naturalSize.height) /2 );
CGAffineTransform t2 = CGAffineTransformRotate(t1, M_PI_2);
</code></pre>

<p>如果需要拍出的视频自定义裁剪的区域，可以指定<code>cropRect</code>，代码如下：</p>

<pre><code>CGFloat cropOffX = cropRect.origin.x;
CGFloat cropOffY = cropRect.origin.y;
CGFloat cropWidth = cropRect.size.width;
CGFloat cropHeight = cropRect.size.height;
videoComposition.renderSize = CGSizeMake(cropWidth, cropHeight);
CGAffineTransform t1 = CGAffineTransformIdentity;
CGAffineTransform t2 = CGAffineTransformIdentity;
t1 = CGAffineTransformMakeTranslation(clipVideoTrack.naturalSize.height - cropOffX, 0 - cropOffY );
t2 = CGAffineTransformRotate(t1, M_PI_2 );
</code></pre>

<p>全文完～</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用CoreAnimation实现的播放按钮]]></title>
    <link href="http://hawk0620.github.io/blog/2015/11/07/player-button/"/>
    <updated>2015-11-07T19:42:48+08:00</updated>
    <id>http://hawk0620.github.io/blog/2015/11/07/player-button</id>
    <content type="html"><![CDATA[<p><img src="https://cloud.githubusercontent.com/assets/5633917/11263321/b48173c6-8ec4-11e5-8e66-5956767adc7d.gif" alt="alt tag" /></p>

<p> 最近做视频播放，需要做一个表示视频正在播放的按钮效果。记录一下实现这功能的经历。</p>

<!--more-->


<p> 首先我使用<code>CABasicAnimation</code>，在按钮的线条滑到下方终点时，通过动画完成的<code>delegate</code>方法:</p>

<pre><code>- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag
</code></pre>

<p> 让线条再到达上方的终点，并以此循环，最终实现线条一上一下的效果。但是在实际中，通过反复给<code>layer</code>添加动画，线条的速率得不到保证，最终会出现线条移动错乱的问题。</p>

<p> 在我陷入困苦之后，<code>CAKeyFrameAnimation</code>映入眼帘，我通过帧动画，把之前线条移到下方终点和上方终点的方法进行优化，帧动画的第一个位置是当前初始位置，其次是下方终点，上方终点，再是初始位置，并为每一帧动画计算了时间。通过帧动画实现了我的需求：）</p>

<p> 源码我已经放到了Github上面:
<a href="https://github.com/hawk0620/ZPPlayerButton">https://github.com/hawk0620/ZPPlayerButton</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义NavigationController转场动画]]></title>
    <link href="http://hawk0620.github.io/blog/2015/08/30/navigation-transition/"/>
    <updated>2015-08-30T08:29:21+08:00</updated>
    <id>http://hawk0620.github.io/blog/2015/08/30/navigation-transition</id>
    <content type="html"><![CDATA[<p> 这篇文章简单介绍下如何自定义UINavigationController转场动画，其大致的思路是:</p>

<!--more-->


<p> 1、实现<UINavigationControllerDelegate>协议的方法:</p>

<pre><code>- (id&lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController
                              animationControllerForOperation:(UINavigationControllerOperation)operation
                                           fromViewController:(UIViewController *)fromVC
                                             toViewController:(UIViewController *)toVC {
    if (fromVC == self &amp;&amp; [toVC isKindOfClass:[YourDestinationController class]]) {
        return [[TransitionAnimator alloc] init];
    }
    else {
        return nil;
    }
}
</code></pre>

<p>2、别忘了在viewDidAppear和viewWillDisappear方法中对delegate属性进行赋值：</p>

<pre><code>- (void)viewDidAppear:(BOOL)animated {
    [super viewDidAppear:animated];
    self.navigationController.delegate = self;
}

- (void)viewWillDisappear:(BOOL)animated {
    [super viewWillDisappear:animated];

    if (self.navigationController.delegate == self) {
        self.navigationController.delegate = nil;
    }
}
</code></pre>

<p>3、然后创建一个名为TransitionAnimator的NSObject子类，让其实现<UIViewControllerAnimatedTransitioning>协议：</p>

<pre><code>- (NSTimeInterval)transitionDuration:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext {
    return duration;
}
- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext {

}
</code></pre>

<p> 4、简单介绍下<code>animateTransition:</code>：</p>

<pre><code>// 返回当前ViewController
UIViewController *fromVC = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];
// 返回目标ViewController
UIViewController *toViewController = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];
// 返回容器视图
UIView *containerView = [transitionContext containerView];
// 返回动画时长
NSTimeInterval duration = [self transitionDuration:transitionContext];
// toViewController.view添加在containerView上
[containerView addSubview:toViewController.view];
</code></pre>

<p> 5、了解了这些基础知识之后，就可以自定义转场动画了，可以使用UIView类方法<code>animateWithDuration</code>，或者Core Animation添加动画:</p>

<pre><code>// 可以对view的alpha值，frame等属性进行
[UIView animateWithDuration:duration animations:^{

} completion:^(BOOL finished) {

    // 动画结束后别忘了告诉我们已经完成了～
    [transitionContext completeTransition:!transitionContext.transitionWasCancelled];
}];
</code></pre>

<p> 或者</p>

<pre><code>// 实现一个类似ping的转场
// -----动画开始------
UIBezierPath *circleMaskPathInitial = [UIBezierPath bezierPathWithOvalInRect:rect];
CGPoint extremePoint = CGPointMake(CGRectGetMidX(rect) - 0, CGRectGetMidY(rect) - CGRectGetHeight(toViewController.view.bounds));
CGFloat radius = sqrt((extremePoint.x*extremePoint.x) + (extremePoint.y*extremePoint.y));
UIBezierPath *circleMaskPathFinal = [UIBezierPath bezierPathWithOvalInRect:CGRectInset(rect, -radius, -radius)];

CAShapeLayer *maskLayer = [CAShapeLayer layer];
maskLayer.path = circleMaskPathFinal.CGPath;
toViewController.view.layer.mask = maskLayer;

CABasicAnimation *maskLayerAnimation = [CABasicAnimation animationWithKeyPath:@"path"];
maskLayerAnimation.fromValue = (__bridge id)(circleMaskPathInitial.CGPath);
maskLayerAnimation.toValue = (__bridge id)(circleMaskPathFinal.CGPath);
maskLayerAnimation.duration = duration;
maskLayerAnimation.delegate = self;
[maskLayer addAnimation:maskLayerAnimation forKey:@"path"];
// -----动画结束------

- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag {
    // 别忘了
    [self.transitionContext completeTransition:!transitionContext.transitionWasCancelled];
    [self.transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey].view.layer.mask = nil;
}
</code></pre>

<p> <img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/10/circle-interactive.gif" alt="" /></p>

<p> 虽然好像大致完成了自定义转场动画，但好像还是少了点什么～如果能在<code>popViewControllerAnimated</code>加上手势是不是更棒呢！</p>

<p> 先添加<code>interactivePopTransition</code>属性：</p>

<pre><code>@property (nonatomic, strong) UIPercentDrivenInteractiveTransition *interactivePopTransition;
</code></pre>

<p> 再实现<code>UINavigationControllerDelegate</code>另一个协议方法：</p>

<pre><code>- (id&lt;UIViewControllerInteractiveTransitioning&gt;)navigationController:(UINavigationController *)navigationController
                     interactionControllerForAnimationController:(id&lt;UIViewControllerAnimatedTransitioning&gt;)animationController {
    // Check if this is for our custom transition
    if ([animationController isKindOfClass:[YourCustomPopAnimator class]]) {
        return self.interactivePopTransition;
    }
    else {
        return nil;
    }
}
</code></pre>

<p>在<code>viewDidLoad</code>中添加手势：</p>

<pre><code>UIScreenEdgePanGestureRecognizer *popRecognizer = [[UIScreenEdgePanGestureRecognizer alloc] initWithTarget:self action:@selector(handlePopRecognizer:)];
popRecognizer.edges = UIRectEdgeLeft;
[self.view addGestureRecognizer:popRecognizer];
</code></pre>

<p>并实现手势方法：</p>

<pre><code>- (void)handlePopRecognizer:(UIScreenEdgePanGestureRecognizer*)recognizer {
    CGFloat progress = [recognizer translationInView:self.view].x / (self.view.bounds.size.width * 1.0);
    progress = MIN(1.0, MAX(0.0, progress));

    if (recognizer.state == UIGestureRecognizerStateBegan) {
        // Create a interactive transition and pop the view controller
        self.interactivePopTransition = [[UIPercentDrivenInteractiveTransition alloc] init];
        [self.navigationController popViewControllerAnimated:YES];
    }
    else if (recognizer.state == UIGestureRecognizerStateChanged) {
        // Update the interactive transition's progress
        [self.interactivePopTransition updateInteractiveTransition:progress];
    }
    else if (recognizer.state == UIGestureRecognizerStateEnded || recognizer.state == UIGestureRecognizerStateCancelled) {
        // Finish or cancel the interactive transition
        if (progress &gt; 0.5) {
            [self.interactivePopTransition finishInteractiveTransition];
        }
        else {
            [self.interactivePopTransition cancelInteractiveTransition];
        }

        self.interactivePopTransition = nil;
    }

}
</code></pre>

<p>最后推荐两篇更详细的教程：</p>

<p>1、<a href="http://dativestudios.com/blog/2013/09/29/interactive-transitions/">interactive-transitions</a>
2、<a href="http://www.raywenderlich.com/86521/how-to-make-a-view-controller-transition-animation-like-in-the-ping-app">实现ping转场动画</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 线程同步: @synchronized指令]]></title>
    <link href="http://hawk0620.github.io/blog/2015/06/02/ios-xian-cheng-tong-bu-at-synchronizedguan-jian-zi/"/>
    <updated>2015-06-02T07:59:59+08:00</updated>
    <id>http://hawk0620.github.io/blog/2015/06/02/ios-xian-cheng-tong-bu-at-synchronizedguan-jian-zi</id>
    <content type="html"><![CDATA[<p> 在之前的一个app中，因为对多线程同步的处理不够好，在某些极端情况下app会发生crash。本文简单介绍一下如何使用<code>@synchronized</code>指令来实现线程安全。苹果文档中对<code>@synchronized</code>指令的说明是：</p>

<p>1.<code>@synchronized</code>指令是Objective-C代码中快捷创建互斥锁的一种方式；</p>

<p>2.<code>@synchronized</code>指令像任何其他的互斥锁一样，防止同一时间不同的线程获取相同的锁。</p>

<p><code>@synchronized</code>指令的使用很简单，只需要传一个参数即可：</p>

<pre><code>@synchronized(key) { 
    // thread-safe code goes here 
}
</code></pre>

<!--more-->


<p>一个简单的例子：</p>

<p>定义一个全局的数组变量</p>

<pre><code>NSMutableArray *array;
</code></pre>

<p>初始化该数组</p>

<pre><code>array = [NSMutableArray arrayWithCapacity:5];
for (int i = 0; i &lt; 5; i++) {
    [array addObject:[NSString stringWithFormat:@"array-%i", i]];
}
</code></pre>

<p>创建更新数组的方法</p>

<pre><code>- (void)updateArray:(NSString *)value {

    for (int j = 0; j &lt; array.count; j++) {

        NSString *currentObject = [array objectAtIndex:j];
        [array replaceObjectAtIndex:j withObject:[currentObject stringByAppendingFormat:@"-%@", value]];

        NSLog(@"%@", [array objectAtIndex:j]);
    }
}
</code></pre>

<p>在不同的线程中调用修改数组的方法</p>

<pre><code>NSString *bla = @"bla";
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    [self updateArray:bla];
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    [self updateArray:bla];
}); 
</code></pre>

<p>得到如下结果</p>

<pre><code>array-0-bla
array-0-bla
array-1-bla
array-1-bla-bla
array-2-bla-bla
array-2-bla
array-3-bla
array-3-bla-bla
array-4-bla
array-4-bla-bla
</code></pre>

<p>显而易见，两个线程在争夺资源，当两个线程彼此作用时可能会导致app的crash。下面，修改一下更新数组的方法：</p>

<pre><code>- (void)updateArray:(NSString *)value {

    @synchronized (value) {
        for (int j = 0; j &lt; array.count; j++) {

            NSString *currentObject = [array objectAtIndex:j];
            [array replaceObjectAtIndex:j withObject:[currentObject stringByAppendingFormat:@"-%@", value]];

            NSLog(@"%@", [array objectAtIndex:j]);
        }
    }
}
</code></pre>

<p>看看结果：</p>

<pre><code>array-0-bla
array-1-bla
array-2-bla
array-3-bla
array-4-bla
array-0-bla-bla
array-1-bla-bla
array-2-bla-bla
array-3-bla-bla
array-4-bla-bla
</code></pre>

<p>这下感觉醒目多了～原因就是<code>@synchronized</code>指令的代码块暂停了其中一个线程，允许另一个线程访问代码块，一旦另一个线程完成工作，就取消暂停。</p>

<p>注意了，如果你使用相同的对象作为<code>@synchronized</code>的key，那么线程将会被暂停（正如刚才所见）。假如使用不同的对象作为<code>@synchronized</code>的key：</p>

<pre><code>NSString *bla = @"bla";
NSString *ola = @"ola";
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    [self updateArray:bla];
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    [self updateArray:ola];
});
</code></pre>

<p>再看看结果：</p>

<pre><code>array-0-bla
array-0-ola
array-1-bla
array-1-bla-ola
array-2-bla
array-2-bla-ola
array-3-bla
array-3-bla-ola
array-4-bla
array-4-bla-ola
</code></pre>

<p>像这种出现多个key的情况，使用</p>

<pre><code>@synchronized (array) { 
    ...
</code></pre>

<p>替换</p>

<pre><code>@synchronized (value) { 
    ...
</code></pre>

<p>这下妥妥了：</p>

<pre><code>array-0-bla
array-1-bla
array-2-bla
array-3-bla
array-4-bla
array-0-bla-ola
array-1-bla-ola
array-2-bla-ola
array-3-bla-ola
array-4-bla-ola
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GCD(semaphore)的日常]]></title>
    <link href="http://hawk0620.github.io/blog/2014/09/20/dispatch-semaphore/"/>
    <updated>2014-09-20T19:36:00+08:00</updated>
    <id>http://hawk0620.github.io/blog/2014/09/20/dispatch-semaphore</id>
    <content type="html"><![CDATA[<p> 当代码块在执行一些特定操作时，比如异步处理，有时需要等待代码块是否执行完成，这时可以通过<code>GCD</code>来帮助我们实现。</p>

<!--more-->


<h3>dispatch_semaphore简介</h3>

<p> <code>dispatch_semaphore_create</code>创建一个带初始值的semaphore；</p>

<p> <code>dispatch_semaphore_signal</code>增加semaphore的计数，并发送semaphore信号；</p>

<p> <code>dispatch_semaphore_wait</code>减少semaphore的计数，并等待semaphore信号的到达。</p>

<p> 示例代码：</p>

<pre><code>dispatch_semaphore_t sem = dispatch_semaphore_create(0);

[self singleBlock:^(id param){
    // your codes...
    dispatch_semaphore_signal(sem);
}];

dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSURLSession的日常]]></title>
    <link href="http://hawk0620.github.io/blog/2014/07/27/daily-nsurlsession/"/>
    <updated>2014-07-27T13:42:05+08:00</updated>
    <id>http://hawk0620.github.io/blog/2014/07/27/daily-nsurlsession</id>
    <content type="html"><![CDATA[<p> 在使用<code>NSURLSessionTaskDelegate</code>的时候，一开始并没有进入<code>URLSession:task:didCompleteWithError:</code>回调，阅读苹果给出的文档之后，成功解决。</p>

<!--more-->


<h3>NSURLSession简介</h3>

<p> <code>NSURLSession</code>是iOS7带来的诸多新特性之一，旨在替换<code>NSURLConnection</code>。<code>NSURLSession</code>的使用非常简单，步骤如下：</p>

<p> 1.创建并配置<code>NSURLSessionConfiguration</code>;</p>

<p> 2.通过步骤一的configuration创建<code>NSURLSession</code>;</p>

<p> 3.创建相应sessionTask(data、upload or download);</p>

<p> 4.调用<code>resume</code>启动task。</p>

<p> 给出一些例子代码：</p>

<pre><code>NSData *imageData = UIImageJPEGRepresentation([UIImage imageNamed:@"panda.jpg"], 0.6);

NSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration];
config.HTTPMaximumConnectionsPerHost = 1;
 [config setHTTPAdditionalHeaders:@{@"example_appkey": @"jfdeh79685eun"}];

NSURLSession *upLoadSession = [NSURLSession sessionWithConfiguration:config];
NSURL *url = [NSURL URLWithString:@"http://example.com"];
NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url];
[request setHTTPMethod:@"PUT"];

NSURLSessionUploadTask *uploadTask = [upLoadSession uploadTaskWithRequest:request fromData:imageData completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
    NSHTTPURLResponse *httpResp = (NSHTTPURLResponse*) response;
    if (!error  &amp;&amp; httpResp.statusCode == 200) {
        //handle...
    }
}];

[[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:YES];
[_uploadTask resume];
</code></pre>

<h2>使用NSURLSessionTaskDelegate</h2>

<p> 修改创建uploadSession方法：</p>

<pre><code>NSURLSession *upLoadSession = [NSURLSession sessionWithConfiguration:config delegate:self delegateQueue:nil];
</code></pre>

<p> 实现<code>&lt;NSURLSessionTaskDelegate&gt;</code>，该委托提供出了能计算上传进度的方法，代码如下：</p>

<pre><code>- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSent totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend
{
    NSLog(@"progress:%f",(double)totalBytesSent / (double)totalBytesExpectedToSend);
}
</code></pre>

<p> 将创建uploadTask方法更改为:</p>

<pre><code>NSURLSessionUploadTask *uploadTask = [upLoadSession uploadTaskWithRequest:request fromData:imageData];
</code></pre>

<p> 当然还有sessionTask完成时的回调：</p>

<pre><code>- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error
{
    dispatch_async(dispatch_get_main_queue(), ^{
        [[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:NO];
    });
    if (!error) {
        //handle..
    } else {
        // Alert for error
    }
}
</code></pre>

<p> 但是该委托方法没有被调用。苹果文档指出，如果使用自定义的委托来获取数据，那么以下方法必须被实现：</p>

<p> <code>URLSession:dataTask:didReceiveData:</code> 一点一点地从你发出地请求中取回数据；
 <code>URLSession:task:didCompleteWithError:</code> 数据被完全接收。</p>

<p> 由此可以看出，还需要实现<code>&lt;NSURLSessionDataDelegate&gt;</code>：</p>

<pre><code>-(void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data
{

}
</code></pre>

<p> 至此，成功进入<code>URLSession:task:didCompleteWithError:</code>。</p>
]]></content>
  </entry>
  
</feed>
